<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN"
                  "JATS-publishing1.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" dtd-version="1.2" article-type="other">
<front>
<journal-meta>
<journal-id></journal-id>
<journal-title-group>
<journal-title>Journal of Open Source Software</journal-title>
<abbrev-journal-title>JOSS</abbrev-journal-title>
</journal-title-group>
<issn publication-format="electronic">2475-9066</issn>
<publisher>
<publisher-name>Open Journals</publisher-name>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="publisher-id">3965</article-id>
<article-id pub-id-type="doi">10.21105/joss.03965</article-id>
<title-group>
<article-title>Castor: A C++ library to code “à la
Matlab”</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author">
<contrib-id contrib-id-type="orcid">0000-0002-2812-7578</contrib-id>
<name>
<surname>Aussal</surname>
<given-names>Matthieu</given-names>
</name>
<xref ref-type="aff" rid="aff-1"/>
</contrib>
<contrib contrib-type="author">
<name>
<surname>Bakry</surname>
<given-names>Marc</given-names>
</name>
<xref ref-type="aff" rid="aff-1"/>
</contrib>
<contrib contrib-type="author">
<name>
<surname>Series</surname>
<given-names>Laurent</given-names>
</name>
<xref ref-type="aff" rid="aff-2"/>
</contrib>
<aff id="aff-1">
<institution-wrap>
<institution>Ecole Polytechnique (CMAP), INRIA, Institut Polytechnique
Paris, Route de Saclay 91128, Palaiseau, France</institution>
</institution-wrap>
</aff>
<aff id="aff-2">
<institution-wrap>
<institution>Ecole Polytechnique (CMAP), Institut Polytechnique Paris,
Route de Saclay 91128, Palaiseau, France</institution>
</institution-wrap>
</aff>
</contrib-group>
<pub-date date-type="pub" publication-format="electronic" iso-8601-date="2021-10-22">
<day>22</day>
<month>10</month>
<year>2021</year>
</pub-date>
<volume>7</volume>
<issue>71</issue>
<fpage>3965</fpage>
<permissions>
<copyright-statement>Authors of papers retain copyright and release the
work under a Creative Commons Attribution 4.0 International License (CC
BY 4.0)</copyright-statement>
<copyright-year>2022</copyright-year>
<copyright-holder>The article authors</copyright-holder>
<license license-type="open-access" xlink:href="https://creativecommons.org/licenses/by/4.0/">
<license-p>Authors of papers retain copyright and release the work under
a Creative Commons Attribution 4.0 International License (CC BY
4.0)</license-p>
</license>
</permissions>
<kwd-group kwd-group-type="author">
<kwd>C++</kwd>
<kwd>Scientific computing</kwd>
<kwd>Fast prototyping</kwd>
<kwd>FEM/BEM simulation</kwd>
</kwd-group>
</article-meta>
</front>
<body>
<sec id="summary">
  <title>Summary</title>
  <p>The objective of the <italic>Castor</italic> framework is to
  propose high-level semantics, inspired by the Matlab language,
  allowing fast software prototyping in a low-level compiled language.
  It is nothing more than a matrix management layer using the tools of
  the standard C++ library (C++14 and later), in different storage
  formats (full, sparse and hierarchical). Linear algebra operations are
  built over the BLAS API and graphic rendering is performed in the VTK
  framework. The <italic>Castor</italic> framework is provided as an
  open source software under the LGPL 3.0, compiled and validated with
  clang and gcc.</p>
</sec>
<sec id="statement-of-need">
  <title>Statement of need</title>
  <p>Matlab is a software used worldwide in numerical prototyping, due
  to its particularly user-friendly semantics and its certified
  toolboxes. However, many use cases do not allow codes in Matlab
  format, for example multi-platform portability issues, proprieraty
  licensing and more generally code interfacing. To start meeting these
  needs, a header-only template library for matrix management has been
  developed, based on the standard C++14 and later library, by
  encapsulating the <monospace>std::vector</monospace> class. Many tools
  and algorithms are provided to simplify the development of
  prototypes:</p>
  <list list-type="bullet">
    <list-item>
      <p>dense, sparse and hierarchical matrices manipulations,</p>
    </list-item>
    <list-item>
      <p>linear algebra computations
      (<xref alt="Anderson et al., 1999" rid="ref-blaslapackU003A00" ref-type="bibr">Anderson
      et al., 1999</xref>),</p>
    </list-item>
    <list-item>
      <p>graphical representations
      (<xref alt="Schroeder et al., 2000" rid="ref-vtkU003A2000" ref-type="bibr">Schroeder
      et al., 2000</xref>).</p>
    </list-item>
  </list>
  <p>This high-level semantic/low-level language coupling makes it
  possible to gain efficiency in the developpement, while ensuring
  performance for applications. In addition, direct access to data
  structures allows users to optimize the most critical parts of their
  code. Finally, a complete documentation is available, as well as
  continuous integration unit tests. All of this makes it possible to
  meet the needs of teaching (notebooks using a C++ interpreter such as
  Cling), academic research and industrial applications at the same
  time.</p>
</sec>
<sec id="state-of-the-field">
  <title>State of the field</title>
  <p>For a developer accustomed to the Matlab language, it is natural to
  turn to prototyping tools such as Numpy or Julia, to produce
  open-source codes. Indeed, these tools today offer similar semantics
  and performance, with well-established user communities. To illustrate
  this similarity, the following codes perform the same tasks, with one
  implementation in Matlab
  (<xref alt="MATLAB, 2010" rid="ref-MATLABU003A2010" ref-type="bibr">MATLAB,
  2010</xref>) (left) and another in Julia
  (<xref alt="Bezanson et al., 2012" rid="ref-bezanson2012julia" ref-type="bibr">Bezanson
  et al., 2012</xref>) (right) :</p>
  <table-wrap>
    <table>
      <colgroup>
        <col width="37%" />
        <col width="3%" />
        <col width="3%" />
        <col width="3%" />
        <col width="53%" />
      </colgroup>
      <thead>
        <tr>
          <th>Matlab</th>
          <th></th>
          <th></th>
          <th></th>
          <th>Julia</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td><monospace>using LinearAlgebra</monospace></td>
        </tr>
        <tr>
          <td><monospace>tic</monospace></td>
          <td></td>
          <td></td>
          <td></td>
          <td><monospace>function test()</monospace></td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <td><monospace>M = [ 1  2  3 ;</monospace></td>
          <td></td>
          <td></td>
          <td></td>
          <td><monospace>M = [ 1  2  3 ;</monospace></td>
        </tr>
        <tr>
          <td><monospace>      4  5  6 ;</monospace></td>
          <td></td>
          <td></td>
          <td></td>
          <td><monospace>      4  5  6 ;</monospace></td>
        </tr>
        <tr>
          <td><monospace>      7  8  9 ;</monospace></td>
          <td></td>
          <td></td>
          <td></td>
          <td><monospace>      7  8  9 ;</monospace></td>
        </tr>
        <tr>
          <td><monospace>     10 11 12];</monospace></td>
          <td></td>
          <td></td>
          <td></td>
          <td><monospace>     10 11 12];</monospace></td>
        </tr>
        <tr>
          <td><monospace>disp(M);</monospace></td>
          <td></td>
          <td></td>
          <td></td>
          <td><monospace>display(M);</monospace></td>
        </tr>
        <tr>
          <td><monospace>M = (M - 1) .* ...</monospace></td>
          <td></td>
          <td></td>
          <td></td>
          <td><monospace>M = (M .- 1) .*</monospace></td>
        </tr>
        <tr>
          <td><monospace>eye(size(M));</monospace></td>
          <td></td>
          <td></td>
          <td></td>
          <td><monospace>Matrix(I,size(M));</monospace></td>
        </tr>
        <tr>
          <td><monospace>M(1,1) = -1;</monospace></td>
          <td></td>
          <td></td>
          <td></td>
          <td><monospace>M[1,1] = -1;</monospace></td>
        </tr>
        <tr>
          <td><monospace>M([2,3],1)  = -1;</monospace></td>
          <td></td>
          <td></td>
          <td></td>
          <td><monospace>M[[2 3],1] .= -1;</monospace></td>
        </tr>
        <tr>
          <td><monospace>M(4,:) = -1;</monospace></td>
          <td></td>
          <td></td>
          <td></td>
          <td><monospace>M[4,:] .= -1;</monospace></td>
        </tr>
        <tr>
          <td><monospace>disp(M);</monospace></td>
          <td></td>
          <td></td>
          <td></td>
          <td><monospace>display(M);</monospace></td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <td><monospace>disp(sum(M,2));</monospace></td>
          <td></td>
          <td></td>
          <td></td>
          <td><monospace>display(sum(M,dims=2));</monospace></td>
        </tr>
        <tr>
          <td><monospace>disp(abs(M));</monospace></td>
          <td></td>
          <td></td>
          <td></td>
          <td><monospace>display(abs.(M))</monospace></td>
        </tr>
        <tr>
          <td><monospace>disp(sort(M,1));</monospace></td>
          <td></td>
          <td></td>
          <td></td>
          <td><monospace>display(sort(M,dims=1));</monospace></td>
        </tr>
        <tr>
          <td><monospace>disp(M*M');</monospace></td>
          <td></td>
          <td></td>
          <td></td>
          <td><monospace>display(M*M');</monospace></td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td><monospace>end</monospace></td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <td><monospace>toc</monospace></td>
          <td></td>
          <td></td>
          <td></td>
          <td><monospace>@time test();</monospace></td>
        </tr>
        <tr>
          <td><monospace>disp(&quot;done.&quot;);</monospace></td>
          <td></td>
          <td></td>
          <td></td>
          <td><monospace>display(&quot;done.&quot;);</monospace></td>
        </tr>
      </tbody>
    </table>
  </table-wrap>
  <p>Despite the many advantages that these languages have and their
  high popularity, many codes are still developed natively in Fortran,
  C, and C++, for practical or historical reasons. Even if there are
  tools to automatically generate C/C++ code from a high-level language
  (as <italic>Matlab Coder</italic>), this work is often done manually
  by specialists. To find high-level semantics in native C++, we can
  turn to libraries like Eigen
  (<xref alt="Guennebaud et al., 2010" rid="ref-eigenweb" ref-type="bibr">Guennebaud
  et al., 2010</xref>), which offers a matrix API and efficient algebra
  tools. However, as the comparison below shows, the transcription from
  a Matlab code to an Eigen-based C++ code is not immediate:</p>
  <code language="c++">#include &lt;iostream&gt;
#include &lt;chrono&gt;
#include &lt;eigen-3.4.0/Eigen/Dense&gt;
using namespace std::chrono;
using namespace Eigen;
int main()
{
    auto tic = high_resolution_clock::now();
    
    MatrixXd  M(4,3);
    M &lt;&lt; 1,  2,  3,
        4,  5,  6,
        7,  8,  9,
       10, 11, 12;
    std::cout &lt;&lt; M &lt;&lt; std::endl;
    
    M.array() -= 1;
    M.array() *= MatrixXd::Identity(M.rows(),M.cols()).array();
    M(0,0)     = -1;
    M.block&lt;2,1&gt;(1,0) = -MatrixXd::Ones(2,1);
    M.row(3)   = -MatrixXd::Ones(1,3);
    std::cout &lt;&lt; M &lt;&lt; std::endl;

    std::cout &lt;&lt; M.rowwise().sum() &lt;&lt; std::endl;
    std::cout &lt;&lt; M.array().abs() &lt;&lt; std::endl;    
    MatrixXd  Ms = M;
    for(auto col : Ms.colwise())
    {
      std::sort(col.begin(), col.end());
    }
    std::cout &lt;&lt; Ms &lt;&lt; std::endl;
    std::cout &lt;&lt; M * M.transpose() &lt;&lt; std::endl;
    
    auto toc  = high_resolution_clock::now();
    auto duration = duration_cast&lt;microseconds&gt;(toc - tic);
    std::cout &lt;&lt; &quot;Elapsed time: &quot; &lt;&lt; duration.count()*1e-6 &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;done.&quot; &lt;&lt; std::endl;

    return 0;
}</code>
  <p>To complete this example, other references are available on this
  <ext-link ext-link-type="uri" xlink:href="https://eigen.tuxfamily.org/dox/AsciiQuickReference.txt">link</ext-link>.
  This is why all the features of the Castor library have been designed
  and developed so that the semantics at user level are as close to
  Matlab as what C++ allows. Moreover, to gain in portability, the
  manipulations of full matrices and the main algorithms depend only on
  the standard library which is available on the most majority of
  operating systems (MacOS, Linux, Windows, Android, etc.). Only
  advanced linear algebra tools require an external BLAS / LAPACK API,
  as well as graphical visualization functionality (VTK). The example
  below illustrates this goal:</p>
  <table-wrap>
    <table>
      <colgroup>
        <col width="42%" />
        <col width="4%" />
        <col width="4%" />
        <col width="4%" />
        <col width="45%" />
      </colgroup>
      <thead>
        <tr>
          <th>Matlab</th>
          <th></th>
          <th></th>
          <th></th>
          <th>Castor</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td><monospace>#include &quot;castor/matrix.hpp&quot;</monospace></td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td><monospace>using namespace castor;</monospace></td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td><monospace>int main (int argc, char* argv[])</monospace></td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td><monospace>{</monospace></td>
        </tr>
        <tr>
          <td><monospace>tic</monospace></td>
          <td></td>
          <td></td>
          <td></td>
          <td><monospace>tic();</monospace></td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <td><monospace>M = [ 1  2  3 ;</monospace></td>
          <td></td>
          <td></td>
          <td></td>
          <td><monospace>M = {{ 1,  2,  3},</monospace></td>
        </tr>
        <tr>
          <td><monospace>      4  5  6 ;</monospace></td>
          <td></td>
          <td></td>
          <td></td>
          <td><monospace>     { 4,  5,  6},</monospace></td>
        </tr>
        <tr>
          <td><monospace>      7  8  9 ;</monospace></td>
          <td></td>
          <td></td>
          <td></td>
          <td><monospace>     { 7,  8,  9},</monospace></td>
        </tr>
        <tr>
          <td><monospace>     10 11 12];</monospace></td>
          <td></td>
          <td></td>
          <td></td>
          <td><monospace>     {10, 11, 12}};</monospace></td>
        </tr>
        <tr>
          <td><monospace>disp(M);</monospace></td>
          <td></td>
          <td></td>
          <td></td>
          <td><monospace>disp(M);</monospace></td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <td><monospace>M = (M - 1) .* eye(size(M));</monospace></td>
          <td></td>
          <td></td>
          <td></td>
          <td><monospace>M = (M - 1) * eye(size(M));</monospace></td>
        </tr>
        <tr>
          <td><monospace>M(1,1) = -1;</monospace></td>
          <td></td>
          <td></td>
          <td></td>
          <td><monospace>M(0,0) = -1;</monospace></td>
        </tr>
        <tr>
          <td><monospace>M([2,3],1)  = -1;</monospace></td>
          <td></td>
          <td></td>
          <td></td>
          <td><monospace>M({1,2},0) = -1;</monospace></td>
        </tr>
        <tr>
          <td><monospace>M(4,:) = -1;</monospace></td>
          <td></td>
          <td></td>
          <td></td>
          <td><monospace>M(3,col(M)) = -1;</monospace></td>
        </tr>
        <tr>
          <td><monospace>disp(M);</monospace></td>
          <td></td>
          <td></td>
          <td></td>
          <td><monospace>disp(M);</monospace></td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <td><monospace>disp(sum(M,2));</monospace></td>
          <td></td>
          <td></td>
          <td></td>
          <td><monospace>disp(sum(M,2));</monospace></td>
        </tr>
        <tr>
          <td><monospace>disp(abs(M));</monospace></td>
          <td></td>
          <td></td>
          <td></td>
          <td><monospace>disp(abs(M));</monospace></td>
        </tr>
        <tr>
          <td><monospace>disp(sort(M,1));</monospace></td>
          <td></td>
          <td></td>
          <td></td>
          <td><monospace>disp(sort(M,1));</monospace></td>
        </tr>
        <tr>
          <td><monospace>disp(M*M');</monospace></td>
          <td></td>
          <td></td>
          <td></td>
          <td><monospace>disp(mtimes(M,transpose(M)));</monospace></td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <td><monospace>toc</monospace></td>
          <td></td>
          <td></td>
          <td></td>
          <td><monospace>toc();</monospace></td>
        </tr>
        <tr>
          <td><monospace>disp(&quot;done.&quot;);</monospace></td>
          <td></td>
          <td></td>
          <td></td>
          <td><monospace>disp(&quot;done.&quot;);</monospace></td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td><monospace>return 0;</monospace></td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td><monospace>}</monospace></td>
        </tr>
      </tbody>
    </table>
  </table-wrap>
  <p><bold>Note:</bold> It is important to specify that the Castor
  library is far from offering today all the functionalities offered by
  Matlab and its many toolboxes.</p>
</sec>
<sec id="dense-matrix">
  <title>Dense Matrix</title>
  <p>The dense matrix part of the <italic>Castor</italic> framework
  implements its own templatized class
  <monospace>matrix&lt;T&gt;</monospace> in
  <monospace>matrix.hpp</monospace>, where <monospace>T</monospace> can
  be fundamental types of C++ as well as
  <monospace>std::complex</monospace>. This class is built over a
  <monospace>std::vector&lt;T&gt;</monospace> which holds the values
  (<xref alt="ISO/IEC, 2014" rid="ref-cppU003A14" ref-type="bibr">ISO/IEC,
  2014</xref>). Note that the element of a matrix is stored in row-major
  order and that a vector is considered as a
  <inline-formula><alternatives>
  <tex-math><![CDATA[1\times n]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mn>1</mml:mn><mml:mo>×</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
  or <inline-formula><alternatives>
  <tex-math><![CDATA[n\times 1]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>n</mml:mi><mml:mo>×</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></alternatives></inline-formula>
  matrix.</p>
  <p>The class <monospace>matrix&lt;T&gt;</monospace> provides many
  useful functions and operators such as:</p>
  <list list-type="bullet">
    <list-item>
      <p>builders which can be used to initialize all coefficients
      (<monospace>zeros</monospace>, <monospace>ones</monospace>,
      <monospace>eye</monospace>, etc.),</p>
    </list-item>
    <list-item>
      <p>standard algorithms over data stored in matrices
      (<monospace>norm</monospace>, <monospace>max</monospace>,
      <monospace>sort</monospace>, <monospace>argsort</monospace>,
      etc.),</p>
    </list-item>
    <list-item>
      <p>mathematical functions which can be applied element-wise
      (<monospace>cos</monospace>, <monospace>sqrt</monospace>,
      <monospace>conj</monospace>, etc.),</p>
    </list-item>
    <list-item>
      <p>matrix manipulations like concatenate matrices in all
      dimensions, find the non-zero elements or transpose them, reshape
      size, etc.,</p>
    </list-item>
    <list-item>
      <p>standard C++ operators which have been overloaded and work
      element-wise
      (<monospace>+</monospace>,<monospace>*</monospace>,<monospace>!</monospace>,<monospace>&amp;&amp;</monospace>,etc.),</p>
    </list-item>
    <list-item>
      <p>values accessors and matrix views with linear and bi-linear
      indexing,</p>
    </list-item>
    <list-item>
      <p>elements of linear algebra, such as the matrix product
      (<monospace>mtimes</monospace> or <monospace>tgemm</monospace>)
      and linear system resolution (multi-right-hand-side
      <monospace>gmres</monospace>),</p>
    </list-item>
    <list-item>
      <p>many other tools to display elements
      (<monospace>&lt;&lt;</monospace>, <monospace>disp</monospace>),
      save and load elements from file (ASCII or binary), etc.</p>
    </list-item>
  </list>
  <p>The API provides more than a hundred functions and is designed such
  that it should feel like using Matlab. For advanced users, direct
  access to the data stored in the
  <monospace>std::vector&lt;T&gt;</monospace> enables all or part of an
  algorithm to be optimized in native C++.</p>
  <p>This example displays the sum of two matrices with implicit cast
  :</p>
  <code language="c++">#include &lt;iostream&gt;
#include &quot;castor/matrix.hpp&quot;
using namespace castor;
int main(int argc, char* argv[])
{
    matrix&lt;float&gt; A = {{ 1.0,  2.0,  3.0,  4.0},
                       { 5.0,  6.0,  7.0,  8.0},
                       { 9.0, 10.0, 11.0, 12.0}};
    matrix&lt;double&gt; B = eye(3,4);
    auto C = A + B;
    disp(C);
    return 0;
}</code>
  <preformat>Matrix 3x4 of type 'd' (96 B):
    2.00000      2.00000      3.00000      4.00000  
    5.00000      7.00000      7.00000      8.00000  
    9.00000     10.00000     12.00000     12.00000  </preformat>
</sec>
<sec id="linear-algebra">
  <title>Linear Algebra</title>
  <p>The linear algebra part of the framework, implemented in
  <monospace>linalg.hpp</monospace>, provides a set of useful functions
  to perform linear algebra computations by linking to optimized
  implementations of the BLAS and LAPACK standards
  (<xref alt="Anderson et al., 1999" rid="ref-blaslapackU003A00" ref-type="bibr">Anderson
  et al., 1999</xref>) (OpenBLAS, oneAPI MKL, etc.).</p>
  <p>The BLAS part is a straightforward overlay of the C-BLAS type III
  API, which is compatible with row-major ordering. This is achieved by
  a template specialization of the <monospace>tgemm</monospace>
  function, which allows optimized implementations to take control of
  the computation using <monospace>sgemm</monospace>,
  <monospace>dgemm</monospace>, <monospace>cgemm</monospace> and
  <monospace>zgemm</monospace>. Thanks to this interface, naive
  implementations proposed in <monospace>matrix.hpp</monospace> for
  dense matrix-products <monospace>mtimes</monospace> and
  <monospace>tgemm</monospace> may be improved in term of performance,
  especially for large matrices.</p>
  <p>The LAPACK part is a direct overlay over the Fortran LAPACK API,
  which uses a column ordering storage convention. This interface brings
  new high-level functionalities, such as a linear solver
  (<monospace>linsolve</monospace>), matrix inversion
  (<monospace>inv</monospace>, <monospace>pinv</monospace>),
  factorizations (<monospace>qr</monospace>, <monospace>lu</monospace>),
  the search for eigen or singular values decompositions
  (<monospace>eig</monospace> ,<monospace>svd</monospace>), aca
  compression (<monospace>aca</monospace>), etc. It uses templatized
  low-level functions following the naming convention close to the
  LAPACK one (like <monospace>tgesdd</monospace>,
  <monospace>tgeqrf</monospace>, etc.).</p>
  <p>This example displays the product of <inline-formula><alternatives>
  <tex-math><![CDATA[A]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>A</mml:mi></mml:math></alternatives></inline-formula>
  and <inline-formula><alternatives>
  <tex-math><![CDATA[A^{-1}]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msup><mml:mi>A</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:math></alternatives></inline-formula>
  :</p>
  <code language="c++">#include &lt;iostream&gt;
#include &quot;castor/matrix.hpp&quot;
#include &quot;castor/linalg.hpp&quot;
using namespace castor;
int main (int argc, char* argv[])
{
    matrix&lt;&gt; A = rand(4);
    matrix&lt;&gt; Am1 = inv(A); 
    disp(mtimes(A,Am1));
    return 0;
}</code>
  <preformat>Matrix 4x4 of type 'd' (128 B):
 1.0000e+00   1.0408e-16  -2.7756e-17  -5.5511e-17  
          0   1.0000e+00  -5.5511e-17   1.1102e-16  
          0  -2.2204e-16   1.0000e+00  -1.1102e-16  
-2.7756e-17            0            0   1.0000e+00  </preformat>
  <p><bold>Note:</bold> The backslash operator
  (<monospace>\</monospace>) not being available, the
  <monospace>linsolve</monospace> function allows to solve linear
  systems with:</p>
  <list list-type="bullet">
    <list-item>
      <p>LU decomposition with partial pivoting and row interchanges for
      square matrices (<monospace>[sdcz]gesv</monospace>),</p>
    </list-item>
    <list-item>
      <p>QR or LQ factorization for overdetermined or underdetermined
      linear systems (<monospace>[sdcz]gels</monospace>).</p>
    </list-item>
  </list>
  <p>In addition, an iterative multi-right-hand-side solver
  <monospace>gmres</monospace> is available in
  <monospace>matrix.hpp</monospace>, without dependency on BLAS and
  LAPACK.</p>
</sec>
<sec id="d3d-visualization">
  <title>2D/3D Visualization</title>
  <p>The graphic rendering part, provided by
  <monospace>graphics.hpp</monospace>, features 2D/3D customizable
  plotting and basic mesh generation. It is based on the well-known VTK
  library
  (<xref alt="Schroeder et al., 2000" rid="ref-vtkU003A2000" ref-type="bibr">Schroeder
  et al., 2000</xref>). Here again, the approach tries to get as close
  as possible to Matlab semantics.</p>
  <p>First, the user creates a <monospace>figure</monospace>, which is a
  dynamic container of data to display. The
  <monospace>figure</monospace> class is composed of a
  <monospace>vtkContextView</monospace> class, providing a view with a
  default interactor style, renderer, etc. Then, graphic representations
  can be added to the figure, using functions like
  <monospace>plot</monospace>, <monospace>imagesc</monospace>,
  <monospace>plot3</monospace>, <monospace>mesh</monospace>, etc.
  Options are available to customize the display of the results, such as
  the plotting style, legend, colorbar and others basic stuff. Finally,
  the <monospace>drawnow</monospace> function must be called to display
  all defined figures. The latters are displayed and manipulated in
  independent windows.</p>
  <p>In addition, graphics exports are available in different
  compression formats
  (<monospace>png</monospace>,<monospace>jpg</monospace>,
  <monospace>tiff</monospace>, etc.), as well as video rendering
  (<monospace>ogg</monospace>).</p>
  <p>This example shows a basic 2D plotting of a sine function
  (<xref alt="Figure 1" rid="figU003Asin">Figure 1</xref>):</p>
  <code language="c++">#include &quot;castor/matrix.hpp&quot;
#include &quot;castor/graphics.hpp&quot; 
using namespace castor;
int main (int argc, char* argv[])
{
    matrix&lt;&gt; X = linspace(0,10,100);
    figure fig;
    plot(fig,X,sin(X),{&quot;r-+&quot;},{&quot;sin(x)&quot;});
    plot(fig,X,cos(X),{&quot;bx&quot;},{&quot;cos(x)&quot;});
    drawnow(fig);
    return 0;
}</code>
  <fig>
    <caption><p>Basic 2D plotting from Castor (using
    VTK).<styled-content id="figU003Asin"></styled-content></p></caption>
    <graphic mimetype="image" mime-subtype="png" xlink:href="media/plot2d.png" xlink:title="" />
  </fig>
</sec>
<sec id="sparse-matrices">
  <title>Sparse matrices</title>
  <p>Some matrices have sparse structures, with many (many) zeros that
  do not need to be stored
  (<xref alt="Tewarson, 1973" rid="ref-sparseU003A1973" ref-type="bibr">Tewarson,
  1973</xref>). There are adapted storage formats for this type of
  structure (LIL, COO, CSR, etc.), the most natural being to store the
  indices of rows and columns for each non-zero value, as a list of
  triplet <inline-formula><alternatives>
  <tex-math><![CDATA[\{i,j,v\}]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo stretchy="false" form="prefix">{</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false" form="postfix">}</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>.
  For the <italic>Castor</italic> framework, a dedicated template class
  to this kind of matrix has been developed (see
  <monospace>smatrix.hpp</monospace>). The storage format is based on a
  row major sorted linear indexing. Only non-zero values and their
  sorted linear indices are stored in a list of pairs
  <inline-formula><alternatives>
  <tex-math><![CDATA[\{v,l\}]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo stretchy="false" form="prefix">{</mml:mo><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>l</mml:mi><mml:mo stretchy="false" form="postfix">}</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>:
  for a <inline-formula><alternatives>
  <tex-math><![CDATA[m\times n]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>m</mml:mi><mml:mo>×</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
  matrix, the following bijection is used to switch with the common
  bilinear indexation:</p>
  <p><disp-formula><alternatives>
  <tex-math><![CDATA[
  \begin{aligned}
  \{i,j\} &\rightarrow l = i \cdot n + j, \\
  l &\rightarrow \{i=\frac{l}{n}; j= i\textrm{ mod }n\}.
  \end{aligned}
  ]]></tex-math>
  <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mtable><mml:mtr><mml:mtd columnalign="right"><mml:mo stretchy="false" form="prefix">{</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false" form="postfix">}</mml:mo></mml:mtd><mml:mtd columnalign="left"><mml:mo>→</mml:mo><mml:mi>l</mml:mi><mml:mo>=</mml:mo><mml:mi>i</mml:mi><mml:mo>⋅</mml:mo><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mi>j</mml:mi><mml:mo>,</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right"><mml:mi>l</mml:mi></mml:mtd><mml:mtd columnalign="left"><mml:mo>→</mml:mo><mml:mo stretchy="false" form="prefix">{</mml:mo><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mi>l</mml:mi><mml:mi>n</mml:mi></mml:mfrac><mml:mo>;</mml:mo><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mi>i</mml:mi><mml:mrow><mml:mspace width="0.333em"></mml:mspace><mml:mtext mathvariant="normal"> mod </mml:mtext><mml:mspace width="0.333em"></mml:mspace></mml:mrow><mml:mi>n</mml:mi><mml:mo stretchy="false" form="postfix">}</mml:mo><mml:mi>.</mml:mi></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p>
  <p>Accessors to all the elements are provided so that sparse matrices
  can be manipulated in a similar way as the dense matrices. This
  operation is performed by dichotomy with a convergence in
  <inline-formula><alternatives>
  <tex-math><![CDATA[\log_2 (\text{nnz})]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mo>log</mml:mo><mml:mn>2</mml:mn></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mtext mathvariant="normal">nnz</mml:mtext><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>,
  where <inline-formula><alternatives>
  <tex-math><![CDATA[\text{nnz}]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mtext mathvariant="normal">nnz</mml:mtext></mml:math></alternatives></inline-formula>
  is the number of non-zero elements. Just like dense matrices,
  numerical values are stored in a templatized
  <monospace>std::vector&lt;T&gt;</monospace>. For convenience, we
  provide classical builders (<monospace>sparse</monospace>,
  <monospace>speye</monospace>, <monospace>spdiags</monospace>, etc.),
  standard C++ operators overloading, views, display functions
  (<monospace>disp</monospace>, <monospace>spy</monospace>) and some
  linear algebra tools (<monospace>transpose</monospace>,
  <monospace>mtimes</monospace>, <monospace>gmres</monospace>,
  etc.).</p>
  <p>This example displays the sum of two sparse matrices, with implicit
  cast and sparse to dense conversion :</p>
  <code language="c++">#include &lt;iostream&gt;
#include &quot;castor/smatrix.hpp&quot;
using namespace castor;
int main (int argc, char* argv[])
{
    smatrix&lt;float&gt; As = {{0.0,  0.0,  0.0},
                         {5.0,  0.0,  7.0}};
    As(0,1) = 2.0;
    smatrix&lt;double&gt; Bs = speye(2,3);
    disp(As);
    disp(As(0,1)); // bilinear accessor
    disp(As(4));   // linear accessor
    disp(Bs);
    disp(full(As+Bs));
    return 0;
}</code>
  <preformat>Sparse matrix 2x3 of type 'f' with 3 elements (12 B):
(0,1)  2
(1,0)  5
(1,2)  7
2
0
Sparse matrix 2x3 of type 'd' with 2 elements (16 B):
(0,0)  1
(1,1)  1
Matrix 2x3 of type 'd' (48 B):
    1.00000      2.00000            0  
    5.00000      1.00000      7.00000  </preformat>
</sec>
<sec id="hierarchical-matrices">
  <title>Hierarchical matrices</title>
  <p>To widen the field of applications, the
  <inline-formula><alternatives>
  <tex-math><![CDATA[\mathcal H]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mstyle mathvariant="script"><mml:mi>ℋ</mml:mi></mml:mstyle></mml:math></alternatives></inline-formula>-matrix
  format, so-called hierachical matrices
  (<xref alt="Hackbusch, 1999" rid="ref-hackbushU003A1999" ref-type="bibr">Hackbusch,
  1999</xref>), have been added in <monospace>hmatrix.hpp</monospace>.
  They are specially designed for matrices with localized rank defaults.
  It allows a fully-populated matrix to be assembled and stored in a
  lighter format by compressing some parts of the original dense matrix
  using a low-rank representation
  (<xref alt="Rjasanow, 2002" rid="ref-rjasanowU003A2002" ref-type="bibr">Rjasanow,
  2002</xref>). They are constructed by binary tree subdivisions in a
  recursive way, with a parallel assembly of the compressed and full
  leaves (using the OpenMP standard). This format features a complete
  algebra, from elementary operations to matrix inversion. An example is
  given in the application section that follows.</p>
</sec>
<sec id="application-with-a-fembem-simulation">
  <title>Application with a FEM/BEM simulation</title>
  <p>As an application example, an acoustical scattering simulation was
  carried out using a boundary element method (BEM) tool, implemented
  with the <italic>Castor</italic> framework (see the
  <italic>fembem</italic> package
  (<xref alt="Aussal &amp; Bakry, 2021" rid="ref-fembemU003A21" ref-type="bibr">Aussal
  &amp; Bakry, 2021</xref>)). We consider a smooth
  <inline-formula><alternatives>
  <tex-math><![CDATA[n]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>n</mml:mi></mml:math></alternatives></inline-formula>-oriented
  surface <inline-formula><alternatives>
  <tex-math><![CDATA[\Gamma]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>Γ</mml:mi></mml:math></alternatives></inline-formula>
  of some object <inline-formula><alternatives>
  <tex-math><![CDATA[\Omega]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>Ω</mml:mi></mml:math></alternatives></inline-formula>,
  illuminated by an incident plane wave <inline-formula><alternatives>
  <tex-math><![CDATA[u_i]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>u</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
  with wave-number <inline-formula><alternatives>
  <tex-math><![CDATA[k]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>k</mml:mi></mml:math></alternatives></inline-formula>.
  The scattered field <inline-formula><alternatives>
  <tex-math><![CDATA[u]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>u</mml:mi></mml:math></alternatives></inline-formula>
  satisfies the Helmholtz equation in <inline-formula><alternatives>
  <tex-math><![CDATA[\Omega]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>Ω</mml:mi></mml:math></alternatives></inline-formula>,
  Neumann boundary conditions (<italic>sound-hard</italic>) and the
  Sommerfeld radiation condition:</p>
  <p><disp-formula><alternatives>
  <tex-math><![CDATA[
  \begin{aligned}
  -(\Delta u + k^2 u) &= 0 \\
  -\partial_n u_i     &= 0 \\
  \lim\limits_{r \to + \infty} r\textrm{ }(\partial_r u - i k u) &= 0
  \end{aligned}
  ]]></tex-math>
  <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mtable><mml:mtr><mml:mtd columnalign="right"><mml:mo>−</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>Δ</mml:mi><mml:mi>u</mml:mi><mml:mo>+</mml:mo><mml:msup><mml:mi>k</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mi>u</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right"><mml:mo>−</mml:mo><mml:msub><mml:mi>∂</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:msub><mml:mi>u</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mtd><mml:mtd columnalign="left"><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right"><mml:munder><mml:mo>lim</mml:mo><mml:mrow><mml:mi>r</mml:mi><mml:mo>→</mml:mo><mml:mo>+</mml:mo><mml:mi>∞</mml:mi></mml:mrow></mml:munder><mml:mi>r</mml:mi><mml:mrow><mml:mspace width="0.333em"></mml:mspace><mml:mtext mathvariant="normal"> </mml:mtext><mml:mspace width="0.333em"></mml:mspace></mml:mrow><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>∂</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mi>u</mml:mi><mml:mo>−</mml:mo><mml:mi>i</mml:mi><mml:mi>k</mml:mi><mml:mi>u</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p>
  <p>The scattered field <inline-formula><alternatives>
  <tex-math><![CDATA[u]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>u</mml:mi></mml:math></alternatives></inline-formula>
  satisfies the integral representation (Neumann interior extension, see
  (<xref alt="Terrasse &amp; Abboud, 2013" rid="ref-terasseU003A2007" ref-type="bibr">Terrasse
  &amp; Abboud, 2013</xref>)):</p>
  <p><named-content id="eq1" content-type="equation"><disp-formula><alternatives>
  <tex-math><![CDATA[
  \label{eq1}\tag{1}
  u(\textbf{x}) = - \left( \frac{1}{2}\mu(\textbf{x}) + \int_\Gamma \partial_{n_y} G(\textbf{x},\textbf{y})\mu(\textbf{y}) d_y \right) \quad \forall  \textbf{x} \in \Gamma^+,
  ]]></tex-math>
  <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>u</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mtext mathvariant="bold">𝐱</mml:mtext><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mo>−</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac><mml:mi>μ</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mtext mathvariant="bold">𝐱</mml:mtext><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:msub><mml:mo>∫</mml:mo><mml:mi>Γ</mml:mi></mml:msub><mml:msub><mml:mi>∂</mml:mi><mml:msub><mml:mi>n</mml:mi><mml:mi>y</mml:mi></mml:msub></mml:msub><mml:mi>G</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mtext mathvariant="bold">𝐱</mml:mtext><mml:mo>,</mml:mo><mml:mtext mathvariant="bold">𝐲</mml:mtext><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mi>μ</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mtext mathvariant="bold">𝐲</mml:mtext><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mi>y</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mspace width="1.0em"></mml:mspace><mml:mo>∀</mml:mo><mml:mtext mathvariant="bold">𝐱</mml:mtext><mml:mo>∈</mml:mo><mml:msup><mml:mi>Γ</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo>,</mml:mo></mml:mrow></mml:math></alternatives></disp-formula></named-content></p>
  <p>for some density <inline-formula><alternatives>
  <tex-math><![CDATA[\mu]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>μ</mml:mi></mml:math></alternatives></inline-formula>,
  with the Green kernel <inline-formula><alternatives>
  <tex-math><![CDATA[G(\textbf{x},\textbf{y}) = \displaystyle\frac{e^{i k |x - y|}}{4 \pi |x - y| }]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>G</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mtext mathvariant="bold">𝐱</mml:mtext><mml:mo>,</mml:mo><mml:mtext mathvariant="bold">𝐲</mml:mtext><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">|</mml:mo><mml:mi>x</mml:mi><mml:mo>−</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="true" form="postfix">|</mml:mo></mml:mrow></mml:mrow></mml:msup><mml:mrow><mml:mn>4</mml:mn><mml:mi>π</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">|</mml:mo><mml:mi>x</mml:mi><mml:mo>−</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="true" form="postfix">|</mml:mo></mml:mrow></mml:mrow></mml:mfrac></mml:mrow></mml:math></alternatives></inline-formula>.
  Using the boundary conditions we obtain :</p>
  <p><named-content id="eq2" content-type="equation"><disp-formula><alternatives>
  <tex-math><![CDATA[ 
  \label{eq2}\tag{2}
  - H\mu(\textbf{x})  = - \partial_n u_i(\textbf{x}) \quad \forall \textbf{x} \in \Gamma,
  ]]></tex-math>
  <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo>−</mml:mo><mml:mi>H</mml:mi><mml:mi>μ</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mtext mathvariant="bold">𝐱</mml:mtext><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mo>−</mml:mo><mml:msub><mml:mi>∂</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:msub><mml:mi>u</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mtext mathvariant="bold">𝐱</mml:mtext><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mspace width="1.0em"></mml:mspace><mml:mo>∀</mml:mo><mml:mtext mathvariant="bold">𝐱</mml:mtext><mml:mo>∈</mml:mo><mml:mi>Γ</mml:mi><mml:mo>,</mml:mo></mml:mrow></mml:math></alternatives></disp-formula></named-content></p>
  <p>where the hypersingular operator <inline-formula><alternatives>
  <tex-math><![CDATA[H]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>H</mml:mi></mml:math></alternatives></inline-formula>
  is defined by:</p>
  <p><named-content id="eq3" content-type="equation"><disp-formula><alternatives>
  <tex-math><![CDATA[ 
  \label{eq3}\tag{3}
  H \mu(\textbf{x}) = \int_\Gamma \partial_{n_x} \partial_{n_y} G(\textbf{x},\textbf{y})\mu(\textbf{y}) d_y.
  ]]></tex-math>
  <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>H</mml:mi><mml:mi>μ</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mtext mathvariant="bold">𝐱</mml:mtext><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mo>∫</mml:mo><mml:mi>Γ</mml:mi></mml:msub><mml:msub><mml:mi>∂</mml:mi><mml:msub><mml:mi>n</mml:mi><mml:mi>x</mml:mi></mml:msub></mml:msub><mml:msub><mml:mi>∂</mml:mi><mml:msub><mml:mi>n</mml:mi><mml:mi>y</mml:mi></mml:msub></mml:msub><mml:mi>G</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mtext mathvariant="bold">𝐱</mml:mtext><mml:mo>,</mml:mo><mml:mtext mathvariant="bold">𝐲</mml:mtext><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mi>μ</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mtext mathvariant="bold">𝐲</mml:mtext><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mi>y</mml:mi></mml:msub><mml:mi>.</mml:mi></mml:mrow></mml:math></alternatives></disp-formula></named-content></p>
  <p>The operator <inline-formula><alternatives>
  <tex-math><![CDATA[H]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>H</mml:mi></mml:math></alternatives></inline-formula>
  is assembled using a <inline-formula><alternatives>
  <tex-math><![CDATA[P_1]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>P</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math></alternatives></inline-formula>
  finite element discretization on a triangular mesh of the surface
  <inline-formula><alternatives>
  <tex-math><![CDATA[\Gamma]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>Γ</mml:mi></mml:math></alternatives></inline-formula>,
  stored using dense matrices (<monospace>matrix.hpp</monospace>) or
  hierarchical matrices (<monospace>hmatrix.hpp</monospace>).</p>
  <fig>
    <caption><p>Resonance mode at 8kHz of the human pinna (BEM with
    H-Matrix).<styled-content id="figU003Ahead"></styled-content></p></caption>
    <graphic mimetype="image" mime-subtype="png" xlink:href="media/head.png" xlink:title="" />
  </fig>
  <p>Finally, using all the tools provided by Castor to write and solve
  these equations, we are able to efficiently compute the acoustic
  diffraction of a harmonic plane wave at 8kHz, on a human head mesh
  (<xref alt="Jin et al., 2013" rid="ref-symareU003A2013" ref-type="bibr">Jin
  et al., 2013</xref>). As shown in
  <xref alt="Figure 2" rid="figU003Ahead">Figure 2</xref>, the
  simulation result highlights the role of the auditory pavilion as a
  resonator, modifying the timbre of a sound source to allow a
  listener’s brain to precisely locate its direction.</p>
  <code language="c++">#include &lt;castor/matrix.hpp&gt;
#include &lt;castor/smatrix.hpp&gt;
#include &lt;castor/hmatrix.hpp&gt;
#include &lt;castor/linalg.hpp&gt;
#include &lt;castor/graphics.hpp&gt;
#include &quot;fem.hpp&quot;
#include &quot;bem.hpp&quot;
using namespace castor;
int main (int argc, char* argv[])
{
    // Load meshes
    matrix&lt;double&gt; Svtx;
    matrix&lt;size_t&gt; Stri;
    std::tie(Stri,Svtx) = triread(&quot;./&quot;,&quot;Head03_04kHz.ply&quot;);
    
    // Graphical representation
    figure fig;
    trimesh(fig,Stri,Svtx);
    
    // Parameters
    matrix&lt;double&gt; U = {0,0,-1};
    double f = 2000;
    double k = 2*M_PI*f/340;
    float tol = 1e-3;
    
    // FEM and mass matrix, sparse storage
    tic();
    femdata&lt;double&gt; v(Stri,Svtx,lagrangeP1,3);
    femdata&lt;double&gt; u(Stri,Svtx,lagrangeP1,3);
    auto Id = mass&lt;std::complex&lt;double&gt;&gt;(v);
    toc();
    
    // Left hand side '-H', equation (3), H-Matrix storage
    tic();
    auto LHSfct = [&amp;v,&amp;u,&amp;k](matrix&lt;std::size_t&gt; Ix, matrix&lt;std::size_t&gt; Iy)
    {
        return -hypersingular&lt;std::complex&lt;double&gt;&gt;(v,u,k,Ix,Iy);
    };
    hmatrix&lt;std::complex&lt;double&gt;&gt; LHS(v.dof(),u.dof(),tol,LHSfct);
    toc();
    disp(LHS);
    
    // Right hand side '-dnUi', equation (2), full storage 
    auto B = - rightHandSide&lt;std::complex&lt;double&gt;&gt;(v,dnPWsource,U,k);
    
    // Solve '-H = -dnUi', equation (2), H-matrix preconditionner
    // associated to iterative solver
    hmatrix&lt;std::complex&lt;double&gt;&gt; Lh,Uh;
    tic();
    std::tie(Lh,Uh) = lu(LHS,1e-1);
    toc();
    disp(Lh);
    disp(Uh);
    auto mu = gmres(LHS,B,tol,100,Lh,Uh);
    
    // Boundary radiation, equation (1)
    tic();
    auto Dbndfct = [&amp;v,&amp;u,&amp;k,&amp;Id](matrix&lt;std::size_t&gt; Ix, matrix&lt;std::size_t&gt; Iy)
    {
        return 0.5*eval(Id(Ix,Iy)) + doubleLayer&lt;std::complex&lt;double&gt;&gt;(v,u,k,Ix,Iy);
    };
    hmatrix&lt;std::complex&lt;double&gt;&gt; Dbnd(v.dof(),u.dof(),tol,Dbndfct);
    matrix&lt;std::complex&lt;double&gt;&gt; Pbnd = mtimes(Dbnd,mu);
    toc();
    Pbnd = - gmres(Id,Pbnd,tol,100) + planeWave(v.dof(),U,k);
    
    // Graphical representation
    figure fig2;
    trimesh(fig2,Stri,Svtx,abs(Pbnd));
    
    // Export in .vtk file
    triwrite(&quot;./&quot;,&quot;head.vtk&quot;,Stri,Svtx,real(Pbnd));
    
    // Plot
    drawnow(fig);
    disp(&quot;done !&quot;);
    return 0;
}</code>
</sec>
<sec id="acknowledgements">
  <title>Acknowledgements</title>
  <p>We thank Houssem Haddar for his precious help.</p>
</sec>
</body>
<back>
<ref-list>
  <ref-list>
    <ref id="ref-bezanson2012julia">
      <element-citation publication-type="article-journal">
        <person-group person-group-type="author">
          <name><surname>Bezanson</surname><given-names>Jeff</given-names></name>
          <name><surname>Karpinski</surname><given-names>Stefan</given-names></name>
          <name><surname>Shah</surname><given-names>Viral B.</given-names></name>
          <name><surname>Edelman</surname><given-names>Alan</given-names></name>
        </person-group>
        <article-title>Julia: A fast dynamic language for technical computing</article-title>
        <source>arXiv preprint arXiv:1209.5145</source>
        <year iso-8601-date="2012">2012</year>
      </element-citation>
    </ref>
    <ref id="ref-blaslapackU003A00">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name><surname>Anderson</surname><given-names>E.</given-names></name>
          <name><surname>Bai</surname><given-names>Z.</given-names></name>
          <name><surname>Bischof</surname><given-names>C.</given-names></name>
          <name><surname>Blackford</surname><given-names>S.</given-names></name>
          <name><surname>Demmel</surname><given-names>J.</given-names></name>
          <name><surname>Dongarra</surname><given-names>J.</given-names></name>
          <name><surname>Du Croz</surname><given-names>J.</given-names></name>
          <name><surname>Greenbaum</surname><given-names>A.</given-names></name>
          <name><surname>Hammarling</surname><given-names>S.</given-names></name>
          <name><surname>McKenney</surname><given-names>A.</given-names></name>
          <name><surname>Sorensen</surname><given-names>D.</given-names></name>
        </person-group>
        <source>LAPACK Users’ guide</source>
        <publisher-name>Society for Industrial and Applied Mathematics</publisher-name>
        <publisher-loc>Philadelphia, PA</publisher-loc>
        <year iso-8601-date="1999">1999</year>
        <isbn>0-89871-447-8</isbn>
      </element-citation>
    </ref>
    <ref id="ref-cppU003A14">
      <element-citation publication-type="article-journal">
        <person-group person-group-type="author">
          <name><surname>ISO/IEC</surname></name>
        </person-group>
        <article-title>International standard ISO/IEC 14882:2014(e) – Programming language C++</article-title>
        <source>Geneva, Switzerland: International Organization for Standardization</source>
        <year iso-8601-date="2014">2014</year>
      </element-citation>
    </ref>
    <ref id="ref-hackbushU003A1999">
      <element-citation publication-type="article-journal">
        <person-group person-group-type="author">
          <name><surname>Hackbusch</surname><given-names>W.</given-names></name>
        </person-group>
        <article-title>A sparse matrix arithmetic based on H-matrices. Part 1: Introduction to H-matrices</article-title>
        <source>Computing, 62(2), 89–108</source>
        <year iso-8601-date="1999">1999</year>
      </element-citation>
    </ref>
    <ref id="ref-MATLABU003A2010">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name><surname>MATLAB</surname></name>
        </person-group>
        <source>Version 7.10.0 (R2010a)</source>
        <publisher-name>The MathWorks Inc.</publisher-name>
        <publisher-loc>Natick, Massachusetts</publisher-loc>
        <year iso-8601-date="2010">2010</year>
      </element-citation>
    </ref>
    <ref id="ref-sparseU003A1973">
      <element-citation publication-type="article-journal">
        <person-group person-group-type="author">
          <name><surname>Tewarson</surname><given-names>R. P.</given-names></name>
        </person-group>
        <article-title>Sparse matrices</article-title>
        <source>New York: Academic press, Vol. 69</source>
        <year iso-8601-date="1973">1973</year>
      </element-citation>
    </ref>
    <ref id="ref-rjasanowU003A2002">
      <element-citation publication-type="article-journal">
        <person-group person-group-type="author">
          <name><surname>Rjasanow</surname><given-names>S.</given-names></name>
        </person-group>
        <article-title>Adaptive cross approximation of dense matrices</article-title>
        <source>Int. Association Boundary Element Methods Conf., IABEM (pp. 28-30)</source>
        <year iso-8601-date="2002">2002</year>
      </element-citation>
    </ref>
    <ref id="ref-symareU003A2013">
      <element-citation publication-type="article-journal">
        <person-group person-group-type="author">
          <name><surname>Jin</surname><given-names>C. T.</given-names></name>
          <name><surname>Guillon</surname><given-names>P.</given-names></name>
          <name><surname>Epain</surname><given-names>N.</given-names></name>
          <name><surname>Zolfaghari</surname><given-names>R.</given-names></name>
          <name><surname>van Schaik</surname><given-names>A.</given-names></name>
          <name><surname>Tew</surname><given-names>A. I.</given-names></name>
          <name><surname>Thorpe</surname><given-names>J.</given-names></name>
        </person-group>
        <article-title>Creating the Sydney York morphological and acoustic recordings of ears database</article-title>
        <source>IEEE Transactions on Multimedia, 16(1), 37-46</source>
        <year iso-8601-date="2013">2013</year>
        <pub-id pub-id-type="doi">10.1109/icme.2012.93</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-terasseU003A2007">
      <element-citation publication-type="article-journal">
        <person-group person-group-type="author">
          <name><surname>Terrasse</surname><given-names>I.</given-names></name>
          <name><surname>Abboud</surname><given-names>T.</given-names></name>
        </person-group>
        <article-title>Modélisation des phénomènes de propagation d’ondes.</article-title>
        <source>École polytechnique</source>
        <year iso-8601-date="2013">2013</year>
      </element-citation>
    </ref>
    <ref id="ref-vtkU003A2000">
      <element-citation publication-type="article-journal">
        <person-group person-group-type="author">
          <name><surname>Schroeder</surname><given-names>W. J.</given-names></name>
          <name><surname>Avila</surname><given-names>L. S.</given-names></name>
          <name><surname>Hoffman</surname><given-names>W.</given-names></name>
        </person-group>
        <article-title>Visualizing with VTK: A tutorial</article-title>
        <source>IEEE Computer graphics and applications, 20(5), 20-27</source>
        <year iso-8601-date="2000">2000</year>
        <pub-id pub-id-type="doi">10.1109/38.865875</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-eigenweb">
      <element-citation>
        <person-group person-group-type="author">
          <name><surname>Guennebaud</surname><given-names>Gaël</given-names></name>
          <name><surname>Jacob</surname><given-names>Benoît</given-names></name>
          <name><surname>al.</surname></name>
        </person-group>
        <article-title>Eigen v3</article-title>
        <publisher-name>http://eigen.tuxfamily.org</publisher-name>
        <year iso-8601-date="2010">2010</year>
      </element-citation>
    </ref>
    <ref id="ref-fembemU003A21">
      <element-citation>
        <person-group person-group-type="author">
          <name><surname>Aussal</surname><given-names>M.</given-names></name>
          <name><surname>Bakry</surname><given-names>M.</given-names></name>
        </person-group>
        <year iso-8601-date="2021">2021</year>
        <uri>https://gitlab.labos.polytechnique.fr/leprojetcastor/fembem</uri>
      </element-citation>
    </ref>
  </ref-list>
</ref-list>
</back>
</article>
