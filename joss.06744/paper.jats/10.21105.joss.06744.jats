<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN"
                  "JATS-publishing1.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" dtd-version="1.2" article-type="other">
<front>
<journal-meta>
<journal-id></journal-id>
<journal-title-group>
<journal-title>Journal of Open Source Software</journal-title>
<abbrev-journal-title>JOSS</abbrev-journal-title>
</journal-title-group>
<issn publication-format="electronic">2475-9066</issn>
<publisher>
<publisher-name>Open Journals</publisher-name>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="publisher-id">6744</article-id>
<article-id pub-id-type="doi">10.21105/joss.06744</article-id>
<title-group>
<article-title>LocalCop: An R package for local likelihood inference for
conditional copulas</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author">
<contrib-id contrib-id-type="orcid">https://orcid.org/0000-0003-2908-7691</contrib-id>
<name>
<surname>Acar</surname>
<given-names>Elif Fidan</given-names>
</name>
<xref ref-type="aff" rid="aff-1"/>
<xref ref-type="aff" rid="aff-2"/>
</contrib>
<contrib contrib-type="author">
<contrib-id contrib-id-type="orcid">https://orcid.org/0000-0001-9974-1121</contrib-id>
<name>
<surname>Lysy</surname>
<given-names>Martin</given-names>
</name>
<xref ref-type="aff" rid="aff-3"/>
</contrib>
<contrib contrib-type="author">
<name>
<surname>Kuchinsky</surname>
<given-names>Alan</given-names>
</name>
<xref ref-type="aff" rid="aff-4"/>
</contrib>
<aff id="aff-1">
<institution-wrap>
<institution>University of Guelph</institution>
</institution-wrap>
</aff>
<aff id="aff-2">
<institution-wrap>
<institution>Hospital for Sick Children</institution>
</institution-wrap>
</aff>
<aff id="aff-3">
<institution-wrap>
<institution>University of Waterloo</institution>
</institution-wrap>
</aff>
<aff id="aff-4">
<institution-wrap>
<institution>University of Manitoba</institution>
</institution-wrap>
</aff>
</contrib-group>
<pub-date date-type="pub" publication-format="electronic" iso-8601-date="2024-09-09">
<day>9</day>
<month>9</month>
<year>2024</year>
</pub-date>
<volume>9</volume>
<issue>101</issue>
<fpage>6744</fpage>
<permissions>
<copyright-statement>Authors of papers retain copyright and release the
work under a Creative Commons Attribution 4.0 International License (CC
BY 4.0)</copyright-statement>
<copyright-year>2022</copyright-year>
<copyright-holder>The article authors</copyright-holder>
<license license-type="open-access" xlink:href="https://creativecommons.org/licenses/by/4.0/">
<license-p>Authors of papers retain copyright and release the work under
a Creative Commons Attribution 4.0 International License (CC BY
4.0)</license-p>
</license>
</permissions>
<kwd-group kwd-group-type="author">
<kwd>R</kwd>
<kwd>C++</kwd>
<kwd>copula</kwd>
<kwd>local likelihood</kwd>
<kwd>covariate effect</kwd>
</kwd-group>
</article-meta>
</front>
<body>
<sec id="summary">
  <title>Summary</title>
  <p>Conditional copulas models allow the dependence structure between
  multiple response variables to be modelled as a function of
  covariates. <bold>LocalCop</bold>
  (<xref alt="Acar &amp; Lysy, 2024" rid="ref-localcop" ref-type="bibr">Acar
  &amp; Lysy, 2024</xref>) is an
  <named-content content-type="sans-serif">R</named-content>/<named-content content-type="sans-serif">C++</named-content>package
  for computationally efficient semiparametric conditional copula
  modelling using a local likelihood inference framework developed in
  Acar, Craiu, &amp; Yao
  (<xref alt="2011" rid="ref-ACY2011" ref-type="bibr">2011</xref>),
  Acar, Craiu, &amp; Yao
  (<xref alt="2013" rid="ref-ACY2013" ref-type="bibr">2013</xref>) and
  Acar, Czado, &amp; Lysy
  (<xref alt="2019" rid="ref-ACL2019" ref-type="bibr">2019</xref>).</p>
</sec>
<sec id="statement-of-need">
  <title>Statement of Need</title>
  <p>There are well-developed
  <named-content content-type="sans-serif">R</named-content>packages
  such as <bold>copula</bold>
  (<xref alt="Hofert, Kojadinovic, Mächler, &amp; Yan, 2023" rid="ref-copula1" ref-type="bibr">Hofert,
  Kojadinovic, Mächler, &amp; Yan, 2023</xref>;
  <xref alt="Hofert &amp; Mächler, 2011" rid="ref-copula4" ref-type="bibr">Hofert
  &amp; Mächler, 2011</xref>;
  <xref alt="Kojadinovic &amp; Yan, 2010" rid="ref-copula3" ref-type="bibr">Kojadinovic
  &amp; Yan, 2010</xref>;
  <xref alt="Yan, 2007" rid="ref-copula2" ref-type="bibr">Yan,
  2007</xref>) and <bold>VineCopula</bold>
  (<xref alt="Nagler et al., 2023" rid="ref-vinecopula" ref-type="bibr">Nagler
  et al., 2023</xref>) for fitting copulas in various multivariate data
  settings. However, these software focus exclusively on unconditional
  dependence modelling and do not accommodate covariate information.</p>
  <p>Aside from <bold>LocalCop</bold>,
  <named-content content-type="sans-serif">R</named-content>packages for
  fitting conditional copulas are <bold>gamCopula</bold>
  (<xref alt="Nagler &amp; Vatter, 2020" rid="ref-gamcopula" ref-type="bibr">Nagler
  &amp; Vatter, 2020</xref>) and <bold>CondCopulas</bold>
  (<xref alt="Derumigny, 2023" rid="ref-condcopulas" ref-type="bibr">Derumigny,
  2023</xref>). <bold>gamCopula</bold> estimates the covariate-dependent
  copula parameter using spline smoothing. While this typically has
  lower variance than the local likelihood estimate provided by
  <bold>LocalCop</bold>, it also tends to have lower accuracy
  (<xref alt="Acar et al., 2019" rid="ref-ACL2019" ref-type="bibr">Acar
  et al., 2019</xref>). <bold>CondCopulas</bold> estimates the copula
  parameter using a semi-parametric maximum-likelihood method based on a
  kernel-weighted conditional concordance metric. <bold>LocalCop</bold>
  also uses kernel weighting, but it uses the full likelihood
  information of a given copula family rather than just that contained
  in the concordance metric, and is therefore more statistically
  efficient.</p>
  <p>Local likelihood methods typically involve solving a large number
  of low-dimensional optimization problems and thus can be
  computationally intensive. To address this issue,
  <bold>LocalCop</bold> implements the local likelihood function in
  <named-content content-type="sans-serif">C++</named-content>, using
  the
  <named-content content-type="sans-serif">R</named-content>/<named-content content-type="sans-serif">C++</named-content>package
  <bold>TMB</bold>
  (<xref alt="Kristensen, Nielsen, Berg, Skaug, &amp; Bell, 2016" rid="ref-kristensen.etal16" ref-type="bibr">Kristensen,
  Nielsen, Berg, Skaug, &amp; Bell, 2016</xref>) to efficiently obtain
  the associated score function using automatic differentiation. Thus,
  <bold>LocalCop</bold> is able to solve each optimization problem very
  quickly using gradient-based algorithms. It also provides a means of
  easily parallelizing the optimization across multiple cores, rendering
  <bold>LocalCop</bold> competitive in terms of speed with other
  available software for conditional copula estimation.</p>
</sec>
<sec id="background">
  <title>Background</title>
  <p>For any bivariate response vector <inline-formula><alternatives>
  <tex-math><![CDATA[(Y_1, Y_2)]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>,
  the conditional joint distribution given a covariate
  <inline-formula><alternatives>
  <tex-math><![CDATA[X]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>X</mml:mi></mml:math></alternatives></inline-formula>
  is given by
  <named-content id="eqU003Afullmodel" content-type="equation"><disp-formula><alternatives>
  <tex-math><![CDATA[F_X(y_1, y_2 \mid x) = C_X (F_{1\mid X} (y_1 \mid x),F_{2\mid X} (y_2 \mid x) \mid x ),
  ]]></tex-math>
  <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:mi>X</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>y</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>y</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>∣</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mi>X</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>F</mml:mi><mml:mrow><mml:mn>1</mml:mn><mml:mo>∣</mml:mo><mml:mi>X</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>y</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>∣</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:msub><mml:mi>F</mml:mi><mml:mrow><mml:mn>2</mml:mn><mml:mo>∣</mml:mo><mml:mi>X</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>y</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>∣</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>∣</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:math></alternatives></disp-formula></named-content>
  where <inline-formula><alternatives>
  <tex-math><![CDATA[F_{1\mid X}(y_1 \mid x)]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:mrow><mml:mn>1</mml:mn><mml:mo>∣</mml:mo><mml:mi>X</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>y</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>∣</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
  and <inline-formula><alternatives>
  <tex-math><![CDATA[F_{2\mid X}(y_2 \mid x)]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:mrow><mml:mn>2</mml:mn><mml:mo>∣</mml:mo><mml:mi>X</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>y</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>∣</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
  are the conditional marginal distributions of
  <inline-formula><alternatives>
  <tex-math><![CDATA[Y_1]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>Y</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math></alternatives></inline-formula>
  and <inline-formula><alternatives>
  <tex-math><![CDATA[Y_2]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>Y</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:math></alternatives></inline-formula>
  given <inline-formula><alternatives>
  <tex-math><![CDATA[X]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>X</mml:mi></mml:math></alternatives></inline-formula>,
  and <inline-formula><alternatives>
  <tex-math><![CDATA[C_X(u, v \mid x)]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>C</mml:mi><mml:mi>X</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo>∣</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
  is a conditional copula function. That is, for given
  <inline-formula><alternatives>
  <tex-math><![CDATA[X = x]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>X</mml:mi><mml:mo>=</mml:mo><mml:mi>x</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>,
  the function <inline-formula><alternatives>
  <tex-math><![CDATA[C_X(u, v \mid x)]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>C</mml:mi><mml:mi>X</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo>∣</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
  is a bivariate CDF with uniform margins.</p>
  <p>The focus of <bold>LocalCop</bold> is on estimating the conditional
  copula function, which is modelled semi-parametrically as
  <named-content id="eqU003Acopmod" content-type="equation"><disp-formula><alternatives>
  <tex-math><![CDATA[C_X(u, v \mid x) = \mathcal{C}(u, v\mid \theta(x), \nu),
  ]]></tex-math>
  <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>C</mml:mi><mml:mi>X</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo>∣</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>𝒞</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo>∣</mml:mo><mml:mi>θ</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:math></alternatives></disp-formula></named-content>
  where <inline-formula><alternatives>
  <tex-math><![CDATA[\mathcal{C}(u, v \mid \theta, \nu)]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>𝒞</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo>∣</mml:mo><mml:mi>θ</mml:mi><mml:mo>,</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
  is a parametric copula family, the copula dependence parameter
  <inline-formula><alternatives>
  <tex-math><![CDATA[\theta \in \Theta]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>θ</mml:mi><mml:mo>∈</mml:mo><mml:mi>Θ</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
  is an arbitrary function of <inline-formula><alternatives>
  <tex-math><![CDATA[X]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>X</mml:mi></mml:math></alternatives></inline-formula>,
  and <inline-formula><alternatives>
  <tex-math><![CDATA[\nu \in \Upsilon]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>ν</mml:mi><mml:mo>∈</mml:mo><mml:mi>Υ</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
  is an additional copula parameter present in some models. Since most
  parametric copula families have a restricted range
  <inline-formula><alternatives>
  <tex-math><![CDATA[\Theta \subsetneq \mathbb{R}]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>Θ</mml:mi><mml:mo>⊊</mml:mo><mml:mi>ℝ</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>,
  we describe the data generating model (DGM) in terms of the
  calibration function <inline-formula><alternatives>
  <tex-math><![CDATA[\eta(x)]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>η</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>,
  such that <disp-formula><alternatives>
  <tex-math><![CDATA[\theta(x) = g^{-1}(\eta(x)),]]></tex-math>
  <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>θ</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msup><mml:mi>g</mml:mi><mml:mrow><mml:mi>−</mml:mi><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>η</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:math></alternatives></disp-formula>
  where <inline-formula><alternatives>
  <tex-math><![CDATA[g^{-1}: \mathbb{R} \to \Theta]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msup><mml:mi>g</mml:mi><mml:mrow><mml:mi>−</mml:mi><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo>:</mml:mo><mml:mi>ℝ</mml:mi><mml:mo>→</mml:mo><mml:mi>Θ</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
  an inverse-link function which ensures that the copula parameter has
  the correct range. The choice of <inline-formula><alternatives>
  <tex-math><![CDATA[g^{-1}(\eta)]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msup><mml:mi>g</mml:mi><mml:mrow><mml:mi>−</mml:mi><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>η</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
  is not unique and depends on the copula family.</p>
  <p>Local likelihood estimation of the conditional copula parameter
  <inline-formula><alternatives>
  <tex-math><![CDATA[\theta(x)]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>θ</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
  uses Taylor expansions to approximate the calibration function
  <inline-formula><alternatives>
  <tex-math><![CDATA[\eta(x)]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>η</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
  at an observed covariate value <inline-formula><alternatives>
  <tex-math><![CDATA[X = x]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>X</mml:mi><mml:mo>=</mml:mo><mml:mi>x</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
  near a fixed point <inline-formula><alternatives>
  <tex-math><![CDATA[X = x_0]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>X</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>,
  i.e., <disp-formula><alternatives>
  <tex-math><![CDATA[
  \eta(x)\approx \eta(x_0) + \eta^{(1)}(x_0) (x - x_0) + \ldots + \dfrac{\eta^{(p)}(x_0)}{p!} (x - x_0)^{p}.
  ]]></tex-math>
  <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>η</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>≈</mml:mo><mml:mi>η</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:msup><mml:mi>η</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:msup><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>x</mml:mi><mml:mo>−</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>…</mml:mi><mml:mo>+</mml:mo><mml:mfrac displaystyle="true"><mml:mrow><mml:msup><mml:mi>η</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:msup><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi>p</mml:mi><mml:mi>!</mml:mi></mml:mrow></mml:mfrac><mml:msup><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>x</mml:mi><mml:mo>−</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mi>p</mml:mi></mml:msup><mml:mi>.</mml:mi></mml:mrow></mml:math></alternatives></disp-formula>
  One then estimates <inline-formula><alternatives>
  <tex-math><![CDATA[\beta_k = \eta^{(k)}(x_0)/k!]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>β</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msup><mml:mi>η</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:msup><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mi>/</mml:mi><mml:mi>k</mml:mi><mml:mi>!</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
  for <inline-formula><alternatives>
  <tex-math><![CDATA[k = 0,\ldots,p]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>…</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
  using a kernel-weighted local likelihood function
  <named-content id="eqU003Alocallik" content-type="equation"><disp-formula><alternatives>
  <tex-math><![CDATA[\ell(\boldsymbol{\beta}) = \sum_{i=1}^n \log\left\{ c\left(u_i, v_i \mid g^{-1}( \boldsymbol{x}_{i}^T \boldsymbol{\beta}), \nu \right)\right\} K_h\left(\dfrac{x_i-x_0}{h}\right),
  ]]></tex-math>
  <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo>ℓ</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>𝛃</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:munderover><mml:mo>log</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">{</mml:mo><mml:mi>c</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>∣</mml:mo><mml:msup><mml:mi>g</mml:mi><mml:mrow><mml:mi>−</mml:mi><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msubsup><mml:mi>𝐱</mml:mi><mml:mi>i</mml:mi><mml:mi>T</mml:mi></mml:msubsup><mml:mi>𝛃</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">}</mml:mo></mml:mrow><mml:msub><mml:mi>K</mml:mi><mml:mi>h</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mfrac displaystyle="true"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow><mml:mi>h</mml:mi></mml:mfrac><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:math></alternatives></disp-formula></named-content>
  where <inline-formula><alternatives>
  <tex-math><![CDATA[(u_i, v_i, x_i)]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>
  is the data for observation <inline-formula><alternatives>
  <tex-math><![CDATA[i]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>i</mml:mi></mml:math></alternatives></inline-formula>,
  <inline-formula><alternatives>
  <tex-math><![CDATA[\boldsymbol{x}_i = (1, x_i - x_0, (x_i - x_0)^2, \ldots, (x_i - x_0)^p)]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>𝐱</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>,</mml:mo><mml:mi>…</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mi>p</mml:mi></mml:msup><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>,
  <inline-formula><alternatives>
  <tex-math><![CDATA[\boldsymbol{\beta}= (\beta_0, \beta_1, \ldots, \beta_p)]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>𝛃</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>β</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>β</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mi>…</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>β</mml:mi><mml:mi>p</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>,
  and <inline-formula><alternatives>
  <tex-math><![CDATA[K_h(z)]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>K</mml:mi><mml:mi>h</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>z</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
  is a kernel function with bandwidth parameter
  <inline-formula><alternatives>
  <tex-math><![CDATA[h > 0]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>h</mml:mi><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></alternatives></inline-formula>.
  Having maximized <inline-formula><alternatives>
  <tex-math><![CDATA[\ell(\boldsymbol{\beta})]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo>ℓ</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>𝛃</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
  in <xref alt="Equation 3" rid="eqU003Alocallik">Equation 3</xref>, one
  estimates <inline-formula><alternatives>
  <tex-math><![CDATA[\eta(x_0)]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>η</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
  by <inline-formula><alternatives>
  <tex-math><![CDATA[\hat \eta(x_0) = \hat \beta_0]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mover><mml:mi>η</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mover><mml:mi>β</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>.
  Usually, a linear fit with <inline-formula><alternatives>
  <tex-math><![CDATA[p=1]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>p</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></alternatives></inline-formula>
  suffices to obtain a good estimate in practice.</p>
</sec>
<sec id="usage">
  <title>Usage</title>
  <p><bold>LocalCop</bold> is available on
  <ext-link ext-link-type="uri" xlink:href="https://CRAN.R-project.org/package=LocalCop">CRAN</ext-link>
  and
  <ext-link ext-link-type="uri" xlink:href="https://github.com/mlysy/LocalCop">GitHub</ext-link>.
  The two main package functions are:</p>
  <list list-type="bullet">
    <list-item>
      <p><monospace>CondiCopLocFit()</monospace>: For estimating the
      calibration function at a sequence of values
      <inline-formula><alternatives>
      <tex-math><![CDATA[\boldsymbol{x}_0 = (x_{01}, \ldots, x_{0m})]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>𝐱</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>01</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mi>…</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mn>0</mml:mn><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>.</p>
    </list-item>
    <list-item>
      <p><monospace>CondiCopSelect()</monospace>: For selecting a copula
      family and bandwidth parameter using leave-one-out
      cross-validation (LOO-CV) with subsampling as described in Acar et
      al.
      (<xref alt="2019" rid="ref-ACL2019" ref-type="bibr">2019</xref>).</p>
    </list-item>
  </list>
  <p>In the following example, we illustrate the model selection/tuning
  and fitting steps for data generated from a Clayton copula with
  conditional Kendall <inline-formula><alternatives>
  <tex-math><![CDATA[\tau]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>τ</mml:mi></mml:math></alternatives></inline-formula>
  displayed in
  <xref alt="[fig:copcomp]" rid="figU003Acopcomp">[fig:copcomp]</xref>.
  The CV metric for each combination of family and bandwidth are
  displayed in
  <xref alt="[fig:select1-plot]" rid="figU003Aselect1-plot">[fig:select1-plot]</xref>.</p>
  <code language="r script">library(LocalCop)   # local likelihood estimation
library(VineCopula) # simulate copula data</code>
  <code language="r script">set.seed(2024)

# simulation setting
family &lt;- 3                    # Clayton Copula
n_obs &lt;- 300                   # number of observations
eta_fun &lt;- function(x) {       # calibration function
  sin(5*pi*x) + cos(8*pi*x^2)
}</code>
  <code language="r script"># simulate covariate values
x &lt;- sort(runif(n_obs))

# simulate response data
eta_true &lt;- eta_fun(x)                     # calibration parameter eta(x)
par_true &lt;- BiCopEta2Par(family = family,  # copula parameter theta(x)
                         eta = eta_true)
udata &lt;- VineCopula::BiCopSim(n_obs, family = family, par = par_true)</code>
  <code language="r script"># model selection and tuning
bandset &lt;- c(.02, .05, .1, .2) # set of bandwidth parameters
famset &lt;- c(1, 2, 3, 4, 5)     # set of copula families
kernel &lt;- KernGaus             # kernel function
degree &lt;- 1                    # degree of local polynomial
n_loo &lt;- 100                   # number of LOO-CV observations
                               # (can be much smaller than n_obs)</code>
  <code language="r script"># calculate cv for each combination of family and bandwidth
cvselect &lt;- CondiCopSelect(u1= udata[,1], u2 = udata[,2],
                           x = x, xind = n_loo,
                           kernel = kernel, degree = degree,
                           family = famset, band = bandset)</code>
  <fig id="figU003Aselect1-plot">
    <caption><p>Cross-validation metric for each combination of family
    and bandwidth.</p></caption>
    <graphic mimetype="application" mime-subtype="pdf" xlink:href="select1-plot-1.pdf" />
  </fig>
  <code language="r script"># extract the selected family and bandwidth from cvselect
cv_res &lt;- cvselect$cv
i_opt &lt;- which.max(cv_res$cv)
fam_opt &lt;- cv_res[i_opt,]$family
band_opt &lt;- cv_res[i_opt,]$band

# calculate eta(x) on a grid of values
x0 &lt;- seq(0, 1, by = 0.01)
copfit &lt;- CondiCopLocFit(u1 = udata[,1], u2 = udata[,2],
                         x = x, x0 = x0,
                         kernel = kernel, degree = degree,
                         family = fam_opt, band = band_opt)
# convert eta to Kendall tau
tau_loc &lt;- BiCopEta2Tau(copfit$eta, family= fam_opt)</code>
  <code language="r script"># simulate covariate values
x &lt;- sort(runif(n_obs))

# simulate response data
eta_true &lt;- eta_fun(x)                     # calibration parameter eta(x)
par_true &lt;- BiCopEta2Par(family = family,  # copula parameter theta(x)
                         eta = eta_true)
udata &lt;- VineCopula::BiCopSim(n_obs, family = family, par = par_true)</code>
  <code language="r script"># model selection and tuning
bandset &lt;- c(.02, .05, .1, .2) # set of bandwidth parameters
famset &lt;- c(1, 2, 3, 4, 5)     # set of copula families
kernel &lt;- KernGaus             # kernel function
degree &lt;- 1                    # degree of local polynomial
n_loo &lt;- 100                   # number of LOO-CV observations
                               # (can be much smaller than n_obs)</code>
  <code language="r script"># calculate cv for each combination of family and bandwidth
cvselect &lt;- CondiCopSelect(u1= udata[,1], u2 = udata[,2],
                           x = x, xind = n_loo,
                           kernel = kernel, degree = degree,
                           family = famset, band = bandset)</code>
  <code language="r script"># extract the selected family and bandwidth from cvselect
cv_res &lt;- cvselect$cv
i_opt &lt;- which.max(cv_res$cv)
fam_opt &lt;- cv_res[i_opt,]$family
band_opt &lt;- cv_res[i_opt,]$band

# calculate eta(x) on a grid of values
x0 &lt;- seq(0, 1, by = 0.01)
copfit &lt;- CondiCopLocFit(u1 = udata[,1], u2 = udata[,2],
                         x = x, x0 = x0,
                         kernel = kernel, degree = degree,
                         family = fam_opt, band = band_opt)
# convert eta to Kendall tau
tau_loc &lt;- BiCopEta2Tau(copfit$eta, family= fam_opt)</code>
  <fig id="figU003Acopcomp">
    <caption><p>True vs estimated conditional Kendall
    <inline-formula><alternatives>
    <tex-math><![CDATA[\tau]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>τ</mml:mi></mml:math></alternatives></inline-formula>
    using various methods.</p></caption>
    <graphic mimetype="application" mime-subtype="pdf" xlink:href="copcomp-1.pdf" />
  </fig>
  <p>In
  <xref alt="[fig:copcomp]" rid="figU003Acopcomp">[fig:copcomp]</xref>,
  we compare the true conditional Kendall <inline-formula><alternatives>
  <tex-math><![CDATA[\tau]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>τ</mml:mi></mml:math></alternatives></inline-formula>
  to estimates using each of the three conditional copula fitting
  packages <bold>LocalCop</bold>, <bold>gamCopula</bold>, and
  <bold>CondCopulas</bold>, for sample sizes
  <inline-formula><alternatives>
  <tex-math><![CDATA[n = 300]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mn>300</mml:mn></mml:mrow></mml:math></alternatives></inline-formula>
  and <inline-formula><alternatives>
  <tex-math><![CDATA[n = 1000]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mn>1000</mml:mn></mml:mrow></mml:math></alternatives></inline-formula>.
  In <bold>gamCopula</bold>, selection of the copula family smoothing
  splines is done using the generalized CV framework provided by the
  <named-content content-type="sans-serif">R</named-content>package
  <bold>mgcv</bold>
  (<xref alt="Wood, 2017" rid="ref-wood17" ref-type="bibr">Wood,
  2017</xref>). In <bold>CondCopulas</bold>, selection of the bandwidth
  parameter is done using LOO-CV. In this particular example, the sample
  size of <inline-formula><alternatives>
  <tex-math><![CDATA[n = 300]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mn>300</mml:mn></mml:mrow></mml:math></alternatives></inline-formula>
  is not large enough for <bold>gamCopula</bold> to pick a sufficiently
  flexible spline basis, and <bold>CondCopulas</bold> picks a large
  bandwidth which oversmooths the data. For the larger sample size
  <inline-formula><alternatives>
  <tex-math><![CDATA[n = 1000]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mn>1000</mml:mn></mml:mrow></mml:math></alternatives></inline-formula>,
  the three methods exhibit similar accuracy.</p>
</sec>
<sec id="acknowledgements">
  <title>Acknowledgements</title>
  <p>We acknowledge funding support from the Natural Sciences and
  Engineering Research Council of Canada Discovery Grants
  RGPIN-2020-06753 (Acar) and RGPIN-2020-04364 (Lysy).</p>
</sec>
</body>
<back>
<ref-list>
  <title></title>
  <ref id="ref-wood17">
    <element-citation publication-type="book">
      <person-group person-group-type="author">
        <name><surname>Wood</surname><given-names>S. N</given-names></name>
      </person-group>
      <source>Generalized additive models: An introduction with R</source>
      <publisher-name>Chapman; Hall/CRC</publisher-name>
      <year iso-8601-date="2017">2017</year>
      <edition>2</edition>
      <pub-id pub-id-type="doi">10.1201/9781315370279</pub-id>
    </element-citation>
  </ref>
  <ref id="ref-kristensen.etal16">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Kristensen</surname><given-names>Kasper</given-names></name>
        <name><surname>Nielsen</surname><given-names>Anders</given-names></name>
        <name><surname>Berg</surname><given-names>Casper W.</given-names></name>
        <name><surname>Skaug</surname><given-names>Hans</given-names></name>
        <name><surname>Bell</surname><given-names>Bradley M.</given-names></name>
      </person-group>
      <article-title>TMB: Automatic differentiation and Laplace approximation</article-title>
      <source>Journal of Statistical Software</source>
      <year iso-8601-date="2016">2016</year>
      <volume>70</volume>
      <issue>5</issue>
      <uri>https://www.jstatsoft.org/article/view/v070i05</uri>
      <pub-id pub-id-type="doi">10.18637/jss.v070.i05</pub-id>
      <fpage>1</fpage>
      <lpage>21</lpage>
    </element-citation>
  </ref>
  <ref id="ref-ACL2019">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Acar</surname><given-names>Elif F.</given-names></name>
        <name><surname>Czado</surname><given-names>Claudia</given-names></name>
        <name><surname>Lysy</surname><given-names>Martin</given-names></name>
      </person-group>
      <article-title>Dynamic vine copula models for multivariate time series data</article-title>
      <source>Econometrics and Statistics</source>
      <year iso-8601-date="2019">2019</year>
      <volume>12</volume>
      <pub-id pub-id-type="doi">10.1016/j.ecosta.2019.03.002</pub-id>
      <fpage>181</fpage>
      <lpage>197</lpage>
    </element-citation>
  </ref>
  <ref id="ref-ACY2011">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Acar</surname><given-names>Elif F.</given-names></name>
        <name><surname>Craiu</surname><given-names>Radu V.</given-names></name>
        <name><surname>Yao</surname><given-names>Fang</given-names></name>
      </person-group>
      <article-title>Dependence calibration in conditional copulas: A nonparametric approach</article-title>
      <source>Biometrics</source>
      <year iso-8601-date="2011">2011</year>
      <volume>67</volume>
      <issue>2</issue>
      <pub-id pub-id-type="doi">10.1111/j.1541-0420.2010.01472.x</pub-id>
      <fpage>445</fpage>
      <lpage>453</lpage>
    </element-citation>
  </ref>
  <ref id="ref-ACY2013">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Acar</surname><given-names>Elif F.</given-names></name>
        <name><surname>Craiu</surname><given-names>Radu V.</given-names></name>
        <name><surname>Yao</surname><given-names>Fang</given-names></name>
      </person-group>
      <article-title>Statistical testing of covariate effects in conditional copula models</article-title>
      <source>Electronic Journal of Statistics</source>
      <year iso-8601-date="2013">2013</year>
      <volume>7</volume>
      <pub-id pub-id-type="doi">10.1214/13-EJS866</pub-id>
      <fpage>2822</fpage>
      <lpage>2850</lpage>
    </element-citation>
  </ref>
  <ref id="ref-localcop">
    <element-citation publication-type="book">
      <person-group person-group-type="author">
        <name><surname>Acar</surname><given-names>Elif F.</given-names></name>
        <name><surname>Lysy</surname><given-names>Martin</given-names></name>
      </person-group>
      <source>LocalCop: LocalCop: Local likelihood inference for conditional copula models</source>
      <year iso-8601-date="2024">2024</year>
      <uri>https://CRAN.R-project.org/package=LocalCop</uri>
      <pub-id pub-id-type="doi">10.32614/CRAN.package.LocalCop</pub-id>
    </element-citation>
  </ref>
  <ref id="ref-copula1">
    <element-citation publication-type="book">
      <person-group person-group-type="author">
        <name><surname>Hofert</surname><given-names>Marius</given-names></name>
        <name><surname>Kojadinovic</surname><given-names>Ivan</given-names></name>
        <name><surname>Mächler</surname><given-names>Martin</given-names></name>
        <name><surname>Yan</surname><given-names>Jun</given-names></name>
      </person-group>
      <source>Copula: Multivariate dependence with copulas</source>
      <year iso-8601-date="2023">2023</year>
      <uri>https://CRAN.R-project.org/package=copula</uri>
      <pub-id pub-id-type="doi">10.32614/CRAN.package.copula</pub-id>
    </element-citation>
  </ref>
  <ref id="ref-copula2">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Yan</surname><given-names>Jun</given-names></name>
      </person-group>
      <article-title>Enjoy the joy of copulas: With a package copula</article-title>
      <source>Journal of Statistical Software</source>
      <year iso-8601-date="2007">2007</year>
      <volume>21</volume>
      <issue>4</issue>
      <uri>https://www.jstatsoft.org/v21/i04/</uri>
      <pub-id pub-id-type="doi">10.18637/jss.v021.i04</pub-id>
      <fpage>1</fpage>
      <lpage>21</lpage>
    </element-citation>
  </ref>
  <ref id="ref-copula3">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Kojadinovic</surname><given-names>Ivan</given-names></name>
        <name><surname>Yan</surname><given-names>Jun</given-names></name>
      </person-group>
      <article-title>Modeling multivariate distributions with continuous margins using the copula R package</article-title>
      <source>Journal of Statistical Software</source>
      <year iso-8601-date="2010">2010</year>
      <volume>34</volume>
      <issue>9</issue>
      <uri>https://www.jstatsoft.org/v34/i09/</uri>
      <pub-id pub-id-type="doi">10.18637/jss.v034.i09</pub-id>
      <fpage>1</fpage>
      <lpage>20</lpage>
    </element-citation>
  </ref>
  <ref id="ref-copula4">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Hofert</surname><given-names>Marius</given-names></name>
        <name><surname>Mächler</surname><given-names>Martin</given-names></name>
      </person-group>
      <article-title>Nested archimedean copulas meet R: The nacopula package</article-title>
      <source>Journal of Statistical Software</source>
      <year iso-8601-date="2011">2011</year>
      <volume>39</volume>
      <issue>9</issue>
      <uri>https://www.jstatsoft.org/v39/i09/</uri>
      <pub-id pub-id-type="doi">10.18637/jss.v039.i09</pub-id>
      <fpage>1</fpage>
      <lpage>20</lpage>
    </element-citation>
  </ref>
  <ref id="ref-vinecopula">
    <element-citation publication-type="book">
      <person-group person-group-type="author">
        <name><surname>Nagler</surname><given-names>Thomas</given-names></name>
        <name><surname>Schepsmeier</surname><given-names>Ulf</given-names></name>
        <name><surname>Stoeber</surname><given-names>Jakob</given-names></name>
        <name><surname>Brechmann</surname><given-names>Eike Christian</given-names></name>
        <name><surname>Graeler</surname><given-names>Benedikt</given-names></name>
        <name><surname>Erhardt</surname><given-names>Tobias</given-names></name>
      </person-group>
      <source>VineCopula: Statistical inference of vine copulas</source>
      <year iso-8601-date="2023">2023</year>
      <uri>https://CRAN.R-project.org/package=VineCopula</uri>
      <pub-id pub-id-type="doi">10.32614/CRAN.package.VineCopula</pub-id>
    </element-citation>
  </ref>
  <ref id="ref-gamcopula">
    <element-citation publication-type="book">
      <person-group person-group-type="author">
        <name><surname>Nagler</surname><given-names>Thomas</given-names></name>
        <name><surname>Vatter</surname><given-names>Thibault</given-names></name>
      </person-group>
      <source>gamCopula: Generalized additive models for bivariate conditional dependence structures and vine copulas</source>
      <year iso-8601-date="2020">2020</year>
      <uri>https://CRAN.R-project.org/package=gamCopula</uri>
      <pub-id pub-id-type="doi">10.32614/CRAN.package.gamCopula</pub-id>
    </element-citation>
  </ref>
  <ref id="ref-condcopulas">
    <element-citation publication-type="book">
      <person-group person-group-type="author">
        <name><surname>Derumigny</surname><given-names>Alexis</given-names></name>
      </person-group>
      <source>CondCopulas: Estimation and inference for conditional copula models</source>
      <year iso-8601-date="2023">2023</year>
      <uri>https://CRAN.R-project.org/package=CondCopulas</uri>
      <pub-id pub-id-type="doi">10.32614/CRAN.package.CondCopulas</pub-id>
    </element-citation>
  </ref>
</ref-list>
</back>
</article>
