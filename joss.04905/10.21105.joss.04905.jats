<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN"
                  "JATS-publishing1.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" dtd-version="1.2" article-type="other">
<front>
<journal-meta>
<journal-id></journal-id>
<journal-title-group>
<journal-title>Journal of Open Source Software</journal-title>
<abbrev-journal-title>JOSS</abbrev-journal-title>
</journal-title-group>
<issn publication-format="electronic">2475-9066</issn>
<publisher>
<publisher-name>Open Journals</publisher-name>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="publisher-id">4905</article-id>
<article-id pub-id-type="doi">10.21105/joss.04905</article-id>
<title-group>
<article-title>fieldcompare: A Python package for regression testing
simulation results</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author" corresp="yes">
<contrib-id contrib-id-type="orcid">https://orcid.org/0000-0001-9646-881X</contrib-id>
<name>
<surname>Gläser</surname>
<given-names>Dennis</given-names>
</name>
<xref ref-type="aff" rid="aff-1"/>
<xref ref-type="corresp" rid="cor-1"><sup>*</sup></xref>
</contrib>
<contrib contrib-type="author">
<contrib-id contrib-id-type="orcid">https://orcid.org/0000-0003-4776-5222</contrib-id>
<name>
<surname>Koch</surname>
<given-names>Timo</given-names>
</name>
<xref ref-type="aff" rid="aff-2"/>
</contrib>
<contrib contrib-type="author">
<contrib-id contrib-id-type="orcid">https://orcid.org/0000-0001-5236-3776</contrib-id>
<name>
<surname>Peters</surname>
<given-names>Sören</given-names>
</name>
<xref ref-type="aff" rid="aff-3"/>
</contrib>
<contrib contrib-type="author">
<contrib-id contrib-id-type="orcid">https://orcid.org/0000-0003-3689-2162</contrib-id>
<name>
<surname>Marcus</surname>
<given-names>Sven</given-names>
</name>
<xref ref-type="aff" rid="aff-3"/>
</contrib>
<contrib contrib-type="author">
<contrib-id contrib-id-type="orcid">https://orcid.org/0000-0001-8188-620X</contrib-id>
<name>
<surname>Flemisch</surname>
<given-names>Bernd</given-names>
</name>
<xref ref-type="aff" rid="aff-1"/>
</contrib>
<aff id="aff-1">
<institution-wrap>
<institution>University of Stuttgart, Germany</institution>
</institution-wrap>
</aff>
<aff id="aff-2">
<institution-wrap>
<institution>University of Oslo, Norway</institution>
</institution-wrap>
</aff>
<aff id="aff-3">
<institution-wrap>
<institution>Technical University Braunschweig, Germany</institution>
</institution-wrap>
</aff>
</contrib-group>
<author-notes>
<corresp id="cor-1">* E-mail: <email></email></corresp>
</author-notes>
<pub-date date-type="pub" publication-format="electronic" iso-8601-date="2022-07-14">
<day>14</day>
<month>7</month>
<year>2022</year>
</pub-date>
<volume>8</volume>
<issue>81</issue>
<fpage>4905</fpage>
<permissions>
<copyright-statement>Authors of papers retain copyright and release the
work under a Creative Commons Attribution 4.0 International License (CC
BY 4.0)</copyright-statement>
<copyright-year>2022</copyright-year>
<copyright-holder>The article authors</copyright-holder>
<license license-type="open-access" xlink:href="https://creativecommons.org/licenses/by/4.0/">
<license-p>Authors of papers retain copyright and release the work under
a Creative Commons Attribution 4.0 International License (CC BY
4.0)</license-p>
</license>
</permissions>
<kwd-group kwd-group-type="author">
<kwd>Python</kwd>
<kwd>simulation</kwd>
<kwd>regression test</kwd>
</kwd-group>
</article-meta>
</front>
<body>
<sec id="summary">
  <title>Summary</title>
  <p>In various research areas such as engineering, physics, and
  mathematics, numerical simulations play an important role. A number of
  research software simulation frameworks have been established, for
  instance, <monospace>Dune</monospace>
  (<xref alt="Bastian et al., 2008" rid="ref-bastian2008" ref-type="bibr">Bastian
  et al., 2008</xref>,
  <xref alt="2021" rid="ref-Dune2021" ref-type="bibr">2021</xref>),
  <monospace>Dumux</monospace>
  (<xref alt="Flemisch et al., 2011" rid="ref-dumux_2011" ref-type="bibr">Flemisch
  et al., 2011</xref>;
  <xref alt="Koch et al., 2021" rid="ref-Kochetaldumux2021" ref-type="bibr">Koch
  et al., 2021</xref>), <monospace>Deal.II</monospace>
  (<xref alt="Arndt et al., 2022" rid="ref-dealII94" ref-type="bibr">Arndt
  et al., 2022</xref>), <monospace>FEniCS</monospace>
  (<xref alt="A. Logg, 2012" rid="ref-fenicsbook2012" ref-type="bibr">A.
  Logg, 2012</xref>;
  <xref alt="FEniCS, 2023" rid="ref-fenics" ref-type="bibr"><italic>FEniCS</italic>,
  2023</xref>), and <monospace>VirtualFluids</monospace>
  (<xref alt="Kutscher et al., 2022" rid="ref-virtualfluids_2022" ref-type="bibr">Kutscher
  et al., 2022</xref>). Numerical software typically has a high inherent
  complexity as it aims at solving complex physical model equations by
  using advanced mathematical methods for solving partial differential
  equations. Beyond this, the model equations often involve parameters
  that are described by means of empirical constitutive relationships.
  Thus, a numerical simulation usually brings together various software
  components: for the domain discretization, the discretization method
  for the equations, the physics, and a non-linear and/or linear solver
  to obtain a solution for the discretized equations.</p>
  <p>While each of these components can be unit tested, it is important
  to have system tests that verify that a particular type of simulation
  can be carried out successfully. By <italic>successful</italic> we
  mean here that the simulation produces the <italic>correct</italic>
  results. As sufficiently complex problems often lack analytical
  solutions, determining correctness of numerical simulations poses a
  significant challenge. In the absence of an analytical solution, a
  common strategy is to use a trusted reference for comparison (e.g.,
  data measured in experiments or results from previous publications).
  From the perspective of software quality assurance, it suffices to
  define a reference result as the <italic>correct</italic> one and
  continuously verify that the code still reproduces it. In numerical
  software, such regression tests play a vital role at the level of
  system tests
  (<xref alt="Kempf &amp; Koch, 2017" rid="ref-dune_testtools" ref-type="bibr">Kempf
  &amp; Koch, 2017</xref>). They make sure that developers notice when a
  certain change to the code affects the results produced by the
  simulations. Whether the new results are better or worse has to be
  decided by the developers, and in the case of the former, the
  reference results may be updated.</p>
  <p>In order to carry out regression tests, one must be able to detect
  <italic>significant</italic> deviations between newly-computed and
  reference results. What a <italic>significant</italic> deviation is
  has to be decided by the developers as well, and adequate tolerances
  have to be chosen that are big enough to avoid false negatives from
  machine precision issues, but small enough to ensure that physically
  relevant deviations in the results are detected. Some numerical
  software packages as, for instance, <monospace>DUNE</monospace> and
  <monospace>DuMux</monospace>
  (<xref alt="Flemisch et al., 2011" rid="ref-dumux_2011" ref-type="bibr">Flemisch
  et al., 2011</xref>), provide mechanisms to detect such deviations.
  However, the functionality is not provided independent of the
  frameworks themselves and is therefore only available to their users.
  Besides this, only those mesh file formats that are used by the
  frameworks are supported. Very recently, <monospace>DuMux</monospace>
  incorporated <monospace>fieldcompare</monospace> into its test suite
  in place of its in-house solutions.</p>
</sec>
<sec id="statement-of-need">
  <title>Statement of Need</title>
  <p><monospace>fieldcompare</monospace> provides a tool that allows for
  detecting deviations in simulation results given in a variety of file
  formats. It supports several VTK file formats
  (<xref alt="Schroeder et al., 2006" rid="ref-schroeder_2006_VTK" ref-type="bibr">Schroeder
  et al., 2006</xref>) out-of-the-box, and a large number of further
  file formats are accessible via interoperability with
  <monospace>meshio</monospace>
  (<xref alt="Schlömer, 2022" rid="ref-meshio" ref-type="bibr">Schlömer,
  2022</xref>). However, <monospace>fieldcompare</monospace> is not
  restricted to mesh files, but can be used for any file format that
  contains data that fits into the concept of <italic>fields</italic>
  (see <xref alt="Figure 1" rid="figU003Aconcept">Figure 1</xref>). In
  principle, it can support file formats that represent collections of
  fields, where a field is something that has a name and an associated
  array of values. Currently, in addition to mesh files, support for DSV
  (delimiter-separated-values) files is provided; this is a widely-used
  format to store secondary data from simulations that one possibly
  wants to include in regression tests. The code is structured in a way
  that allows for easy integration of more file formats when needed.</p>
  <p>A challenge with regression-testing simulation results is that the
  order of points and cells may change within an otherwise identical
  mesh. The numerical solution may be the same, but it is organized in a
  different order in the mesh file. To this end,
  <monospace>fieldcompare</monospace> uses the approach of Kempf &amp;
  Koch
  (<xref alt="2017" rid="ref-dune_testtools" ref-type="bibr">2017</xref>),
  allowing a user to sort the mesh by arranging the point coordinates
  and cell connectivity in a lexicographically ascending manner to get a
  unique representation. This avoids false negative regression tests
  when only the order of the mesh has changed.</p>
  <p>Simulations often perform time integrations using a number of
  discrete time steps. To facilitate comparing the results of an entire
  time series, the command-line-interface (CLI) of
  <monospace>fieldcompare</monospace> offers the option to compare two
  folders with results. It searches both folders for matching file names
  and then performs file comparisons for each of the matching pairs.</p>
  <p>Finally, to make regression testing in continuous integration
  pipelines as easy as possible, we developed a GitHub Action around
  <monospace>fieldcompare</monospace>
  (<xref alt="Gläser, 2022" rid="ref-fieldcompare_action" ref-type="bibr">Gläser,
  2022</xref>), that can be used by projects hosted on GitHub to perform
  regression tests in their workflows with minimal effort. The CLI of
  <monospace>fieldcompare</monospace> also supports exporting the
  results of a regression test run into the
  <ext-link ext-link-type="uri" xlink:href="https://www.ibm.com/docs/de/developer-for-zos/14.1.0?topic=formats-junit-xml-format">junit
  xml file format</ext-link>, which is supported by some continuous
  integration platforms as, for instance,
  <ext-link ext-link-type="uri" xlink:href="https://docs.gitlab.com/ee/ci/">GitLab
  CI</ext-link>. If the <monospace>junit</monospace> report is submitted
  as an <monospace>artifact</monospace> from a GitLab pipeline, the
  GitLab web interface nicely displays which field comparisons have
  failed, passed, or were skipped, without the need to scan the pipeline
  log. We register field comparisons via the
  <monospace>testcase</monospace> element of the
  <ext-link ext-link-type="uri" xlink:href="https://www.ibm.com/docs/de/developer-for-zos/14.1.0?topic=formats-junit-xml-format">junit
  file format</ext-link>, while a file comparison is registered as a
  <monospace>testsuite</monospace>, with the comparisons of all fields
  contained in the file as underlying
  <monospace>testcases</monospace>.</p>
</sec>
<sec id="concept">
  <title>Concept</title>
  <p><monospace>fieldcompare</monospace> aims to provide a framework
  that can be used for comparing data structures that represent
  collections of <italic>fields</italic>. Such a collection exposes
  fields together with the <italic>domain</italic> on which they are
  defined. So far, our main focus has been on results of numerical
  simulations, where the domains are computational meshes and the fields
  are, for instance, the values of discrete numerical solutions on those
  meshes. In <monospace>fieldcompare</monospace>, such collections are
  represented by the <monospace>FieldData</monospace> protocol, and two
  implementations currently exist: <monospace>MeshFields</monospace> and
  <monospace>TabularFields</monospace>. The former represents numerical
  results, as discussed before, while the latter exposes tabular data,
  for instance, read from a DSV file.</p>
  <p>Two instances of objects conforming to the
  <monospace>FieldData</monospace> protocol can then be compared using
  the <monospace>FieldDataComparison</monospace> class, which checks
  that the domains are equal and that a given
  <monospace>Predicate</monospace> evaluates to true for the values of
  those fields that have matching names. A
  <monospace>Predicate</monospace> is a <italic>callable</italic> that
  takes two value arrays and returns a
  <monospace>PredicateResult</monospace>, which is an object that can be
  converted to <monospace>bool</monospace>, while further exposing
  information such as detected violations, tolerances used, etc. Note
  that it is possible to provide different
  <monospace>Predicate</monospace>s on a per-field basis, and per
  default, the array values are compared for fuzzy equality.</p>
  <p>For an illustration of the concept, see
  <xref alt="Figure 1" rid="figU003Aconcept">Figure 1</xref>.</p>
  <fig>
    <caption><p>Basic concept: <monospace>FieldData</monospace> is
    either read from a file with the I/O facilities provided by
    fieldcompare, or constructed manually, or by conversion from a
    <monospace>meshio</monospace> mesh. Subsequently, it can be passed
    to the <monospace>FieldDataComparison</monospace> class to compare
    them against reference data, optionally using custom predicates to
    compare the individual field values.
    <styled-content id="figU003Aconcept"></styled-content></p></caption>
    <graphic mimetype="image" mime-subtype="png" xlink:href="media/img/concept.png" xlink:title="" />
  </fig>
  <p>The following code snippet illustrates how to read fields from two
  mesh files, sort the meshes to avoid false negatives from differing
  mesh ordering, and check the fields for customized fuzzy equality:</p>
  <code language="python">from fieldcompare import FieldDataComparator
from fieldcompare.io import read
from fieldcompare.mesh import sort
from fieldcompare.predicates import FuzzyEquality

result_fields = read(&quot;test/data/test_mesh.vtu&quot;)
reference_fields = read(&quot;test/data/test_mesh_permutated.vtu&quot;)
comparator = FieldDataComparator(result_fields, reference_fields)

# The `FieldDataComparator` has a default choice for predicates
# that it uses. But, we can (optionally) pass in a selector
# function (which will be invoked with the two fields to be
# compared) from which we can return the predicate we would
# like to use for a pair of fields:
predicate = FuzzyEquality(abs_tol=1e-6, rel_tol=1e-8)
result = comparator(predicate_selector=lambda _, __: predicate)

if not result and not result.domain_equality_check:
    print(&quot;Meshes not equal, retrying with sorted meshes...&quot;)
    result_fields = sort(result_fields)
    reference_fields = sort(reference_fields)
    result = FieldDataComparator(result_fields, reference_fields)(
        predicate_selector=lambda _, __: predicate
    )

print(f&quot;Result is {bool(result)}&quot;)

# The result is a suite of field comparisons that we can loop over
# and print information on each comparison that was performed
for field_comp in result:
    print(f&quot;Field name: {field_comp.name}&quot;)
    print(f&quot;Status: {field_comp.status}&quot;)
    print(f&quot;Predicate: {field_comp.predicate}&quot;)
    print(f&quot;Report: {field_comp.report}&quot;)</code>
  <p>Note that the API of <monospace>fieldcompare</monospace> also
  exposes a <monospace>MeshFieldsComparator</monospace> that can be used
  for fields defined on computational meshes. It automatically sorts the
  meshes in case they are not equal, making it possible to write a
  simple equality check for meshes using a custom predicate in a single
  instruction:</p>
  <code language="python">from fieldcompare.io import read
from fieldcompare.mesh import MeshFieldsComparator
from fieldcompare.predicates import FuzzyEquality

assert MeshFieldsComparator(
    source=read(&quot;test/data/test_mesh.vtu&quot;),
    reference=read(&quot;test/data/test_mesh_permutated.vtu&quot;)
)(
    predicate_selector=lambda _, __: FuzzyEquality(
        abs_tol=1e-6, rel_tol=1e-8
    )
)</code>
  <p>On the command line, the mesh is sorted by default (though this can
  be deactivated with a runtime flag). Results similar to the examples
  shown above can be obtained with the following commands:</p>
  <code language="bash"># uses default tolerances
fieldcompare file test/data/test_mesh.vtu \
                  test/data/test_mesh_permutated.vtu

# specify tolerances
fieldcompare file test/data/test_mesh.vtu \
                  test/data/test_mesh_permutated.vtu \
                  --absolute-tolerance 1e-6 \
                  --relative-tolerance 1e-8

# specify the tolerances for a specific field only
fieldcompare file test/data/test_mesh.vtu \
                  test/data/test_mesh_permutated.vtu \
                  --absolute-tolerance function:1e-6 \
                  --relative-tolerance function:1e-8</code>
</sec>
<sec id="the-fuzzy-details">
  <title>The fuzzy details</title>
  <p>Fuzziness is crucial when comparing fields of floating-point
  values, which are unlikely to be bit-wise identical to a reference
  solution when computed on different machines and/or after slight
  modifications to the code. In the code examples above, we have used
  the <monospace>FuzzyEquality</monospace> predicate of
  <monospace>fieldcompare</monospace>, which allows us define the
  absolute and relative tolerances to be used. However, specifying the
  tolerances is optional, so what are the defaults?</p>
  <p>First of all, the <monospace>FuzzyEquality</monospace> predicate in
  <monospace>fieldcompare</monospace> evaluates to true if two given
  arrays have the same shape, and for each pair
  (<inline-formula><alternatives>
  <tex-math><![CDATA[a]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>a</mml:mi></mml:math></alternatives></inline-formula>,
  <inline-formula><alternatives>
  <tex-math><![CDATA[b]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>b</mml:mi></mml:math></alternatives></inline-formula>)
  of scalar values in the arrays, the following condition holds:</p>
  <p><disp-formula><alternatives>
  <tex-math><![CDATA[\vert a - b \vert \le max(\rho \cdot max(\vert a \vert, \vert b \vert), \epsilon).]]></tex-math>
  <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo stretchy="false" form="postfix">|</mml:mo><mml:mi>a</mml:mi><mml:mo>−</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false" form="postfix">|</mml:mo><mml:mo>≤</mml:mo><mml:mi>m</mml:mi><mml:mi>a</mml:mi><mml:mi>x</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>ρ</mml:mi><mml:mo>⋅</mml:mo><mml:mi>m</mml:mi><mml:mi>a</mml:mi><mml:mi>x</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mo stretchy="false" form="postfix">|</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false" form="postfix">|</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false" form="postfix">|</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false" form="postfix">|</mml:mo><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mi>ϵ</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mi>.</mml:mi></mml:mrow></mml:math></alternatives></disp-formula></p>
  <p>Here, <inline-formula><alternatives>
  <tex-math><![CDATA[\rho]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>ρ</mml:mi></mml:math></alternatives></inline-formula>
  and <inline-formula><alternatives>
  <tex-math><![CDATA[\epsilon]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>ϵ</mml:mi></mml:math></alternatives></inline-formula>
  are the relative and absolute tolerance, respectively. Per default,
  <inline-formula><alternatives>
  <tex-math><![CDATA[\epsilon = 0]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>ϵ</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></alternatives></inline-formula>,
  which means that each pair of scalars is tested by a relative
  criterion. The default relative tolerance depends on the data type and
  is chosen as the difference between <inline-formula><alternatives>
  <tex-math><![CDATA[1.0]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mn>1.0</mml:mn></mml:math></alternatives></inline-formula>
  and the next smallest value larger than <inline-formula><alternatives>
  <tex-math><![CDATA[1.0]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mn>1.0</mml:mn></mml:math></alternatives></inline-formula>
  as representable by the data type at hand (i.e., the
  <ext-link ext-link-type="uri" xlink:href="https://en.wikipedia.org/wiki/Unit_in_the_last_place">unit
  of least precision</ext-link>). For 64-bit floating-point values
  following the IEEE-754 standard (“IEEE Standard for Binary
  Floating-Point Arithmetic”
  (<xref alt="1985" rid="ref-ieee754" ref-type="bibr">1985</xref>)) this
  yields <inline-formula><alternatives>
  <tex-math><![CDATA[\rho_{\mathrm{default}} \approx 2.22 \cdot 10^{-16}]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>ρ</mml:mi><mml:mstyle mathvariant="normal"><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>f</mml:mi><mml:mi>a</mml:mi><mml:mi>u</mml:mi><mml:mi>l</mml:mi><mml:mi>t</mml:mi></mml:mstyle></mml:msub><mml:mo>≈</mml:mo><mml:mn>2.22</mml:mn><mml:mo>⋅</mml:mo><mml:msup><mml:mn>10</mml:mn><mml:mrow><mml:mo>−</mml:mo><mml:mn>16</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></alternatives></inline-formula>;
  that is, we require the values to match in
  <inline-formula><alternatives>
  <tex-math><![CDATA[\approx 15]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo>≈</mml:mo><mml:mn>15</mml:mn></mml:mrow></mml:math></alternatives></inline-formula>
  decimal digits. Generally, the tolerances should be carefully chosen
  for the context at hand, and the rather strict default values were
  selected to minimize the chances of false positives when using
  <monospace>fieldcompare</monospace> without any tolerance
  settings.</p>
  <p>A common issue, in particular in numerical simulations, is that the
  values in a field may span several orders of magnitude, which may have
  a negative impact on the precision one can expect from the smaller
  values. As an example, consider a flow simulation with very high
  velocities in some parts of the domain, while in others the velocity
  is close to zero. A relative tolerance appropriate for the large
  velocities is unlikely to be suitable for the entire range of
  values.</p>
  <p>For such scenarios, a suitable choice for the absolute tolerance
  <inline-formula><alternatives>
  <tex-math><![CDATA[\epsilon]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>ϵ</mml:mi></mml:math></alternatives></inline-formula>
  comes into play, which can help avoid false negatives from comparing
  the velocities that are close to zero. According to the above formula,
  a switch to an absolute criterion occurs when the scaled relative
  tolerance falls below <inline-formula><alternatives>
  <tex-math><![CDATA[\epsilon]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>ϵ</mml:mi></mml:math></alternatives></inline-formula>.
  In other words, <inline-formula><alternatives>
  <tex-math><![CDATA[\epsilon]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>ϵ</mml:mi></mml:math></alternatives></inline-formula>
  defines a lower bound for the allowed difference between field values,
  which is illustrated in the figures below.</p>
  <p><inline-graphic mimetype="application" mime-subtype="pdf" xlink:href="media/img/fuzzy_eq_zero_abs_tol.pdf" />
  <inline-graphic mimetype="application" mime-subtype="pdf" xlink:href="media/img/fuzzy_eq.pdf" /></p>
  <p>As can be seen, while for <inline-formula><alternatives>
  <tex-math><![CDATA[\epsilon = 0]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>ϵ</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></alternatives></inline-formula>
  the allowed difference between values goes down to zero as
  <inline-formula><alternatives>
  <tex-math><![CDATA[a \rightarrow 0]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>a</mml:mi><mml:mo>→</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></alternatives></inline-formula>,
  a constant residual difference is allowed for small values of
  <inline-formula><alternatives>
  <tex-math><![CDATA[a]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>a</mml:mi></mml:math></alternatives></inline-formula>
  in the case of <inline-formula><alternatives>
  <tex-math><![CDATA[\epsilon > 0]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>ϵ</mml:mi><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></alternatives></inline-formula>.
  A suitable choice for <inline-formula><alternatives>
  <tex-math><![CDATA[\epsilon]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>ϵ</mml:mi></mml:math></alternatives></inline-formula>
  depends on the fields to be compared, and when comparing a large
  number of fields, it can be cumbersome to define
  <inline-formula><alternatives>
  <tex-math><![CDATA[\epsilon]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>ϵ</mml:mi></mml:math></alternatives></inline-formula>
  for all of them. We found that a useful heuristic is to define
  <inline-formula><alternatives>
  <tex-math><![CDATA[\epsilon]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>ϵ</mml:mi></mml:math></alternatives></inline-formula>
  as a fraction of the maximum absolute value of both fields as an
  estimate for the precision that can be expected from the smaller
  values. Using the <monospace>fieldcompare</monospace> API, this can be
  achieved with the <monospace>ScaledTolerance</monospace> class, which
  is accepted by all interfaces receiving tolerances. A modified version
  of the previous example may look like this:</p>
  <code language="python">from fieldcompare.io import read
from fieldcompare.mesh import MeshFieldsComparator
from fieldcompare.predicates import FuzzyEquality, ScaledTolerance

assert MeshFieldsComparator(
    source=read(&quot;test/data/test_mesh.vtu&quot;),
    reference=read(&quot;test/data/test_mesh_permutated.vtu&quot;)
)(
    predicate_selector=lambda _, __: FuzzyEquality(
        abs_tol=ScaledTolerance(base_tolerance=1e-12),
        rel_tol=1e-8
    )
)</code>
  <p>With the above code, the absolute tolerance is computed for a pair
  of fields <inline-formula><alternatives>
  <tex-math><![CDATA[f_1]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>f</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math></alternatives></inline-formula>
  and <inline-formula><alternatives>
  <tex-math><![CDATA[f_2]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>f</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:math></alternatives></inline-formula>
  via <inline-formula><alternatives>
  <tex-math><![CDATA[\epsilon = max(mag(f_1), mag(f_2)) \cdot 10^{-12}]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>ϵ</mml:mi><mml:mo>=</mml:mo><mml:mi>m</mml:mi><mml:mi>a</mml:mi><mml:mi>x</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>m</mml:mi><mml:mi>a</mml:mi><mml:mi>g</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>f</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mi>m</mml:mi><mml:mi>a</mml:mi><mml:mi>g</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>f</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>⋅</mml:mo><mml:msup><mml:mn>10</mml:mn><mml:mrow><mml:mo>−</mml:mo><mml:mn>12</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></alternatives></inline-formula>,
  where <monospace>mag</monospace> estimates the magnitude as the
  maximum absolute scalar value in a field. In the CLI, this
  functionality is exposed via the following syntax:</p>
  <code language="bash">fieldcompare file test/data/test_mesh.vtu \
                  test/data/test_mesh_permutated.vtu \
                  -atol 1e-12*max</code>
  <sec id="fuzzy-mesh-comparison">
    <title>Fuzzy mesh comparison</title>
    <p>As mentioned above, before the
    <monospace>FieldDataComparison</monospace> compares fields, it
    checks if the domains on which they are defined are
    <italic>equal</italic>. In the case of computational meshes, this
    check also has to be done in a fuzzy sense, since the point
    coordinates of the meshes are typically given as floating-point
    values. Moreover, the mesh sorting algorithms shown in the examples
    above also rely on fuzziness, and therefore, it is again crucial
    that suitable tolerances are defined. As a default,
    <monospace>fieldcompare</monospace> uses
    <inline-formula><alternatives>
    <tex-math><![CDATA[\rho = 10^{-8}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>ρ</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mn>10</mml:mn><mml:mrow><mml:mo>−</mml:mo><mml:mn>8</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></alternatives></inline-formula>
    and <inline-formula><alternatives>
    <tex-math><![CDATA[\epsilon = \tilde{x}*10^{-8}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>ϵ</mml:mi><mml:mo>=</mml:mo><mml:mover><mml:mi>x</mml:mi><mml:mo accent="true">̃</mml:mo></mml:mover><mml:mo>*</mml:mo><mml:msup><mml:mn>10</mml:mn><mml:mrow><mml:mo>−</mml:mo><mml:mn>8</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></alternatives></inline-formula>,
    where <inline-formula><alternatives>
    <tex-math><![CDATA[\tilde{x}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mover><mml:mi>x</mml:mi><mml:mo accent="true">̃</mml:mo></mml:mover></mml:math></alternatives></inline-formula>
    is the maximum occurring coordinate value in all points of the grid.
    Tolerances for domain equality checks can be set via the CLI as
    follows (again supporting the definition of scaled absolute
    tolerances):</p>
    <code language="bash">fieldcompare file test/data/test_mesh.vtu \
                  test/data/test_mesh_permutated.vtu \
                  -atol domain:1e-12*max \
                  -rtol domain:1e-7</code>
    <p>Programmatically, tolerances can be set directly on instances of
    a <monospace>Mesh</monospace>. As outlined before, the
    <italic>domain</italic> is a mesh when reading fields from mesh
    files, and the behavior of the above call to the CLI can be
    reproduced programmatically with the following code snippet:</p>
    <code language="python">from fieldcompare.io import read
from fieldcompare.mesh import MeshFieldsComparator
from fieldcompare.predicates import FuzzyEquality, ScaledTolerance

source = read(&quot;test/data/test_mesh.vtu&quot;)
reference = read(&quot;test/data/test_mesh_permutated.vtu&quot;)
source.domain.set_tolerances(
    abs_tol=ScaledTolerance(1e-12),
    rel_tol=1e-7
)
reference.domain.set_tolerances(
    abs_tol=ScaledTolerance(1e-12),
    rel_tol=1e-7
)
assert MeshFieldsComparator(source, reference)()</code>
  </sec>
</sec>
<sec id="applications">
  <title>Applications</title>
  <p><monospace>fieldcompare</monospace> is currently used successfully
  by <monospace>VirtualFluids</monospace>
  (<xref alt="Kutscher et al., 2022" rid="ref-virtualfluids_2022" ref-type="bibr">Kutscher
  et al., 2022</xref>) to continuously verify the results of the latest
  changes to the source code inside a continuous integration (CI)
  pipeline. To this end, <monospace>VirtualFluids</monospace> makes use
  of the command-line-interface of <monospace>fieldcompare</monospace>.
  Inside the CI pipeline, the trusted reference data is downloaded from
  a separate data source, in this case a Git repository. After that, the
  <monospace>fieldcompare</monospace> package is installed, and finally,
  a bash script compiles <monospace>VirtualFluids</monospace>, runs
  several simulations, and compares their result data with the
  respective reference files using the
  <monospace>fieldcompare</monospace> CLI. In case one of the test cases
  fails, the developers are notified by the continuous integration
  pipeline, therefore providing rapid feedback and allowing them to
  immediately start working on resolving the issue.</p>
  <fig id="imgU003Avf">
    <caption><p>Overview of the VirtualFluids pipeline using
    fieldcompare</p></caption>
    <graphic mimetype="application" mime-subtype="pdf" xlink:href="media/img/vf-fieldcompare.pdf" xlink:title="" />
  </fig>
  <p>Another project in which <monospace>fieldcompare</monospace> is
  currently in use is <monospace>Argo</monospace>
  (<xref alt="Tolle &amp; Maric, 2023" rid="ref-argo_repo" ref-type="bibr">Tolle
  &amp; Maric, 2023</xref>), an <monospace>OpenFoam</monospace>
  (<xref alt="OpenFOAM, 2023" rid="ref-openfoam" ref-type="bibr"><italic>OpenFOAM</italic>,
  2023</xref>) module for multiphase flow simulations. The continuous
  integration pipeline of <monospace>Argo</monospace> checks if the
  current state of the code is able to reproduce previously-published
  results by rerunning the cases of a paper
  (<xref alt="Tolle et al., 2022" rid="ref-tolle2022trisurfaceimmersion" ref-type="bibr">Tolle
  et al., 2022</xref>), fetching the published results from
  <monospace>Zenodo</monospace>
  (<xref alt="European Organization For Nuclear Research &amp; OpenAIRE, 2013" rid="ref-Zenodo2013" ref-type="bibr">European
  Organization For Nuclear Research &amp; OpenAIRE, 2013</xref>;
  <xref alt="Maric et al., 2021" rid="ref-maric_tomislav_2021_5603255" ref-type="bibr">Maric
  et al., 2021</xref>), and using <monospace>fieldcompare</monospace> to
  check for significant deviations.</p>
  <p>The SURESOFT
  (<xref alt="Blech et al., 2022" rid="ref-suresoft2022" ref-type="bibr">Blech
  et al., 2022</xref>) project aims to establish a common usable
  methodology and infrastructure based on the concepts of continuous
  integration and containerization to approve the quality of research
  software, easing software delivery and ensuring long-term
  sustainability and availability. One exemplary workflow of SURESOFT
  (<xref alt="Peters &amp; Marcus, 2022" rid="ref-suresoft_hpc_workflow_2022" ref-type="bibr">Peters
  &amp; Marcus, 2022</xref>) deploys a Singularity container on an HPC
  platform using <monospace>HPC-Rocket</monospace>
  (<xref alt="Marcus, 2022" rid="ref-marcus_hpcrocket_2022" ref-type="bibr">Marcus,
  2022</xref>), runs a numerical simulation on the cluster, and
  validates the results with <monospace>fieldcompare</monospace>.</p>
  <p>Finally, <monospace>DuMux</monospace>
  (<xref alt="Koch et al., 2021" rid="ref-Kochetaldumux2021" ref-type="bibr">Koch
  et al., 2021</xref>) uses the API of fieldcompare in its test suite,
  consisting of nearly <inline-formula><alternatives>
  <tex-math><![CDATA[600]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mn>600</mml:mn></mml:math></alternatives></inline-formula>
  unit, integration, and system tests, the majority of which are
  regression tests. Calls to the <monospace>fieldcompare</monospace> API
  occur in the central
  <ext-link ext-link-type="uri" xlink:href="https://git.iws.uni-stuttgart.de/dumux-repositories/dumux/-/blob/master/bin/testing/runtest.py">test
  script</ext-link> of <monospace>DuMux</monospace>, where suitable
  default tolerances are defined, which are overridden by a few
  individual tests.</p>
</sec>
<sec id="acknowledgements">
  <title>Acknowledgements</title>
  <p>The authors would like to thank the Federal Government and the
  Heads of Government of the Länder, as well as the Joint Science
  Conference (GWK), for their funding and support within the framework
  of the NFDI4Ing consortium. Funded by the German Research Foundation
  (DFG) - project number 442146713. Additionally funding from the
  Deutsche Forschungsgemeinschaft (Project SURESOFT, LI 2970/1-1) and
  from the European Union’s Horizon 2020 Research and Innovation
  programme under the Marie Skłodowska-Curie Actions Grant agreement No
  801133 is gratefully acknowledged. Most of the icons in the presented
  figures have been obtained from Font Awesome by Dave Gandy -
  <ext-link ext-link-type="uri" xlink:href="http://fontawesome.io">fontawesome.io</ext-link></p>
</sec>
</body>
<back>
<ref-list>
  <ref id="ref-meshio">
    <element-citation>
      <person-group person-group-type="author">
        <name><surname>Schlömer</surname><given-names>Nico</given-names></name>
      </person-group>
      <article-title>MeshIO: Input/output for many mesh formats</article-title>
      <publisher-name>Published on GitHub https://github.com/nschloe/meshio and also accessible via Software Heritage Permalink</publisher-name>
      <year iso-8601-date="2022">2022</year>
    </element-citation>
  </ref>
  <ref id="ref-fieldcompare_action">
    <element-citation>
      <person-group person-group-type="author">
        <name><surname>Gläser</surname><given-names>Dennis</given-names></name>
      </person-group>
      <article-title>GitHub action for FieldCompare</article-title>
      <source>GitHub repository</source>
      <publisher-name>GitHub</publisher-name>
      <year iso-8601-date="2022">2022</year>
      <uri>https://github.com/dglaeser/fieldcompare-action</uri>
    </element-citation>
  </ref>
  <ref id="ref-schroeder_2006_VTK">
    <element-citation publication-type="book">
      <person-group person-group-type="author">
        <name><surname>Schroeder</surname><given-names>Will</given-names></name>
        <name><surname>Martin</surname><given-names>Ken</given-names></name>
        <name><surname>Lorensen</surname><given-names>Bill</given-names></name>
      </person-group>
      <source>The visualization toolkit</source>
      <publisher-name>Kitware</publisher-name>
      <year iso-8601-date="2006">2006</year>
    </element-citation>
  </ref>
  <ref id="ref-dumux_2011">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Flemisch</surname><given-names>B.</given-names></name>
        <name><surname>Darcis</surname><given-names>M.</given-names></name>
        <name><surname>Erbertseder</surname><given-names>K.</given-names></name>
        <name><surname>Faigle</surname><given-names>B.</given-names></name>
        <name><surname>Lauser</surname><given-names>A.</given-names></name>
        <name><surname>Mosthaf</surname><given-names>K.</given-names></name>
        <name><surname>Müthing</surname><given-names>S.</given-names></name>
        <name><surname>Nuske</surname><given-names>P.</given-names></name>
        <name><surname>Tatomir</surname><given-names>A.</given-names></name>
        <name><surname>Wolff</surname><given-names>M.</given-names></name>
        <name><surname>Helmig</surname><given-names>R.</given-names></name>
      </person-group>
      <article-title>DuMux: DUNE for multi-{phase, component, scale, physics, …} flow and transport in porous media</article-title>
      <source>Advances in Water Resources</source>
      <year iso-8601-date="2011">2011</year>
      <volume>34</volume>
      <issue>9</issue>
      <issn>0309-1708</issn>
      <uri>https://www.sciencedirect.com/science/article/pii/S030917081100056X</uri>
      <pub-id pub-id-type="doi">10.1016/j.advwatres.2011.03.007</pub-id>
      <fpage>1102</fpage>
      <lpage>1112</lpage>
    </element-citation>
  </ref>
  <ref id="ref-dune_testtools">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Kempf</surname><given-names>Dominic</given-names></name>
        <name><surname>Koch</surname><given-names>Timo</given-names></name>
      </person-group>
      <article-title>System testing in scientific numerical software frameworks using the example of DUNE</article-title>
      <year iso-8601-date="2017-03">2017</year><month>03</month>
      <volume>5</volume>
      <pub-id pub-id-type="doi">10.11588/ans.2017.1.27447</pub-id>
      <fpage>151</fpage>
      <lpage>168</lpage>
    </element-citation>
  </ref>
  <ref id="ref-Kochetaldumux2021">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Koch</surname><given-names>Timo</given-names></name>
        <name><surname>Gläser</surname><given-names>Dennis</given-names></name>
        <name><surname>Weishaupt</surname><given-names>Kilian</given-names></name>
        <name><surname>others</surname></name>
      </person-group>
      <article-title>DuMux 3 - an open-source simulator for solving flow and transport problems in porous media with a focus on model coupling</article-title>
      <source>Computers &amp; Mathematics with Applications</source>
      <year iso-8601-date="2021">2021</year>
      <volume>81</volume>
      <pub-id pub-id-type="doi">10.1016/j.camwa.2020.02.012</pub-id>
      <fpage>423</fpage>
      <lpage>443</lpage>
    </element-citation>
  </ref>
  <ref id="ref-bastian2008">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Bastian</surname><given-names>Peter</given-names></name>
        <name><surname>Blatt</surname><given-names>Markus</given-names></name>
        <name><surname>Dedner</surname><given-names>Andreas</given-names></name>
        <name><surname>Engwer</surname><given-names>Christian</given-names></name>
        <name><surname>Klöfkorn</surname><given-names>Robert</given-names></name>
        <name><surname>Kornhuber</surname><given-names>Ralf</given-names></name>
        <name><surname>Ohlberger</surname><given-names>Mario</given-names></name>
        <name><surname>Sander</surname><given-names>Oliver</given-names></name>
      </person-group>
      <article-title>A generic grid interface for parallel and adaptive scientific computing. Part II: Implementation and tests in DUNE</article-title>
      <source>Computing</source>
      <publisher-name>Springer</publisher-name>
      <year iso-8601-date="2008">2008</year>
      <volume>82</volume>
      <issue>2</issue>
      <pub-id pub-id-type="doi">10.1007/s00607-008-0004-9</pub-id>
      <fpage>121</fpage>
      <lpage>138</lpage>
    </element-citation>
  </ref>
  <ref id="ref-Dune2021">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Bastian</surname><given-names>Peter</given-names></name>
        <name><surname>Blatt</surname><given-names>Markus</given-names></name>
        <name><surname>Dedner</surname><given-names>Andreas</given-names></name>
        <name><surname>Dreier</surname><given-names>Nils-Arne</given-names></name>
        <name><surname>Engwer</surname><given-names>Christian</given-names></name>
        <name><surname>Fritze</surname><given-names>René</given-names></name>
        <name><surname>Gräser</surname><given-names>Carsten</given-names></name>
        <name><surname>Grüninger</surname><given-names>Christoph</given-names></name>
        <name><surname>Kempf</surname><given-names>Dominic</given-names></name>
        <name><surname>Klöfkorn</surname><given-names>Robert</given-names></name>
        <name><surname>Ohlberger</surname><given-names>Mario</given-names></name>
        <name><surname>Sander</surname><given-names>Oliver</given-names></name>
      </person-group>
      <article-title>The Dune framework: Basic concepts and recent developments</article-title>
      <source>Computers &amp; Mathematics with Applications</source>
      <year iso-8601-date="2021">2021</year>
      <volume>81</volume>
      <pub-id pub-id-type="doi">10.1016/j.camwa.2020.06.007</pub-id>
      <fpage>75</fpage>
      <lpage>112</lpage>
    </element-citation>
  </ref>
  <ref id="ref-dealII94">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Arndt</surname><given-names>Daniel</given-names></name>
        <name><surname>Bangerth</surname><given-names>Wolfgang</given-names></name>
        <name><surname>Feder</surname><given-names>Marco</given-names></name>
        <name><surname>Fehling</surname><given-names>Marc</given-names></name>
        <name><surname>Gassmöller</surname><given-names>Rene</given-names></name>
        <name><surname>Heister</surname><given-names>Timo</given-names></name>
        <name><surname>Heltai</surname><given-names>Luca</given-names></name>
        <name><surname>Kronbichler</surname><given-names>Martin</given-names></name>
        <name><surname>Maier</surname><given-names>Matthias</given-names></name>
        <name><surname>Munch</surname><given-names>Peter</given-names></name>
        <name><surname>Pelteret</surname><given-names>Jean-Paul</given-names></name>
        <name><surname>Sticko</surname><given-names>Simon</given-names></name>
        <name><surname>Turcksin</surname><given-names>Bruno</given-names></name>
        <name><surname>Wells</surname><given-names>David</given-names></name>
      </person-group>
      <article-title>The deal.II library, version 9.4</article-title>
      <source>Journal of Numerical Mathematics</source>
      <year iso-8601-date="2022">2022</year>
      <volume>30</volume>
      <issue>3</issue>
      <uri>https://doi.org/10.1515/jnma-2022-0054</uri>
      <pub-id pub-id-type="doi">10.1515/jnma-2022-0054</pub-id>
      <fpage>231</fpage>
      <lpage>246</lpage>
    </element-citation>
  </ref>
  <ref id="ref-virtualfluids_2022">
    <element-citation>
      <person-group person-group-type="author">
        <name><surname>Kutscher</surname><given-names>Konstantin</given-names></name>
        <name><surname>Schönherr</surname><given-names>Martin</given-names></name>
        <name><surname>Geier</surname><given-names>Martin</given-names></name>
        <name><surname>Marcus</surname><given-names>Sven</given-names></name>
        <name><surname>Peters</surname><given-names>Sören</given-names></name>
        <name><surname>Linxweiler</surname><given-names>Jan</given-names></name>
        <name><surname>Krafczyk</surname><given-names>Manfred</given-names></name>
        <name><surname>Wellmann</surname><given-names>Anna</given-names></name>
      </person-group>
      <article-title>VirtualFluids</article-title>
      <source>GitLab repository</source>
      <publisher-name>GitLab</publisher-name>
      <year iso-8601-date="2022">2022</year>
      <uri>https://git.rz.tu-bs.de/irmb/virtualfluids</uri>
    </element-citation>
  </ref>
  <ref id="ref-Zenodo2013">
    <element-citation>
      <person-group person-group-type="author">
        <string-name>European Organization For Nuclear Research</string-name>
        <string-name>OpenAIRE</string-name>
      </person-group>
      <article-title>Zenodo</article-title>
      <publisher-name>CERN</publisher-name>
      <year iso-8601-date="2013">2013</year>
      <uri>https://www.zenodo.org/</uri>
      <pub-id pub-id-type="doi">10.25495/7GXK-RD71</pub-id>
    </element-citation>
  </ref>
  <ref id="ref-maric_tomislav_2021_5603255">
    <element-citation publication-type="dataset">
      <person-group person-group-type="author">
        <name><surname>Maric</surname><given-names>Tomislav</given-names></name>
        <name><surname>Tolle</surname><given-names>Tobias</given-names></name>
        <name><surname>Gruending</surname><given-names>Dirk</given-names></name>
      </person-group>
      <article-title>Computing volume fractions and signed distances from arbitrary surfaces on unstructured meshes</article-title>
      <publisher-name>Zenodo</publisher-name>
      <year iso-8601-date="2021-10">2021</year><month>10</month>
      <uri>https://doi.org/10.5281/zenodo.5603255</uri>
      <pub-id pub-id-type="doi">10.5281/zenodo.5603255</pub-id>
    </element-citation>
  </ref>
  <ref id="ref-tolle2022trisurfaceimmersion">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Tolle</surname><given-names>Tobias</given-names></name>
        <name><surname>Gründing</surname><given-names>Dirk</given-names></name>
        <name><surname>Bothe</surname><given-names>Dieter</given-names></name>
        <name><surname>Marić</surname><given-names>Tomislav</given-names></name>
      </person-group>
      <article-title>triSurfaceImmersion: Computing volume fractions and signed distances from triangulated surfaces immersed in unstructured meshes</article-title>
      <source>Computer Physics Communications</source>
      <publisher-name>Elsevier</publisher-name>
      <year iso-8601-date="2022">2022</year>
      <volume>273</volume>
      <pub-id pub-id-type="doi">10.1016/j.cpc.2021.108249</pub-id>
      <fpage>108249</fpage>
      <lpage></lpage>
    </element-citation>
  </ref>
  <ref id="ref-suresoft2022">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Blech</surname><given-names>Christopher</given-names></name>
        <name><surname>Dreyer</surname><given-names>Nils</given-names></name>
        <name><surname>Friebel</surname><given-names>Matthias</given-names></name>
        <name><surname>Jacob</surname><given-names>Christoph</given-names></name>
        <name><surname>Shamil Jassim</surname><given-names>Mostafa</given-names></name>
        <name><surname>Jehl</surname><given-names>Leander</given-names></name>
        <name><surname>Kapitza</surname><given-names>Rüdiger</given-names></name>
        <name><surname>Krafczyk</surname><given-names>Manfred</given-names></name>
        <name><surname>Kürner</surname><given-names>Thomas</given-names></name>
        <name><surname>Langer</surname><given-names>Sabine Christine</given-names></name>
        <name><surname>Linxweiler</surname><given-names>Jan</given-names></name>
        <name><surname>Mahhouk</surname><given-names>Mohammad</given-names></name>
        <name><surname>Marcus</surname><given-names>Sven</given-names></name>
        <name><surname>Messadi</surname><given-names>Ines</given-names></name>
        <name><surname>Peters</surname><given-names>Sören</given-names></name>
        <name><surname>Pilawa</surname><given-names>Jan-Marc</given-names></name>
        <name><surname>Sreekumar</surname><given-names>Harikrishnan K.</given-names></name>
        <name><surname>Strötgen</surname><given-names>Robert</given-names></name>
        <name><surname>Stump</surname><given-names>Katrin</given-names></name>
        <name><surname>Vogel</surname><given-names>Arne</given-names></name>
        <name><surname>Wolter</surname><given-names>Mario</given-names></name>
      </person-group>
      <article-title>SURESOFT: Towards sustainable research software</article-title>
      <publisher-name>Technische Universität</publisher-name>
      <publisher-loc>Braunschweig</publisher-loc>
      <year iso-8601-date="2022">2022</year>
      <uri>https://leopard.tu-braunschweig.de/receive/dbbs_mods_00071451</uri>
      <pub-id pub-id-type="doi">10.24355/dbbs.084-202210121528-0</pub-id>
    </element-citation>
  </ref>
  <ref id="ref-openfoam">
    <element-citation>
      <article-title>OpenFOAM</article-title>
      <publisher-name>Website: https://www.openfoam.com/, code repository: https://develop.openfoam.com/Development/openfoam</publisher-name>
      <year iso-8601-date="2023">2023</year>
    </element-citation>
  </ref>
  <ref id="ref-argo_repo">
    <element-citation>
      <person-group person-group-type="author">
        <name><surname>Tolle</surname><given-names>Tobias</given-names></name>
        <name><surname>Maric</surname><given-names>Tomislav</given-names></name>
      </person-group>
      <article-title>argo</article-title>
      <publisher-name>Published on GitLab https://gitlab.com/leia-methods/argo and also accessible via Software Heritage Permalink</publisher-name>
      <year iso-8601-date="2023">2023</year>
    </element-citation>
  </ref>
  <ref id="ref-suresoft_hpc_workflow_2022">
    <element-citation>
      <person-group person-group-type="author">
        <name><surname>Peters</surname><given-names>Sören</given-names></name>
        <name><surname>Marcus</surname><given-names>Sven</given-names></name>
      </person-group>
      <article-title>SURESOFT HPC workflow</article-title>
      <source>GitLab repository</source>
      <publisher-name>GitLab</publisher-name>
      <year iso-8601-date="2022">2022</year>
      <uri>https://git.rz.tu-bs.de/soe.peters/suresoft-hpc-workflow</uri>
    </element-citation>
  </ref>
  <ref id="ref-marcus_hpcrocket_2022">
    <element-citation publication-type="book">
      <person-group person-group-type="author">
        <name><surname>Marcus</surname><given-names>Sven</given-names></name>
      </person-group>
      <source>hpc-rocket</source>
      <publisher-name>Zenodo</publisher-name>
      <year iso-8601-date="2022-12">2022</year><month>12</month>
      <uri>https://doi.org/10.5281/zenodo.7469695</uri>
      <pub-id pub-id-type="doi">10.5281/zenodo.7469695</pub-id>
    </element-citation>
  </ref>
  <ref id="ref-ieee754">
    <element-citation publication-type="article-journal">
      <article-title>IEEE standard for binary floating-point arithmetic</article-title>
      <source>ANSI/IEEE Std 754-1985</source>
      <year iso-8601-date="1985">1985</year>
      <volume></volume>
      <issue></issue>
      <pub-id pub-id-type="doi">10.1109/IEEESTD.1985.82928</pub-id>
      <fpage>1</fpage>
      <lpage>20</lpage>
    </element-citation>
  </ref>
  <ref id="ref-fenics">
    <element-citation>
      <article-title>FEniCS</article-title>
      <publisher-name>Website: https://fenicsproject.org/, code repository: https://github.com/FEniCS</publisher-name>
      <year iso-8601-date="2023">2023</year>
    </element-citation>
  </ref>
  <ref id="ref-fenicsbook2012">
    <element-citation publication-type="book">
      <person-group person-group-type="author">
        <name><surname>A. Logg</surname><given-names>G. N. Wells et al</given-names><suffix>K.-A. Mardal</suffix></name>
      </person-group>
      <source>Automated solution of differential equations by the finite element method</source>
      <publisher-name>Springer</publisher-name>
      <year iso-8601-date="2012">2012</year>
      <pub-id pub-id-type="doi">10.1007/978-3-642-23099-8</pub-id>
    </element-citation>
  </ref>
</ref-list>
</back>
</article>
