<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN"
                  "JATS-publishing1.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" dtd-version="1.2" article-type="other">
<front>
<journal-meta>
<journal-id></journal-id>
<journal-title-group>
<journal-title>Journal of Open Source Software</journal-title>
<abbrev-journal-title>JOSS</abbrev-journal-title>
</journal-title-group>
<issn publication-format="electronic">2475-9066</issn>
<publisher>
<publisher-name>Open Journals</publisher-name>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="publisher-id">6233</article-id>
<article-id pub-id-type="doi">10.21105/joss.06233</article-id>
<title-group>
<article-title>Aerobus: a C++ template library for polynomials algebra
over discrete Euclidean domains</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author">
<contrib-id contrib-id-type="orcid">https://orcid.org/0000-0002-6291-3345</contrib-id>
<name>
<surname>Portalez</surname>
<given-names>Regis</given-names>
</name>
<xref ref-type="aff" rid="aff-1"/>
</contrib>
<aff id="aff-1">
<institution-wrap>
<institution>COMUA, France</institution>
</institution-wrap>
</aff>
</contrib-group>
<pub-date date-type="pub" publication-format="electronic" iso-8601-date="2023-10-12">
<day>12</day>
<month>10</month>
<year>2023</year>
</pub-date>
<volume>10</volume>
<issue>105</issue>
<fpage>6233</fpage>
<permissions>
<copyright-statement>Authors of papers retain copyright and release the
work under a Creative Commons Attribution 4.0 International License (CC
BY 4.0)</copyright-statement>
<copyright-year>2025</copyright-year>
<copyright-holder>The article authors</copyright-holder>
<license license-type="open-access" xlink:href="https://creativecommons.org/licenses/by/4.0/">
<license-p>Authors of papers retain copyright and release the work under
a Creative Commons Attribution 4.0 International License (CC BY
4.0)</license-p>
</license>
</permissions>
<kwd-group kwd-group-type="author">
<kwd>Polynomials</kwd>
<kwd>Mathematics</kwd>
<kwd>metaprogramming</kwd>
<kwd>Euclidean Domains</kwd>
<kwd>Rings</kwd>
<kwd>Fields</kwd>
</kwd-group>
</article-meta>
</front>
<body>
<sec id="summary">
  <title>Summary</title>
  <p>C++ comes with high compile-time computations capability, also
  known as metaprogramming with templates. Templates are a
  language-in-the-language which is Turing-complete, meaning we can run
  every computation at compile time instead of runtime, as long as input
  data is known at compile time.</p>
  <p>Using these capabilities, vastly extended with the latest versions
  of the standard, we implemented a library for discrete Euclidean
  domains (commutative and associative), such as
  <inline-formula><alternatives>
  <tex-math><![CDATA[\mathbb{Z}]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>‚Ñ§</mml:mi></mml:math></alternatives></inline-formula>.
  We also provide a way to generate the fraction field of such rings
  (e.g.¬†<inline-formula><alternatives>
  <tex-math><![CDATA[\mathbb{Q}]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>‚Ñö</mml:mi></mml:math></alternatives></inline-formula>).</p>
  <p>We also implemented polynomials over such discrete rings and fields
  (e.g.¬†<inline-formula><alternatives>
  <tex-math><![CDATA[\mathbb{Q}[X]]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>‚Ñö</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>).
  Since polynomials are also a ring, the above implementation gives us
  rational fractions as the field of fractions of polynomials.</p>
  <p>In addition, we expose a way to generate Taylor series of analytic
  functions, known polynomials (e.g.¬†Chebyshev), continued fractions,
  quotient rings and small degree Conway polynomials to define Galois
  finite fields.</p>
  <p><monospace>Aerobus</monospace> was designed to be used in
  high-performance software, teaching purposes or embedded software. It
  compiles with major compilers: <monospace>gcc</monospace>,
  <monospace>clang</monospace> and <monospace>msvc</monospace>. It is
  quite easily configurable and extensible.</p>
</sec>
<sec id="statement-of-need">
  <title>Statement of need</title>
  <p>By implementing general algebra concepts such as discrete rings,
  field of fractions and polynomials, <monospace>Aerobus</monospace> can
  serve multiple purposes, mainly polynomial arithmetic at compile time
  and efficient
  (<xref alt="Comua, 2024" rid="ref-aerobus_benchmarks_2023" ref-type="bibr">Comua,
  2024</xref>) polynomial evaluation, regardless of the coefficients
  <monospace>ring</monospace>.</p>
  <p>The main application we want to express in this paper is the
  automatic (and configurable) generation or Taylor approximation of
  analytic functions such as <monospace>exp</monospace> or
  <monospace>sin</monospace>, by using polynomial arithmetic at compile
  time.</p>
  <p>Some important software, such as
  <monospace>geographiclib</monospace>
  (<xref alt="Karney, 2013" rid="ref-karney2013algorithms" ref-type="bibr">Karney,
  2013</xref>) evaluate polynomials with a simple loop, expected to be
  unrolled by compiler. It works really well (on arithmetic types such
  as <monospace>double</monospace>) but does not provide a way to
  manipulate polynomials (addition, multiplication, division, modulus)
  automatically where <monospace>aerobus</monospace> does at no runtime
  cost.</p>
  <p>Notable libraries such as
  <ext-link ext-link-type="uri" xlink:href="https://live.boost.org/doc/libs/1_86_0/libs/math/doc/html/math_toolkit/polynomials.html">boost</ext-link>
  provide polynomial arithmetic, but arithmetic is done at runtime with
  memory allocations while <monospace>aerobus</monospace> does it at
  compile time.</p>
  <p>Common analytic functions are usually exposed by the standard
  library (<monospace>&lt;cmath&gt;</monospace>) with high (guaranteed)
  precision. However, in high-performance computing, when not compiled
  with <monospace>-Ofast</monospace>, evaluating
  <monospace>std::exp</monospace> has several flaws:</p>
  <list list-type="bullet">
    <list-item>
      <p>It leads to a <monospace>syscall</monospace> which is very
      expensive;</p>
    </list-item>
    <list-item>
      <p>It doesn‚Äôt leverage vector units (AVX, AVX2, AVX512 or
      equivalent in non-intel hardware);</p>
    </list-item>
    <list-item>
      <p>Results are hardware dependent.</p>
    </list-item>
  </list>
  <p>Hardware vendors provide high-performance libraries such as
  (<xref alt="Wang et al., 2014" rid="ref-wang2014intel" ref-type="bibr">Wang
  et al., 2014</xref>), but implementation is often hidden and not
  extensible.</p>
  <p>Some others can provide vectorized functions, such as
  (<xref alt="Wang et al., 2014" rid="ref-wang2014intel" ref-type="bibr">Wang
  et al., 2014</xref>) does. But libraries like VML are highly tight to
  one architecture by their use of intrinsic or inline assembly. In
  addition, they only provide a restricted list of math functions and do
  not expose capabilities to generate high-performance versions of other
  functions such as <monospace>arctanh</monospace>. It is the same for
  the standard library compiled with <monospace>-Ofast</monospace>: it
  generates a vectorized version of some functions (such as
  <monospace>exp</monospace>) but with no control of precision and no
  extensibility. In addition, <monospace>fast-math</monospace> versions
  are compiler and architecture dependent, which can be a problem for
  results reproducibility.</p>
  <p><monospace>Aerobus</monospace> provides automatic generation of
  such functions, in a hardware-independent way, as tested on x86 and
  CUDA platforms. In addition, <monospace>Aerobus</monospace> provides a
  way to control the precision of the generated function by changing the
  degree of Taylor expansion, which can‚Äôt be used in competing libraries
  without reimplementing the whole function or changing the array of
  coefficients.</p>
  <p><monospace>Aerobus</monospace> does not provide optimal
  approximation polynomials the way
  (<xref alt="chevillard2010sollya?" rid="ref-chevillard2010sollya" ref-type="bibr"><bold>chevillard2010sollya?</bold></xref>)
  does. However, <monospace>Sollya</monospace> could be used beforehand
  to feed <monospace>aerobus</monospace> with appropriate coefficients.
  <monospace>Aerobus</monospace> does not provide floating point
  manipulations (domain normalization) to extend domain of
  approximation, like it is done in standard library.</p>
</sec>
<sec id="mathematic-definitions">
  <title>Mathematic definitions</title>
  <p>For the sake of completeness, we give basic definitions of the
  mathematical concepts which the library deals with. However, readers
  desiring complete and rigorous definitions of the concepts explained
  below should refer to a mathematical book on algebra, such as
  (<xref alt="Lang, 2012" rid="ref-lang2012algebra" ref-type="bibr">Lang,
  2012</xref>) or
  (<xref alt="Bourbaki, 2013" rid="ref-bourbaki2013algebra" ref-type="bibr">Bourbaki,
  2013</xref>).</p>
  <p>A <monospace>ring</monospace> <inline-formula><alternatives>
  <tex-math><![CDATA[\mathbb{A}]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>ùî∏</mml:mi></mml:math></alternatives></inline-formula>
  is a nonempty set with two internal laws, addition and multiplication.
  There is a neutral element for both, zero and one. Addition is
  commutative and associative and every element
  <inline-formula><alternatives>
  <tex-math><![CDATA[x]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>x</mml:mi></mml:math></alternatives></inline-formula>
  has an inverse <inline-formula><alternatives>
  <tex-math><![CDATA[-x]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>‚àí</mml:mi><mml:mi>x</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>.
  Multiplication is commutative, associative and distributive over
  addition, meaning that <inline-formula><alternatives>
  <tex-math><![CDATA[a(b+c) = ab+ac]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>a</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>b</mml:mi><mml:mo>+</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>a</mml:mi><mml:mi>b</mml:mi><mml:mo>+</mml:mo><mml:mi>a</mml:mi><mml:mi>c</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
  for every <inline-formula><alternatives>
  <tex-math><![CDATA[a, b, c]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo>,</mml:mo><mml:mi>c</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
  element. We call it <monospace>discrete</monospace> if it is
  countable.</p>
  <p>In a <monospace>field</monospace>, in addition to previous
  properties, each element (except zero), has an inverse for
  multiplication.</p>
  <p>A <monospace>integral domain</monospace> is a ring with one
  additional property. For every element <inline-formula><alternatives>
  <tex-math><![CDATA[a, b, c]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo>,</mml:mo><mml:mi>c</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
  such as <inline-formula><alternatives>
  <tex-math><![CDATA[ab = ac]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>a</mml:mi><mml:mi>b</mml:mi><mml:mo>=</mml:mo><mml:mi>a</mml:mi><mml:mi>c</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>,
  then either <inline-formula><alternatives>
  <tex-math><![CDATA[a = 0]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>a</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></alternatives></inline-formula>
  or <inline-formula><alternatives>
  <tex-math><![CDATA[b = c]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>b</mml:mi><mml:mo>=</mml:mo><mml:mi>c</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>.
  Such a ring is not always a field, such as
  <inline-formula><alternatives>
  <tex-math><![CDATA[\mathbb{Z}]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>‚Ñ§</mml:mi></mml:math></alternatives></inline-formula>
  shows it.</p>
  <p>A <monospace>euclidean domain</monospace> is an integral domain
  that can be endowed with a euclidean division.</p>
  <p>For such a euclidean domain, we can build two important
  structures:</p>
  <sec id="polynomials-mathbbax">
    <title>Polynomials <inline-formula><alternatives>
    <tex-math><![CDATA[\mathbb{A}[X]]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>ùî∏</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula></title>
    <p>Polynomials over <inline-formula><alternatives>
    <tex-math><![CDATA[\mathbb{A}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>ùî∏</mml:mi></mml:math></alternatives></inline-formula>
    is the free module generated by a base noted
    <inline-formula><alternatives>
    <tex-math><![CDATA[(X^k)_{k\in\mathbb{N}}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msup><mml:mi>X</mml:mi><mml:mi>k</mml:mi></mml:msup><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>‚àà</mml:mo><mml:mi>‚Ñï</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>.
    Practically speaking, it‚Äôs the set of :</p>
    <p><disp-formula><alternatives>
    <tex-math><![CDATA[a_0 + a_1X + \ldots + a_nX^n]]></tex-math>
    <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mi>X</mml:mi><mml:mo>+</mml:mo><mml:mi>‚Ä¶</mml:mi><mml:mo>+</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:msup><mml:mi>X</mml:mi><mml:mi>n</mml:mi></mml:msup></mml:mrow></mml:math></alternatives></disp-formula></p>
    <p>where <inline-formula><alternatives>
    <tex-math><![CDATA[a_n \neq 0]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo>‚â†</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></alternatives></inline-formula>
    if <inline-formula><alternatives>
    <tex-math><![CDATA[n \neq 0]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>n</mml:mi><mml:mo>‚â†</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></alternatives></inline-formula>.</p>
    <p><inline-formula><alternatives>
    <tex-math><![CDATA[(a_i)]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>,
    the coefficients, are elements of <inline-formula><alternatives>
    <tex-math><![CDATA[\mathbb{A}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>ùî∏</mml:mi></mml:math></alternatives></inline-formula>.
    The theory states that if <inline-formula><alternatives>
    <tex-math><![CDATA[\mathbb{A}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>ùî∏</mml:mi></mml:math></alternatives></inline-formula>
    is a field, then <inline-formula><alternatives>
    <tex-math><![CDATA[\mathbb{A}[X]]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>ùî∏</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
    is Euclidean. That means notions like division of greatest common
    divisor (gcd) have a meaning, yielding an arithmetic of
    polynomials.</p>
  </sec>
  <sec id="field-of-fractions">
    <title>Field of fractions</title>
    <p>If <inline-formula><alternatives>
    <tex-math><![CDATA[\mathbb{A}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>ùî∏</mml:mi></mml:math></alternatives></inline-formula>
    is Euclidean, we can build its field of fractions: the smallest
    field containing <inline-formula><alternatives>
    <tex-math><![CDATA[\mathbb{A}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>ùî∏</mml:mi></mml:math></alternatives></inline-formula>.
    We construct it as congruences classes of
    <inline-formula><alternatives>
    <tex-math><![CDATA[\mathbb{A}\times \mathbb{A}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>ùî∏</mml:mi><mml:mo>√ó</mml:mo><mml:mi>ùî∏</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
    for the relation <inline-formula><alternatives>
    <tex-math><![CDATA[(p,q) \sim (pp, qq)\  \mathrm{iff}\ p*qq = q*pp]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>‚àº</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>p</mml:mi><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi><mml:mi>q</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mspace width="0.222em"></mml:mspace><mml:mrow><mml:mi mathvariant="normal">i</mml:mi><mml:mi mathvariant="normal">f</mml:mi><mml:mi mathvariant="normal">f</mml:mi></mml:mrow><mml:mspace width="0.222em"></mml:mspace><mml:mi>p</mml:mi><mml:mo>*</mml:mo><mml:mi>q</mml:mi><mml:mi>q</mml:mi><mml:mo>=</mml:mo><mml:mi>q</mml:mi><mml:mo>*</mml:mo><mml:mi>p</mml:mi><mml:mi>p</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>.
    Basic algebra shows that this is a field (every element has an
    inverse). The canonical example is <inline-formula><alternatives>
    <tex-math><![CDATA[\mathbb{Q}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>‚Ñö</mml:mi></mml:math></alternatives></inline-formula>,
    the set of rational numbers.</p>
    <p>Given polynomials over a field form an Euclidean ring, we can do
    the same construction and get rational fractions
    <inline-formula><alternatives>
    <tex-math><![CDATA[P(x) / Q(X)]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>P</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mi>/</mml:mi><mml:mi>Q</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
    where <inline-formula><alternatives>
    <tex-math><![CDATA[P]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>P</mml:mi></mml:math></alternatives></inline-formula>
    and <inline-formula><alternatives>
    <tex-math><![CDATA[Q]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>Q</mml:mi></mml:math></alternatives></inline-formula>
    are polynomials.</p>
  </sec>
  <sec id="quotient-rings">
    <title>Quotient rings</title>
    <p>In an Euclidean domain <inline-formula><alternatives>
    <tex-math><![CDATA[\mathbb{A}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>ùî∏</mml:mi></mml:math></alternatives></inline-formula>,
    such as <inline-formula><alternatives>
    <tex-math><![CDATA[\mathbb{Z}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>‚Ñ§</mml:mi></mml:math></alternatives></inline-formula>
    or <inline-formula><alternatives>
    <tex-math><![CDATA[\mathbb{A}[X]]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>ùî∏</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>,
    we can define the quotient ring of <inline-formula><alternatives>
    <tex-math><![CDATA[\mathbb{A}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>ùî∏</mml:mi></mml:math></alternatives></inline-formula>
    by a principal ideal <inline-formula><alternatives>
    <tex-math><![CDATA[I]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>I</mml:mi></mml:math></alternatives></inline-formula>.
    Given that <inline-formula><alternatives>
    <tex-math><![CDATA[I]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>I</mml:mi></mml:math></alternatives></inline-formula>
    is principal, it is generated by an element
    <inline-formula><alternatives>
    <tex-math><![CDATA[X]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>X</mml:mi></mml:math></alternatives></inline-formula>
    and the quotient ring is the ring of rests modulo
    <inline-formula><alternatives>
    <tex-math><![CDATA[X]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>X</mml:mi></mml:math></alternatives></inline-formula>.
    When <inline-formula><alternatives>
    <tex-math><![CDATA[X]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>X</mml:mi></mml:math></alternatives></inline-formula>
    is <monospace>prime</monospace> (meaning it has no smallest factors
    in <inline-formula><alternatives>
    <tex-math><![CDATA[\mathbb{A}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>ùî∏</mml:mi></mml:math></alternatives></inline-formula>),
    the quotient ring <inline-formula><alternatives>
    <tex-math><![CDATA[\mathbb{A}/I]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>ùî∏</mml:mi><mml:mi>/</mml:mi><mml:mi>I</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
    is a field.</p>
    <p>Applied on <inline-formula><alternatives>
    <tex-math><![CDATA[\mathbb{Z}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>‚Ñ§</mml:mi></mml:math></alternatives></inline-formula>,
    that operation gives us modular arithmetic and all finite fields of
    cardinal <inline-formula><alternatives>
    <tex-math><![CDATA[q]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>q</mml:mi></mml:math></alternatives></inline-formula>
    where <inline-formula><alternatives>
    <tex-math><![CDATA[q]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>q</mml:mi></mml:math></alternatives></inline-formula>
    is a prime number (up to isomorphism). These fields are usually
    named <inline-formula><alternatives>
    <tex-math><![CDATA[\mathbb{Z}/p\mathbb{Z}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>‚Ñ§</mml:mi><mml:mi>/</mml:mi><mml:mi>p</mml:mi><mml:mi>‚Ñ§</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>.
    Applied on <inline-formula><alternatives>
    <tex-math><![CDATA[\mathbb{Z}/p\mathbb{Z}[X]]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>‚Ñ§</mml:mi><mml:mi>/</mml:mi><mml:mi>p</mml:mi><mml:mi>‚Ñ§</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>,
    it gives finite Galois fields, meaning all finite fields of cardinal
    <inline-formula><alternatives>
    <tex-math><![CDATA[p^n]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msup><mml:mi>p</mml:mi><mml:mi>n</mml:mi></mml:msup></mml:math></alternatives></inline-formula>
    where <inline-formula><alternatives>
    <tex-math><![CDATA[p]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>p</mml:mi></mml:math></alternatives></inline-formula>
    is prime (see
    (<xref alt="√âvariste, 1846" rid="ref-evariste1846memoire" ref-type="bibr">√âvariste,
    1846</xref>)).</p>
  </sec>
</sec>
<sec id="software">
  <title>Software</title>
  <p>All types of Aerobus have the same structure.</p>
  <p>An englobing type describes an algebraic structure. It has a nested
  type <monospace>val</monospace> which is always a template model
  describing elements of the set.</p>
  <p>This is because we want to operate on types more than on values.
  This allows generic implementation, for example of
  <monospace>gcd</monospace> (see below) without specifying what are the
  values.</p>
  <sec id="concepts">
    <title>Concepts</title>
    <p>The library exposes three main
    <monospace>concepts</monospace>:</p>
    <code language="c++">template &lt;typename R&gt;
concept IsRing; // see in code or documentation

template &lt;typename R&gt;
concept IsEuclideanDomain; // see in code or documentation

template&lt;typename R&gt;
concept IsField; // see in code or documentation</code>
    <p>which express the algebraic objects described above. Then, as
    long as a type satisfies the
    <monospace>IsEuclideanDomain</monospace> concept, we can calculate
    the greatest common divisor of two values of this type using
    Euclid‚Äôs algorithm
    (<xref alt="Heath &amp; others, 1956" rid="ref-heath1956thirteen" ref-type="bibr">Heath
    &amp; others, 1956</xref>). As stated above, this algorithm operates
    on types instead of values and does not depend on the Ring, making
    it possible for users to implement another kind of discrete
    Euclidean domain without worrying about that kind of algorithm.</p>
    <p>The same is done for the field of fractions: implementation does
    not rely on the nature of the underlying Euclidean domain but rather
    on its structure. It‚Äôs automatically done by templates, as long as
    Ring satisfies the appropriate concept.</p>
    <p>Doing that way, <inline-formula><alternatives>
    <tex-math><![CDATA[\mathbb{Q}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>‚Ñö</mml:mi></mml:math></alternatives></inline-formula>
    has the same implementation as rational fractions of polynomials.
    Users could also get the field of fractions of any ring of their
    convenience, as long as they implement the required concepts.</p>
  </sec>
  <sec id="native-types">
    <title>Native types</title>
    <p><monospace>Aerobus</monospace> exposes several pre-implemented
    types, as they are common and necessary to do actual
    computations:</p>
    <list list-type="bullet">
      <list-item>
        <p><monospace>i32</monospace> and <monospace>i64</monospace>
        (<inline-formula><alternatives>
        <tex-math><![CDATA[\mathbb{Z}]]></tex-math>
        <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>‚Ñ§</mml:mi></mml:math></alternatives></inline-formula>
        seen as 32 bits or 64 bits integers)</p>
      </list-item>
      <list-item>
        <p><monospace>zpz</monospace> the quotient ring
        <inline-formula><alternatives>
        <tex-math><![CDATA[\mathbb{Z}/p\mathbb{Z}]]></tex-math>
        <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>‚Ñ§</mml:mi><mml:mi>/</mml:mi><mml:mi>p</mml:mi><mml:mi>‚Ñ§</mml:mi></mml:mrow></mml:math></alternatives></inline-formula></p>
      </list-item>
      <list-item>
        <p><monospace>polynomial&lt;T&gt;</monospace> where T is a
        ring</p>
      </list-item>
      <list-item>
        <p><monospace>FractionField&lt;T&gt;</monospace> where T is an
        Euclidean domain</p>
      </list-item>
    </list>
    <p>Polynomial exposes an evaluation function, which automatically
    generates Horner development and unrolls the loop by generating it
    at compile time. See
    (<xref alt="Horner, 1815" rid="ref-horner1815new" ref-type="bibr">Horner,
    1815</xref>) or
    (<xref alt="Knuth, 2014" rid="ref-knuth2014art" ref-type="bibr">Knuth,
    2014</xref>) for further developments of this method.</p>
    <p>Given a polynomial</p>
    <p><disp-formula><alternatives>
    <tex-math><![CDATA[P = \sum_{i=0}^{i ‚â§ n}a_iX^i = a_0 + a_1X + ... + a_nX^n]]></tex-math>
    <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>P</mml:mi><mml:mo>=</mml:mo><mml:munderover><mml:mo>‚àë</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>‚â§</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:munderover><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msup><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msup><mml:mo>=</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mi>X</mml:mi><mml:mo>+</mml:mo><mml:mi>.</mml:mi><mml:mi>.</mml:mi><mml:mi>.</mml:mi><mml:mo>+</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:msup><mml:mi>X</mml:mi><mml:mi>n</mml:mi></mml:msup></mml:mrow></mml:math></alternatives></disp-formula></p>
    <p>we can evaluate it by rewriting it this way:</p>
    <p><disp-formula><alternatives>
    <tex-math><![CDATA[P(x) = a_0 + X (a_1 + X (a_2 + X(... + X(a_{n-1} + X an))))]]></tex-math>
    <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>P</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:mi>X</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:mi>X</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:mi>X</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>.</mml:mi><mml:mi>.</mml:mi><mml:mi>.</mml:mi><mml:mo>+</mml:mo><mml:mi>X</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mi>n</mml:mi><mml:mo>‚àí</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi>X</mml:mi><mml:mi>a</mml:mi><mml:mi>n</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></disp-formula></p>
    <p>which is automaticcaly done by <monospace>aerobus</monospace>
    using the <monospace>polynomial::val::eval</monospace> function.</p>
    <p>This evaluation function is <monospace>constexpr</monospace> and
    therefore will be completely computed at compile time when called on
    a constant.</p>
    <p>Polynomials also expose Compensated Horner scheme like in
    (<xref alt="Graillat et al., 2006" rid="ref-graillat2006compensated" ref-type="bibr">Graillat
    et al., 2006</xref>), to gain extra precision when evaluating
    polynomials close to its roots.</p>
    <p>The library also provides built-in integers and functions, such
    as Bernouilli numbers, factorials or other utilities.</p>
    <p>Some well known Taylor series, such as <monospace>exp</monospace>
    or <monospace>acosh</monospace> come preimplemented.</p>
    <p>The library comes with a type designed to help the users
    implement other Taylor series. If users provide a type
    <monospace>mycoeff</monospace> satisfying the appropriate template
    (depending on the <monospace>Ring</monospace> of coefficients and
    degree), the corresponding Taylor expansion can be built
    automatically as a polynomial over this <monospace>Ring</monospace>
    and then, evaluated at some value in a native arithmetic type (such
    as <monospace>double</monospace>).</p>
  </sec>
</sec>
<sec id="misc">
  <title>Misc</title>
  <sec id="continued-fractions">
    <title>Continued Fractions</title>
    <p><monospace>Aerobus</monospace> provides
    <ext-link ext-link-type="uri" xlink:href="https://en.wikipedia.org/wiki/Continued_fraction">continued
    fractions</ext-link>, seen as an example of what is possible when
    you have a proper type representation of the field of fractions. One
    can get a rational approximation of numbers using their known
    representation, given by the On-Line Encyclopedia of Integer
    Sequences
    (<xref alt="On-Line Encyclopedia of Integer Sequences, n.d." rid="ref-OEIS" ref-type="bibr"><italic>On-Line
    Encyclopedia of Integer Sequences</italic>, n.d.</xref>). Some
    useful math constants, such as <inline-formula><alternatives>
    <tex-math><![CDATA[\pi]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>œÄ</mml:mi></mml:math></alternatives></inline-formula>
    or <inline-formula><alternatives>
    <tex-math><![CDATA[e]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>e</mml:mi></mml:math></alternatives></inline-formula>
    are provided preimplemented, from which user can have the
    corresponding rational number by using (for example)
    <monospace>PI_fraction::type</monospace> and a computation with
    <monospace>PI_fraction::val</monospace>.</p>
  </sec>
  <sec id="known-polynomials">
    <title>Known polynomials</title>
    <p>There existe many orthogonal polynomial bases used in various
    domains, from number theory to quantum physics.
    <monospace>Aerobus</monospace> provide predefined implementation for
    some of them (Laguerre, Hermite, Bernstein, Bessel, ‚Ä¶). These
    polynomials have integers coefficients by default, but can be
    defined (specialized) with coefficients in any
    <monospace>Ring</monospace> (such as <inline-formula><alternatives>
    <tex-math><![CDATA[\mathbb{Z}/2\mathbb{Z}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>‚Ñ§</mml:mi><mml:mi>/</mml:mi><mml:mn>2</mml:mn><mml:mi>‚Ñ§</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>).</p>
  </sec>
  <sec id="quotient-rings-and-galois-fields">
    <title>Quotient rings and Galois fields</title>
    <p>If some type meets the <monospace>IsRing</monospace> concept
    requirement, Aerobus can generate its quotient ring by a principal
    ideal generated by some element <monospace>X</monospace>.</p>
    <p>We can then define finite fields such as
    <inline-formula><alternatives>
    <tex-math><![CDATA[\mathbb{Z}/p\mathbb{Z}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>‚Ñ§</mml:mi><mml:mi>/</mml:mi><mml:mi>p</mml:mi><mml:mi>‚Ñ§</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
    by writing
    <monospace>using Z2Z = Quotient&lt;i32, i32::inject_constant_t&lt;2&gt;&gt;;</monospace>.</p>
    <p>In <inline-formula><alternatives>
    <tex-math><![CDATA[\mathbb{Z}/p\mathbb{Z}[X]]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>‚Ñ§</mml:mi><mml:mi>/</mml:mi><mml:mi>p</mml:mi><mml:mi>‚Ñ§</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>,
    there are special irreducible polynomials named Conway polynomials
    (<xref alt="Holt et al., 2005" rid="ref-holt2005handbook" ref-type="bibr">Holt
    et al., 2005</xref>), used to build larger finite fields.
    <monospace>Aerobus</monospace> exposes Conway polynomials for
    <inline-formula><alternatives>
    <tex-math><![CDATA[p]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>p</mml:mi></mml:math></alternatives></inline-formula>
    smaller than 1000 and degrees smaller than 20.</p>
    <p>To speed up compilation for users who don‚Äôt use them, they are
    hidden behing the flag
    <monospace>AEROBUS_CONWAY_IMPORTS</monospace>. If this is defined,
    it‚Äôs possible define <inline-formula><alternatives>
    <tex-math><![CDATA[\mathrm{GF}(p, n) = \mathbb{F}_{p^n}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mrow><mml:mi mathvariant="normal">G</mml:mi><mml:mi mathvariant="normal">F</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mi>ùîΩ</mml:mi><mml:msup><mml:mi>p</mml:mi><mml:mi>n</mml:mi></mml:msup></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>.</p>
    <p>For instance, we can compute <inline-formula><alternatives>
    <tex-math><![CDATA[\mathbb{F}_4 = \mathrm{GF}(2, 2)]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>ùîΩ</mml:mi><mml:mn>4</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mi mathvariant="normal">G</mml:mi><mml:mi mathvariant="normal">F</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
    by writing:</p>
    <code language="c++">using F2 = zpz&lt;2&gt;;
using PF2 = polynomial&lt;F2&gt;;
using F4 = Quotient&lt;PF2, ConwayPolynomial&lt;2, 2&gt;::type&gt;;</code>
    <p>Multiplication and addition tables are checked to be those of
    <inline-formula><alternatives>
    <tex-math><![CDATA[\mathbb{F}_4]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>ùîΩ</mml:mi><mml:mn>4</mml:mn></mml:msub></mml:math></alternatives></inline-formula>.</p>
    <p>Surprisingly, compilation time is not significantly higher when
    we include <monospace>conwaypolynomials.h</monospace>. However, we
    chose to make it optional.</p>
  </sec>
</sec>
<sec id="acknowledgments">
  <title>Acknowledgments</title>
  <p>Many thanks to my math teachers, A. Soyeur and M. Gonnord. I also
  acknowledge indirect contributions from F. Duguet, who showed me the
  way. I wish also to thank Miss Chlo√© Gence, who gave me the name of
  the library.</p>
</sec>
</body>
<back>
<ref-list>
  <title>Reference</title>
  <ref id="ref-wang2014intel">
    <element-citation publication-type="chapter">
      <person-group person-group-type="author">
        <name><surname>Wang</surname><given-names>Endong</given-names></name>
        <name><surname>Zhang</surname><given-names>Qing</given-names></name>
        <name><surname>Shen</surname><given-names>Bo</given-names></name>
        <name><surname>Zhang</surname><given-names>Guangyong</given-names></name>
        <name><surname>Lu</surname><given-names>Xiaowei</given-names></name>
        <name><surname>Wu</surname><given-names>Qing</given-names></name>
        <name><surname>Wang</surname><given-names>Yajuan</given-names></name>
      </person-group>
      <article-title>Intel math kernel library</article-title>
      <source>High-performance computing on the intel xeon phi: How to fully exploit MIC architectures</source>
      <publisher-name>Springer International Publishing</publisher-name>
      <publisher-loc>Cham</publisher-loc>
      <year iso-8601-date="2014">2014</year>
      <isbn>978-3-319-06486-4</isbn>
      <uri>https://doi.org/10.1007/978-3-319-06486-4_7</uri>
      <pub-id pub-id-type="doi">10.1007/978-3-319-06486-4_7</pub-id>
      <fpage>167</fpage>
      <lpage>188</lpage>
    </element-citation>
  </ref>
  <ref id="ref-OEIS">
    <element-citation>
      <article-title>On-line encyclopedia of integer sequences</article-title>
      <publisher-name>https://oeis.org/</publisher-name>
    </element-citation>
  </ref>
  <ref id="ref-lang2012algebra">
    <element-citation publication-type="book">
      <person-group person-group-type="author">
        <name><surname>Lang</surname><given-names>Serge</given-names></name>
      </person-group>
      <source>Algebra</source>
      <publisher-name>Springer Science &amp; Business Media</publisher-name>
      <year iso-8601-date="2012">2012</year>
      <volume>211</volume>
      <pub-id pub-id-type="doi">10.1007/978-1-4613-0041-0</pub-id>
    </element-citation>
  </ref>
  <ref id="ref-bourbaki2013algebra">
    <element-citation publication-type="book">
      <person-group person-group-type="author">
        <name><surname>Bourbaki</surname><given-names>Nicolas</given-names></name>
      </person-group>
      <source>Algebra II: Chapters 4-7</source>
      <publisher-name>Springer Science &amp; Business Media</publisher-name>
      <year iso-8601-date="2013">2013</year>
      <pub-id pub-id-type="doi">10.1007/978-3-642-61698-3</pub-id>
    </element-citation>
  </ref>
  <ref id="ref-evariste1846memoire">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>√âvariste</surname><given-names>Galois</given-names></name>
      </person-group>
      <article-title>M√©moire sur les conditions de r√©solubilit√© des √©quations par radicaux</article-title>
      <source>Journal de math√©matiques pures et appliqu√©es, Ser</source>
      <year iso-8601-date="1846">1846</year>
      <volume>1</volume>
      <issue>111846</issue>
      <fpage>417</fpage>
      <lpage>433</lpage>
    </element-citation>
  </ref>
  <ref id="ref-holt2005handbook">
    <element-citation publication-type="book">
      <person-group person-group-type="author">
        <name><surname>Holt</surname><given-names>Derek F</given-names></name>
        <name><surname>Eick</surname><given-names>Bettina</given-names></name>
        <name><surname>O‚ÄôBrien</surname><given-names>Eamonn A</given-names></name>
      </person-group>
      <source>Handbook of computational group theory</source>
      <publisher-name>CRC Press</publisher-name>
      <year iso-8601-date="2005">2005</year>
      <pub-id pub-id-type="doi">10.1201/9781420035216</pub-id>
    </element-citation>
  </ref>
  <ref id="ref-heath1956thirteen">
    <element-citation publication-type="book">
      <person-group person-group-type="author">
        <name><surname>Heath</surname><given-names>Thomas Little</given-names></name>
        <name><surname>others</surname></name>
      </person-group>
      <source>The thirteen books of euclid‚Äôs elements</source>
      <publisher-name>Courier Corporation</publisher-name>
      <year iso-8601-date="1956">1956</year>
    </element-citation>
  </ref>
  <ref id="ref-horner1815new">
    <element-citation publication-type="paper-conference">
      <person-group person-group-type="author">
        <name><surname>Horner</surname><given-names>WG</given-names></name>
      </person-group>
      <article-title>A new method of solving numerical equations of all orders, by continuous approximation.</article-title>
      <source>Abstracts of the papers printed in the philosophical transactions of the royal society of london</source>
      <publisher-name>JSTOR</publisher-name>
      <year iso-8601-date="1815">1815</year>
      <volume>2</volume>
      <fpage>117</fpage>
      <lpage>117</lpage>
    </element-citation>
  </ref>
  <ref id="ref-knuth2014art">
    <element-citation publication-type="book">
      <person-group person-group-type="author">
        <name><surname>Knuth</surname><given-names>Donald E</given-names></name>
      </person-group>
      <source>Art of computer programming, volume 2: Seminumerical algorithms</source>
      <publisher-name>Addison-Wesley Professional</publisher-name>
      <year iso-8601-date="2014">2014</year>
      <pub-id pub-id-type="doi">10.1137/1012065</pub-id>
    </element-citation>
  </ref>
  <ref id="ref-karney2013algorithms">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Karney</surname><given-names>Charles FF</given-names></name>
      </person-group>
      <article-title>Algorithms for geodesics</article-title>
      <source>Journal of Geodesy</source>
      <publisher-name>Springer</publisher-name>
      <year iso-8601-date="2013">2013</year>
      <volume>87</volume>
      <pub-id pub-id-type="doi">10.1007/s00190-012-0578-z</pub-id>
      <fpage>43</fpage>
      <lpage>55</lpage>
    </element-citation>
  </ref>
  <ref id="ref-graillat2006compensated">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Graillat</surname><given-names>Stef</given-names></name>
        <name><surname>Langlois</surname><given-names>Philippe</given-names></name>
        <name><surname>Louvet</surname><given-names>Nicolas</given-names></name>
      </person-group>
      <article-title>Compensated horner scheme</article-title>
      <source>Algebraic and Numerical Algorithms and</source>
      <year iso-8601-date="2006">2006</year>
    </element-citation>
  </ref>
  <ref id="ref-aerobus_benchmarks_2023">
    <element-citation>
      <person-group person-group-type="author">
        <name><surname>Comua</surname></name>
      </person-group>
      <article-title>Aerobus benchmarks</article-title>
      <publisher-name>Figshare</publisher-name>
      <year iso-8601-date="2024">2024</year>
      <uri>https://figshare.com/articles/dataset/Aerobus_benchmarks/27222777?file=49774845</uri>
    </element-citation>
  </ref>
</ref-list>
</back>
</article>
