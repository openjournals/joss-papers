<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN"
                  "JATS-publishing1.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" dtd-version="1.2" article-type="other">
<front>
<journal-meta>
<journal-id></journal-id>
<journal-title-group>
<journal-title>Journal of Open Source Software</journal-title>
<abbrev-journal-title>JOSS</abbrev-journal-title>
</journal-title-group>
<issn publication-format="electronic">2475-9066</issn>
<publisher>
<publisher-name>Open Journals</publisher-name>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="publisher-id">4566</article-id>
<article-id pub-id-type="doi">10.21105/joss.04566</article-id>
<title-group>
<article-title>PyMSM: Python package for Competing Risks and Multi-State
models for Survival Data</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author">
<contrib-id contrib-id-type="orcid">0000-0002-5613-8004</contrib-id>
<name>
<surname>Rossman</surname>
<given-names>Hagai</given-names>
</name>
<xref ref-type="aff" rid="aff-1"/>
<xref ref-type="aff" rid="aff-2"/>
</contrib>
<contrib contrib-type="author">
<contrib-id contrib-id-type="orcid">0000-0002-1841-7918</contrib-id>
<name>
<surname>Keshet</surname>
<given-names>Ayya</given-names>
</name>
<xref ref-type="aff" rid="aff-1"/>
<xref ref-type="aff" rid="aff-2"/>
</contrib>
<contrib contrib-type="author" corresp="yes">
<contrib-id contrib-id-type="orcid">0000-0002-1577-6624</contrib-id>
<name>
<surname>Gorfine</surname>
<given-names>Malka</given-names>
</name>
<xref ref-type="aff" rid="aff-3"/>
<xref ref-type="corresp" rid="cor-1"><sup>*</sup></xref>
</contrib>
<aff id="aff-1">
<institution-wrap>
<institution>Department of Computer Science and Applied Mathematics,
Weizmann Institute of Science, Rehovot, Israel</institution>
</institution-wrap>
</aff>
<aff id="aff-2">
<institution-wrap>
<institution>Department of Molecular Cell Biology, Weizmann Institute of
Science, Rehovot, Israel</institution>
</institution-wrap>
</aff>
<aff id="aff-3">
<institution-wrap>
<institution>Department of Statistics and Operations Research, Tel Aviv
University, Tel Aviv, Israel</institution>
</institution-wrap>
</aff>
</contrib-group>
<author-notes>
<corresp id="cor-1">* E-mail: <email></email></corresp>
</author-notes>
<pub-date date-type="pub" publication-format="electronic" iso-8601-date="2022-04-10">
<day>10</day>
<month>4</month>
<year>2022</year>
</pub-date>
<volume>7</volume>
<issue>78</issue>
<fpage>4566</fpage>
<permissions>
<copyright-statement>Authors of papers retain copyright and release the
work under a Creative Commons Attribution 4.0 International License (CC
BY 4.0)</copyright-statement>
<copyright-year>2022</copyright-year>
<copyright-holder>The article authors</copyright-holder>
<license license-type="open-access" xlink:href="https://creativecommons.org/licenses/by/4.0/">
<license-p>Authors of papers retain copyright and release the work under
a Creative Commons Attribution 4.0 International License (CC BY
4.0)</license-p>
</license>
</permissions>
<kwd-group kwd-group-type="author">
<kwd>Python</kwd>
<kwd>multistate models</kwd>
<kwd>survival analysis</kwd>
<kwd>competing risks</kwd>
</kwd-group>
</article-meta>
</front>
<body>
<sec id="summary">
  <title>Summary</title>
  <p>Multi-state survival data are common, and can be used to describe
  trajectories in diverse applications such as a patient’s health
  progression through disease states, pickups during the workday of a
  taxi driver, or a website browsing trajectory to name a few. When
  faced with such data, a researcher or clinician might seek to
  characterize the possible transitions between states, their occurrence
  probabilities, or to predict the trajectory of future observations
  given various baseline and time-varying individual covariates
  (features). By fitting a multi-state model, we can learn the hazard
  for each specific transition, which would later be used to predict
  future paths. Predicting paths can be used at a single individual
  level, for example predicting how long a cancer patient will be
  relapse-free given his current health status, or at what probability
  will a patient end a trajectory at any of the possible states. At the
  population level paths predictions can be used, for example, to
  estimate how many patients which arrive at the emergency-room will
  need to be admitted, given their covariates. Moreover, their expected
  hospitalization duration can also be inferred, and provide planners
  with anticipated patients load.</p>
</sec>
<sec id="statement-of-need">
  <title>Statement of need</title>
  <p><monospace>PyMSM</monospace> is a Python package for fitting
  multi-state models, with a simple API which allows user-defined
  models, predictions at a single or population sample level, and
  various statistical summaries and figures. Features of this software
  include:</p>
  <list list-type="bullet">
    <list-item>
      <p>Fitting competing risks and multi-state models based on various
      types of survival analysis (time-to-event) such as Cox
      proportional hazards models or machine learning models, while
      taking into account right censoring, competing events, recurrent
      events, left truncation, and time-dependent covariates. The number
      of states in the model, and the possible transitions between them
      will be determined by the user, as well as the number of competing
      risks when fitting a competing risks model.</p>
    </list-item>
    <list-item>
      <p>Running Monte-Carlo simulations (in parallel computation) for
      paths emitted by the trained model and extracting various summary
      statistics and plots.</p>
    </list-item>
    <list-item>
      <p>Loading or configuring a pre-defined multi-state model and
      generating simulated multi-state survival data in terms of random
      paths, which can be highly useful as a research tool.</p>
    </list-item>
    <list-item>
      <p>Modularity and compatibility for different time-to-event models
      such as Survival Forests and other custom ML models provided by
      the user.</p>
    </list-item>
  </list>
  <p>The package is designed to allow modular usage by both experienced
  researchers and non-expert users. In addition to fitting a multi-state
  model for a given data-set, <monospace>PyMSM</monospace> allows the
  user to simulate trajectories, thus creating a multi-state survival
  data-set, from a predefined model. This could be a valuable research
  tool, both for sharing sensitive simulated individual data and as a
  tool for any downstream task which needs individual trajectories. To
  the authors best knowledge, this is the first open-source multi-state
  model tool that allows fitting of such models while also dealing with
  important concepts such as right censoring, competing events,
  recurrent events, left truncation, and time-dependent covariates.</p>
</sec>
<sec id="usage-examples">
  <title>Usage examples</title>
  <p>This project is based on methods first introduced during 2020 for
  predicting national COVID-19 hospitalizations in Israel. Important
  health policy applications based on these methods were built and used
  by government policymakers throughout the pandemic. For example, help
  assess hospital resource utilization
  (<xref alt="Roimi et al., 2021" rid="ref-RoimiU003A2021" ref-type="bibr">Roimi
  et al., 2021</xref>), and associations between high hospital load and
  excess deaths
  (<xref alt="Rossman et al., 2021" rid="ref-RossmanU003A2021" ref-type="bibr">Rossman
  et al., 2021</xref>). A similar R version of this package is available
  in Roimi et. al. 2021, yet this is the first Python version to be
  released as an open-source package containing extended features and
  use cases. Other usage examples are provided in the software package
  docs such as breast cancer state transitions (Rotterdam dataset - see
  Figure 1), AIDS competing-risk data, disease-stage data from the
  European Society for Blood and Marrow Transplantation (EBMT) and
  COVID-19 national hospitalizations.</p>
  <fig>
    <caption><p>A multi-state model of the Rotterdam breast-cancer data,
    2790 observations. Numbers next to arrows indicate number of
    observed transitions. Graph automatically created by PyMSM after
    defining a data-set.</p></caption>
    <graphic mimetype="image" mime-subtype="png" xlink:href="media/rotterdam.png" xlink:title="" />
  </fig>
</sec>
<sec id="the-pymsm-package">
  <title>The <monospace>PyMSM</monospace> package</title>
  <p>A brief overview of the package functionality is described below.
  Detailed explanations of the API, along with four full usage examples
  on real data are available in the package documentation at
  https://hrossman.github.io/pymsm/.</p>
  <sec id="model-fitting">
    <title>Model fitting</title>
    <p>Fitting a multi-state model to a data-set requires only a few
    simple steps:</p>
    <list list-type="bullet">
      <list-item>
        <p>Preparing a data-set in one of two formats.</p>
      </list-item>
      <list-item>
        <p>Defining a function for updating time-dependent
        covariates.</p>
      </list-item>
      <list-item>
        <p>Defining covariates’ columns.</p>
      </list-item>
      <list-item>
        <p>Defining terminal states.</p>
      </list-item>
      <list-item>
        <p>Defining a minimum number of data transitions needed to fit a
        transition.</p>
      </list-item>
    </list>
    <p>Once all the above is done, the user can fit a multi-state model
    to the data-set, and use it for downstream analyses.</p>
  </sec>
  <sec id="path-sampling">
    <title>Path sampling</title>
    <p>Using the previously fitted multi-state model, the user can
    sample paths using Monte-Carlo simulations. Given covariates,
    initial state and time, next states and times spent at each future
    state are sequentially sampled via the entire estimated multi-state
    model. The process concludes when the path arrives at a terminal
    state or the number of transitions exceeds a pre-defined maximum.
    Once a large number of paths have been sampled for each observation,
    the user can explore summary statistics such as the probability of
    being in any of the states or the median time spent in each
    state.</p>
  </sec>
  <sec id="custom-fitters">
    <title>Custom fitters</title>
    <p><monospace>PyMSM</monospace> works with Cox proportional hazards
    models by default using the lifelines
    (<xref alt="Davidson-Pilon, 2019" rid="ref-Davidson-PilonU003A2019" ref-type="bibr">Davidson-Pilon,
    2019</xref>) Python library, but also allows configuration of custom
    event-specific fitters. EventSpecificFitter class is an abstract
    class which defines the API and needs to be subclassed by the
    user.</p>
    <p>Some custom fitters are available off-the-shelf such as survival
    trees
    (<xref alt="Ishwaran et al., 2008" rid="ref-IshwaranU003A2008" ref-type="bibr">Ishwaran
    et al., 2008</xref>) through the
    <monospace>scikit-survival</monospace> Python package
    (<xref alt="Pölsterl, 2020" rid="ref-PölsterlU003A2020" ref-type="bibr">Pölsterl,
    2020</xref>).</p>
  </sec>
  <sec id="simulating-multi-state-survival-data">
    <title>Simulating Multi-state Survival Data</title>
    <p>Using a pre-loaded or a pre-defined multi-state model,
    <monospace>PyMSM</monospace> provides an API to generate simulated
    data of random trajectories. Creating a simulated multi-state paths
    data-set could serve as a useful research tool in cases where data
    sharing is limited due to privacy limitations, or as a generation
    tool for any downstream task which requires individual
    trajectories.</p>
  </sec>
</sec>
<sec id="models-and-methods">
  <title>Models and Methods</title>
  <p>In this section we give an overview of the multi-state models and
  methods underlying the statistical analysis and computations performed
  in <monospace>PyMSM</monospace>.</p>
  <sec id="introduction">
    <title>Introduction</title>
    <p>The description of the content of <monospace>PyMSM</monospace> is
    easier to digest under a given setting. Thus, to set the stage, we
    adopt the multi-state model of Roimi
    (<xref alt="Roimi et al., 2021" rid="ref-RoimiU003A2021" ref-type="bibr">Roimi
    et al., 2021</xref>). Specifically, assume a multi-state model
    consists of four states <inline-formula><alternatives>
    <tex-math><![CDATA[A,B,C,D]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>B</mml:mi><mml:mo>,</mml:mo><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mi>D</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
    and six possible transitions: <disp-formula><alternatives>
    <tex-math><![CDATA[
    A \rightarrow B \,\,\,\,\,\,       A \rightarrow C   \,\,\,\,\,\,     A \rightarrow D   \,\,\,\,\,\,    B \rightarrow A \,\,\,\,\,\,    B \rightarrow D \,\,\,\,\,\,   C \rightarrow A \, .
    ]]></tex-math>
    <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>A</mml:mi><mml:mo>→</mml:mo><mml:mi>B</mml:mi><mml:mspace width="0.167em"></mml:mspace><mml:mspace width="0.167em"></mml:mspace><mml:mspace width="0.167em"></mml:mspace><mml:mspace width="0.167em"></mml:mspace><mml:mspace width="0.167em"></mml:mspace><mml:mspace width="0.167em"></mml:mspace><mml:mi>A</mml:mi><mml:mo>→</mml:mo><mml:mi>C</mml:mi><mml:mspace width="0.167em"></mml:mspace><mml:mspace width="0.167em"></mml:mspace><mml:mspace width="0.167em"></mml:mspace><mml:mspace width="0.167em"></mml:mspace><mml:mspace width="0.167em"></mml:mspace><mml:mspace width="0.167em"></mml:mspace><mml:mi>A</mml:mi><mml:mo>→</mml:mo><mml:mi>D</mml:mi><mml:mspace width="0.167em"></mml:mspace><mml:mspace width="0.167em"></mml:mspace><mml:mspace width="0.167em"></mml:mspace><mml:mspace width="0.167em"></mml:mspace><mml:mspace width="0.167em"></mml:mspace><mml:mspace width="0.167em"></mml:mspace><mml:mi>B</mml:mi><mml:mo>→</mml:mo><mml:mi>A</mml:mi><mml:mspace width="0.167em"></mml:mspace><mml:mspace width="0.167em"></mml:mspace><mml:mspace width="0.167em"></mml:mspace><mml:mspace width="0.167em"></mml:mspace><mml:mspace width="0.167em"></mml:mspace><mml:mspace width="0.167em"></mml:mspace><mml:mi>B</mml:mi><mml:mo>→</mml:mo><mml:mi>D</mml:mi><mml:mspace width="0.167em"></mml:mspace><mml:mspace width="0.167em"></mml:mspace><mml:mspace width="0.167em"></mml:mspace><mml:mspace width="0.167em"></mml:mspace><mml:mspace width="0.167em"></mml:mspace><mml:mspace width="0.167em"></mml:mspace><mml:mi>C</mml:mi><mml:mo>→</mml:mo><mml:mi>A</mml:mi><mml:mspace width="0.167em"></mml:mspace><mml:mi>.</mml:mi></mml:mrow></mml:math></alternatives></disp-formula>
    Each transition is characterized by a transition-specific hazard
    function, also known as a cause-specific hazard function,
    <disp-formula><alternatives>
    <tex-math><![CDATA[
    \lambda_{A,B} (t|Z) \,\,\, \lambda_{A,C} (t|Z) \,\,\,   \lambda_{A,D} (t|Z) \,\,\, \lambda_{B,A} (t|Z)  \,\,\, \lambda_{B,D} (t|Z) \,\,\,  \lambda_{C,A} (t|Z) \,
    ]]></tex-math>
    <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>λ</mml:mi><mml:mrow><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>B</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false" form="prefix">|</mml:mo><mml:mi>Z</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mspace width="0.167em"></mml:mspace><mml:mspace width="0.167em"></mml:mspace><mml:mspace width="0.167em"></mml:mspace><mml:msub><mml:mi>λ</mml:mi><mml:mrow><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>C</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false" form="prefix">|</mml:mo><mml:mi>Z</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mspace width="0.167em"></mml:mspace><mml:mspace width="0.167em"></mml:mspace><mml:mspace width="0.167em"></mml:mspace><mml:msub><mml:mi>λ</mml:mi><mml:mrow><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>D</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false" form="prefix">|</mml:mo><mml:mi>Z</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mspace width="0.167em"></mml:mspace><mml:mspace width="0.167em"></mml:mspace><mml:mspace width="0.167em"></mml:mspace><mml:msub><mml:mi>λ</mml:mi><mml:mrow><mml:mi>B</mml:mi><mml:mo>,</mml:mo><mml:mi>A</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false" form="prefix">|</mml:mo><mml:mi>Z</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mspace width="0.167em"></mml:mspace><mml:mspace width="0.167em"></mml:mspace><mml:mspace width="0.167em"></mml:mspace><mml:msub><mml:mi>λ</mml:mi><mml:mrow><mml:mi>B</mml:mi><mml:mo>,</mml:mo><mml:mi>D</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false" form="prefix">|</mml:mo><mml:mi>Z</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mspace width="0.167em"></mml:mspace><mml:mspace width="0.167em"></mml:mspace><mml:mspace width="0.167em"></mml:mspace><mml:msub><mml:mi>λ</mml:mi><mml:mrow><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mi>A</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false" form="prefix">|</mml:mo><mml:mi>Z</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mspace width="0.167em"></mml:mspace></mml:mrow></mml:math></alternatives></disp-formula>
    for <inline-formula><alternatives>
    <tex-math><![CDATA[t > 0]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>t</mml:mi><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></alternatives></inline-formula>
    and a <inline-formula><alternatives>
    <tex-math><![CDATA[Z]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>Z</mml:mi></mml:math></alternatives></inline-formula>
    vector of covariates. Although <inline-formula><alternatives>
    <tex-math><![CDATA[Z]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>Z</mml:mi></mml:math></alternatives></inline-formula>
    is shared by the six models above, it does not imply that identical
    covariates must be used in these models. For example, in Cox models
    with transition-dependent regression coefficient vectors, one can
    set any specific coefficient to zero for excluding the corresponding
    covariate.</p>
    <p>Let <inline-formula><alternatives>
    <tex-math><![CDATA[J_C]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>J</mml:mi><mml:mi>C</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
    and <inline-formula><alternatives>
    <tex-math><![CDATA[J_N]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>J</mml:mi><mml:mi>N</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
    denote the current and next states, respectively, and
    <inline-formula><alternatives>
    <tex-math><![CDATA[T]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>T</mml:mi></mml:math></alternatives></inline-formula>
    denote the transition time. Assume the journey of an observation in
    the system described by the multi-state model starts at state
    <inline-formula><alternatives>
    <tex-math><![CDATA[j^*]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msup><mml:mi>j</mml:mi><mml:mo>*</mml:mo></mml:msup></mml:math></alternatives></inline-formula>
    with a vector of baseline covariates <inline-formula><alternatives>
    <tex-math><![CDATA[W]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>W</mml:mi></mml:math></alternatives></inline-formula>.
    Let <inline-formula><alternatives>
    <tex-math><![CDATA[Z(t)]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>Z</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
    be a time-dependent vector of covariates, where
    <disp-formula><alternatives>
    <tex-math><![CDATA[ 
    Z(T)^T = (W^T,\widetilde{W}(T)^T)
    ]]></tex-math>
    <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>Z</mml:mi><mml:msup><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mi>T</mml:mi></mml:msup><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msup><mml:mi>W</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mo>,</mml:mo><mml:mover><mml:mi>W</mml:mi><mml:mo accent="true">̃</mml:mo></mml:mover><mml:msup><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mi>T</mml:mi></mml:msup><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></disp-formula>
    and <inline-formula><alternatives>
    <tex-math><![CDATA[\widetilde{W}(t)]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mover><mml:mi>W</mml:mi><mml:mo accent="true">̃</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
    is a time-dependent vector of covariates known at the entrance to
    the new state. Let <inline-formula><alternatives>
    <tex-math><![CDATA[K_{j^*}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>K</mml:mi><mml:msup><mml:mi>j</mml:mi><mml:mo>*</mml:mo></mml:msup></mml:msub></mml:math></alternatives></inline-formula>
    be the set of possible states that can be reached directly from
    state <inline-formula><alternatives>
    <tex-math><![CDATA[j^*]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msup><mml:mi>j</mml:mi><mml:mo>*</mml:mo></mml:msup></mml:math></alternatives></inline-formula>.
    Then, the conditional probability of transition
    <inline-formula><alternatives>
    <tex-math><![CDATA[j^* \rightarrow j]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msup><mml:mi>j</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mo>→</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>,
    <inline-formula><alternatives>
    <tex-math><![CDATA[j \in K_{j^*}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi>K</mml:mi><mml:msup><mml:mi>j</mml:mi><mml:mo>*</mml:mo></mml:msup></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>,
    by time <inline-formula><alternatives>
    <tex-math><![CDATA[t]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>t</mml:mi></mml:math></alternatives></inline-formula>
    given <inline-formula><alternatives>
    <tex-math><![CDATA[Z(0)=Z]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>Z</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>Z</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
    is given by <disp-formula><alternatives>
    <tex-math><![CDATA[
    \Pr(T \leq t, J_N=j|J_C=j^*,Z(0)=Z) = \int_0^t \lambda_{j^*,j}(u|Z)\exp\left\{-\sum_{k=1}^{|K_{j^*}|} \Lambda_{j^*,k}(u-|Z) \right\} du \, ,
    ]]></tex-math>
    <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo>Pr</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>T</mml:mi><mml:mo>≤</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>J</mml:mi><mml:mi>N</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false" form="prefix">|</mml:mo><mml:msub><mml:mi>J</mml:mi><mml:mi>C</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msup><mml:mi>j</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mo>,</mml:mo><mml:mi>Z</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>Z</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msubsup><mml:mo>∫</mml:mo><mml:mn>0</mml:mn><mml:mi>t</mml:mi></mml:msubsup><mml:msub><mml:mi>λ</mml:mi><mml:mrow><mml:msup><mml:mi>j</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false" form="prefix">|</mml:mo><mml:mi>Z</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>exp</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">{</mml:mo><mml:mo>−</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mo stretchy="true" form="prefix">|</mml:mo><mml:msub><mml:mi>K</mml:mi><mml:msup><mml:mi>j</mml:mi><mml:mo>*</mml:mo></mml:msup></mml:msub><mml:mo stretchy="true" form="postfix">|</mml:mo></mml:mrow></mml:munderover><mml:msub><mml:mi>Λ</mml:mi><mml:mrow><mml:msup><mml:mi>j</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>u</mml:mi><mml:mo>−</mml:mo><mml:mo stretchy="false" form="prefix">|</mml:mo><mml:mi>Z</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">}</mml:mo></mml:mrow><mml:mi>d</mml:mi><mml:mi>u</mml:mi><mml:mspace width="0.167em"></mml:mspace><mml:mo>,</mml:mo></mml:mrow></mml:math></alternatives></disp-formula>
    where <inline-formula><alternatives>
    <tex-math><![CDATA[u-]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>u</mml:mi><mml:mo>−</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>
    is a time just prior to <inline-formula><alternatives>
    <tex-math><![CDATA[u]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>u</mml:mi></mml:math></alternatives></inline-formula>,
    <inline-formula><alternatives>
    <tex-math><![CDATA[|K_{j^*}|]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo stretchy="true" form="prefix">|</mml:mo><mml:msub><mml:mi>K</mml:mi><mml:msup><mml:mi>j</mml:mi><mml:mo>*</mml:mo></mml:msup></mml:msub><mml:mo stretchy="true" form="postfix">|</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>
    is the cardinality of <inline-formula><alternatives>
    <tex-math><![CDATA[K_{j^*}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>K</mml:mi><mml:msup><mml:mi>j</mml:mi><mml:mo>*</mml:mo></mml:msup></mml:msub></mml:math></alternatives></inline-formula>
    and <inline-formula><alternatives>
    <tex-math><![CDATA[\Lambda_{j,k}(t|Z)=\int_0^t \lambda_{j,k}(u|Z) du]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>Λ</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false" form="prefix">|</mml:mo><mml:mi>Z</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msubsup><mml:mo>∫</mml:mo><mml:mn>0</mml:mn><mml:mi>t</mml:mi></mml:msubsup><mml:msub><mml:mi>λ</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false" form="prefix">|</mml:mo><mml:mi>Z</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mi>d</mml:mi><mml:mi>u</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
    is the cumulative hazard function. In our example, if the first
    state <inline-formula><alternatives>
    <tex-math><![CDATA[j^*=A]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msup><mml:mi>j</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mo>=</mml:mo><mml:mi>A</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>,
    <inline-formula><alternatives>
    <tex-math><![CDATA[K_{j^*}=\{B,C,D\}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>K</mml:mi><mml:msup><mml:mi>j</mml:mi><mml:mo>*</mml:mo></mml:msup></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false" form="prefix">{</mml:mo><mml:mi>B</mml:mi><mml:mo>,</mml:mo><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false" form="postfix">}</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>,
    and</p>
    <p><disp-formula><alternatives>
    <tex-math><![CDATA[
    \Pr(T \leq t, J_N=j|J_C=A,Z(0)=Z) = 
    ]]></tex-math>
    <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo>Pr</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>T</mml:mi><mml:mo>≤</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>J</mml:mi><mml:mi>N</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false" form="prefix">|</mml:mo><mml:msub><mml:mi>J</mml:mi><mml:mi>C</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>Z</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>Z</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo></mml:mrow></mml:math></alternatives></disp-formula>
    <disp-formula><alternatives>
    <tex-math><![CDATA[
    \int_0^t \lambda_{A,j}(u|Z)\exp\left\{- \Lambda_{A,B}(u-|Z) - \Lambda_{A,C}(u-|Z) - \Lambda_{A,D}(u-|Z)\right\} du \, .
    ]]></tex-math>
    <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msubsup><mml:mo>∫</mml:mo><mml:mn>0</mml:mn><mml:mi>t</mml:mi></mml:msubsup><mml:msub><mml:mi>λ</mml:mi><mml:mrow><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false" form="prefix">|</mml:mo><mml:mi>Z</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>exp</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">{</mml:mo><mml:mo>−</mml:mo><mml:msub><mml:mi>Λ</mml:mi><mml:mrow><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>B</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>u</mml:mi><mml:mo>−</mml:mo><mml:mo stretchy="false" form="prefix">|</mml:mo><mml:mi>Z</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:msub><mml:mi>Λ</mml:mi><mml:mrow><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>C</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>u</mml:mi><mml:mo>−</mml:mo><mml:mo stretchy="false" form="prefix">|</mml:mo><mml:mi>Z</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:msub><mml:mi>Λ</mml:mi><mml:mrow><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>D</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>u</mml:mi><mml:mo>−</mml:mo><mml:mo stretchy="false" form="prefix">|</mml:mo><mml:mi>Z</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">}</mml:mo></mml:mrow><mml:mi>d</mml:mi><mml:mi>u</mml:mi><mml:mspace width="0.167em"></mml:mspace><mml:mi>.</mml:mi></mml:mrow></mml:math></alternatives></disp-formula></p>
    <p>The marginal probability of transition
    <inline-formula><alternatives>
    <tex-math><![CDATA[j^* \rightarrow j]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msup><mml:mi>j</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mo>→</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
    is given by <disp-formula><alternatives>
    <tex-math><![CDATA[
    \Pr(J_N=j|J_C=j^*,Z(0)=Z) = \int_0^\infty \lambda_{j^*,j}(u|Z)\exp\left\{-\sum_{k=1}^{|K_{j^*}|} \Lambda_{j^*,k}(u-|Z) \right\} du \, ,
    ]]></tex-math>
    <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo>Pr</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>J</mml:mi><mml:mi>N</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false" form="prefix">|</mml:mo><mml:msub><mml:mi>J</mml:mi><mml:mi>C</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msup><mml:mi>j</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mo>,</mml:mo><mml:mi>Z</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>Z</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msubsup><mml:mo>∫</mml:mo><mml:mn>0</mml:mn><mml:mi>∞</mml:mi></mml:msubsup><mml:msub><mml:mi>λ</mml:mi><mml:mrow><mml:msup><mml:mi>j</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false" form="prefix">|</mml:mo><mml:mi>Z</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>exp</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">{</mml:mo><mml:mo>−</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mo stretchy="true" form="prefix">|</mml:mo><mml:msub><mml:mi>K</mml:mi><mml:msup><mml:mi>j</mml:mi><mml:mo>*</mml:mo></mml:msup></mml:msub><mml:mo stretchy="true" form="postfix">|</mml:mo></mml:mrow></mml:munderover><mml:msub><mml:mi>Λ</mml:mi><mml:mrow><mml:msup><mml:mi>j</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>u</mml:mi><mml:mo>−</mml:mo><mml:mo stretchy="false" form="prefix">|</mml:mo><mml:mi>Z</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">}</mml:mo></mml:mrow><mml:mi>d</mml:mi><mml:mi>u</mml:mi><mml:mspace width="0.167em"></mml:mspace><mml:mo>,</mml:mo></mml:mrow></mml:math></alternatives></disp-formula>
    and the probability of transition time less than
    <inline-formula><alternatives>
    <tex-math><![CDATA[t]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>t</mml:mi></mml:math></alternatives></inline-formula>
    given a transition <inline-formula><alternatives>
    <tex-math><![CDATA[j^* \rightarrow j]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msup><mml:mi>j</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mo>→</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
    <disp-formula><alternatives>
    <tex-math><![CDATA[
    \Pr(T \leq t | J_N=j,J_C=j^*, Z(0)=Z)
    = \frac{ \int_0^t \lambda_{j^*,j}(u|Z)\exp\left\{-\sum_{k=1}^{|K_{j^*}|} \Lambda_{j^*,k}(u-|Z) \right\} du  }
    { \int_0^\infty \lambda_{j^*,j}(u|Z)\exp\left\{-\sum_{k=1}^{|K_{j^*}|} \Lambda_{j^*,k}(u-|Z) \right\} du  }  \, .
    ]]></tex-math>
    <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo>Pr</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>T</mml:mi><mml:mo>≤</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false" form="prefix">|</mml:mo><mml:msub><mml:mi>J</mml:mi><mml:mi>N</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>J</mml:mi><mml:mi>C</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msup><mml:mi>j</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mo>,</mml:mo><mml:mi>Z</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>Z</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msubsup><mml:mo>∫</mml:mo><mml:mn>0</mml:mn><mml:mi>t</mml:mi></mml:msubsup><mml:msub><mml:mi>λ</mml:mi><mml:mrow><mml:msup><mml:mi>j</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false" form="prefix">|</mml:mo><mml:mi>Z</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>exp</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">{</mml:mo><mml:mo>−</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mo stretchy="true" form="prefix">|</mml:mo><mml:msub><mml:mi>K</mml:mi><mml:msup><mml:mi>j</mml:mi><mml:mo>*</mml:mo></mml:msup></mml:msub><mml:mo stretchy="true" form="postfix">|</mml:mo></mml:mrow></mml:munderover><mml:msub><mml:mi>Λ</mml:mi><mml:mrow><mml:msup><mml:mi>j</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>u</mml:mi><mml:mo>−</mml:mo><mml:mo stretchy="false" form="prefix">|</mml:mo><mml:mi>Z</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">}</mml:mo></mml:mrow><mml:mi>d</mml:mi><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:msubsup><mml:mo>∫</mml:mo><mml:mn>0</mml:mn><mml:mi>∞</mml:mi></mml:msubsup><mml:msub><mml:mi>λ</mml:mi><mml:mrow><mml:msup><mml:mi>j</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false" form="prefix">|</mml:mo><mml:mi>Z</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>exp</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">{</mml:mo><mml:mo>−</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mo stretchy="true" form="prefix">|</mml:mo><mml:msub><mml:mi>K</mml:mi><mml:msup><mml:mi>j</mml:mi><mml:mo>*</mml:mo></mml:msup></mml:msub><mml:mo stretchy="true" form="postfix">|</mml:mo></mml:mrow></mml:munderover><mml:msub><mml:mi>Λ</mml:mi><mml:mrow><mml:msup><mml:mi>j</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>u</mml:mi><mml:mo>−</mml:mo><mml:mo stretchy="false" form="prefix">|</mml:mo><mml:mi>Z</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">}</mml:mo></mml:mrow><mml:mi>d</mml:mi><mml:mi>u</mml:mi></mml:mrow></mml:mfrac><mml:mspace width="0.167em"></mml:mspace><mml:mi>.</mml:mi></mml:mrow></mml:math></alternatives></disp-formula>
    Now assume an observation entered state
    <inline-formula><alternatives>
    <tex-math><![CDATA[j']]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>j</mml:mi><mml:mi>′</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
    at time <inline-formula><alternatives>
    <tex-math><![CDATA[t'>0]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>t</mml:mi><mml:mi>′</mml:mi><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></alternatives></inline-formula>
    with <inline-formula><alternatives>
    <tex-math><![CDATA[Z(t')]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>Z</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>t</mml:mi><mml:mi>′</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>.
    Then, the probability of <inline-formula><alternatives>
    <tex-math><![CDATA[j' \rightarrow j]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>j</mml:mi><mml:mi>′</mml:mi><mml:mo>→</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
    by time <inline-formula><alternatives>
    <tex-math><![CDATA[t]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>t</mml:mi></mml:math></alternatives></inline-formula>
    is given by <disp-formula><alternatives>
    <tex-math><![CDATA[
    \Pr(T \leq t, J_N=j|J_C=j',Z(t')=Z) = \int_{t'}^t \lambda_{j',j}(u|Z)\exp\left\{-\sum_{k=1}^{|K_{j'}|} \Lambda_{j',k}(u-|Z) \right\} du \, ,
    ]]></tex-math>
    <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo>Pr</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>T</mml:mi><mml:mo>≤</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>J</mml:mi><mml:mi>N</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false" form="prefix">|</mml:mo><mml:msub><mml:mi>J</mml:mi><mml:mi>C</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>j</mml:mi><mml:mi>′</mml:mi><mml:mo>,</mml:mo><mml:mi>Z</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>t</mml:mi><mml:mi>′</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>Z</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msubsup><mml:mo>∫</mml:mo><mml:mrow><mml:mi>t</mml:mi><mml:mi>′</mml:mi></mml:mrow><mml:mi>t</mml:mi></mml:msubsup><mml:msub><mml:mi>λ</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mi>′</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false" form="prefix">|</mml:mo><mml:mi>Z</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>exp</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">{</mml:mo><mml:mo>−</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mo stretchy="true" form="prefix">|</mml:mo><mml:msub><mml:mi>K</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mi>′</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="true" form="postfix">|</mml:mo></mml:mrow></mml:munderover><mml:msub><mml:mi>Λ</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mi>′</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>u</mml:mi><mml:mo>−</mml:mo><mml:mo stretchy="false" form="prefix">|</mml:mo><mml:mi>Z</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">}</mml:mo></mml:mrow><mml:mi>d</mml:mi><mml:mi>u</mml:mi><mml:mspace width="0.167em"></mml:mspace><mml:mo>,</mml:mo></mml:mrow></mml:math></alternatives></disp-formula>
    and <disp-formula><alternatives>
    <tex-math><![CDATA[
    \Pr(T \leq t| J_N=j,J_C=j',Z(t')=Z) = 
    \frac{ \int_{t'}^t \lambda_{j',j}(u|Z)\exp\left\{-\sum_{k=1}^{|K_{j'}|} \Lambda_{j',k}(u-|Z) \right\} du }
    { \int_{t'}^\infty \lambda_{j',j}(u|Z)\exp\left\{-\sum_{k=1}^{|K_{j'}|} \Lambda_{j',k}(u-|Z) \right\} du } \, .
    ]]></tex-math>
    <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo>Pr</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>T</mml:mi><mml:mo>≤</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false" form="prefix">|</mml:mo><mml:msub><mml:mi>J</mml:mi><mml:mi>N</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>J</mml:mi><mml:mi>C</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>j</mml:mi><mml:mi>′</mml:mi><mml:mo>,</mml:mo><mml:mi>Z</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>t</mml:mi><mml:mi>′</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>Z</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msubsup><mml:mo>∫</mml:mo><mml:mrow><mml:mi>t</mml:mi><mml:mi>′</mml:mi></mml:mrow><mml:mi>t</mml:mi></mml:msubsup><mml:msub><mml:mi>λ</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mi>′</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false" form="prefix">|</mml:mo><mml:mi>Z</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>exp</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">{</mml:mo><mml:mo>−</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mo stretchy="true" form="prefix">|</mml:mo><mml:msub><mml:mi>K</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mi>′</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="true" form="postfix">|</mml:mo></mml:mrow></mml:munderover><mml:msub><mml:mi>Λ</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mi>′</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>u</mml:mi><mml:mo>−</mml:mo><mml:mo stretchy="false" form="prefix">|</mml:mo><mml:mi>Z</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">}</mml:mo></mml:mrow><mml:mi>d</mml:mi><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:msubsup><mml:mo>∫</mml:mo><mml:mrow><mml:mi>t</mml:mi><mml:mi>′</mml:mi></mml:mrow><mml:mi>∞</mml:mi></mml:msubsup><mml:msub><mml:mi>λ</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mi>′</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false" form="prefix">|</mml:mo><mml:mi>Z</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>exp</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">{</mml:mo><mml:mo>−</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mo stretchy="true" form="prefix">|</mml:mo><mml:msub><mml:mi>K</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mi>′</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="true" form="postfix">|</mml:mo></mml:mrow></mml:munderover><mml:msub><mml:mi>Λ</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mi>′</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>u</mml:mi><mml:mo>−</mml:mo><mml:mo stretchy="false" form="prefix">|</mml:mo><mml:mi>Z</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">}</mml:mo></mml:mrow><mml:mi>d</mml:mi><mml:mi>u</mml:mi></mml:mrow></mml:mfrac><mml:mspace width="0.167em"></mml:mspace><mml:mi>.</mml:mi></mml:mrow></mml:math></alternatives></disp-formula>
    For all of the above, set the main multi-state model components
    required for prediction, as will be explained in the following
    sections.</p>
  </sec>
  <sec id="estimation">
    <title>Estimation</title>
    <sec id="cox-transition-specific-hazard-models">
      <title>Cox transition-specific hazard models</title>
      <p>The estimation procedure for the hazard functions that define
      the multi-state model can be chosen by the user. For example, if
      Cox models are adopted, where each transition
      <inline-formula><alternatives>
      <tex-math><![CDATA[j \rightarrow j']]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>j</mml:mi><mml:mo>→</mml:mo><mml:mi>j</mml:mi><mml:mi>′</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
      consists of transition-specific unspecified baseline hazard
      function <inline-formula><alternatives>
      <tex-math><![CDATA[\lambda_{0j,j'}(\cdot)]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>λ</mml:mi><mml:mrow><mml:mn>0</mml:mn><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mi>′</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mo>⋅</mml:mo><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
      and a transition-specific vector of regression coefficients
      <inline-formula><alternatives>
      <tex-math><![CDATA[\beta_{j,j'}]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>β</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mi>′</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>,
      i.e., <disp-formula><alternatives>
      <tex-math><![CDATA[
      \lambda_{j,j'}(t|Z) = \lambda_{0j,j'}(t) \exp(Z^T \beta_{j,j'}) \, ,
      ]]></tex-math>
      <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>λ</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mi>′</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false" form="prefix">|</mml:mo><mml:mi>Z</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mi>λ</mml:mi><mml:mrow><mml:mn>0</mml:mn><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mi>′</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>exp</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msup><mml:mi>Z</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:msub><mml:mi>β</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mi>′</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mspace width="0.167em"></mml:mspace><mml:mo>,</mml:mo></mml:mrow></mml:math></alternatives></disp-formula>
      the estimation procedure is straightforward. Specifically, under
      transition-specific semi-parametric Cox models, we can easily deal
      with right censoring and competing events based on the approach of
      Andersen &amp; Keiding
      (<xref alt="Andersen et al., 1991" rid="ref-AndersenU003A1991" ref-type="bibr">Andersen
      et al., 1991</xref>). Namely, maximization of the partial
      likelihood function in terms of all the involved Cox models is
      done by maximizing the partial-likelihood of each transition
      separately, and temporarily treating competing events as
      censoring. Thus, we use the standard partial-likelihood estimators
      of <inline-formula><alternatives>
      <tex-math><![CDATA[\beta_{j,j'}]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>β</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mi>′</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>
      (<xref alt="Klein &amp; Moeschberger, 2006" rid="ref-KleinU003A2006" ref-type="bibr">Klein
      &amp; Moeschberger, 2006</xref>) and Breslow estimator of
      <inline-formula><alternatives>
      <tex-math><![CDATA[\Lambda_{0j,j'}(t)=\int_0^t \lambda_{0j,j'}(u)du]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>Λ</mml:mi><mml:mrow><mml:mn>0</mml:mn><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mi>′</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msubsup><mml:mo>∫</mml:mo><mml:mn>0</mml:mn><mml:mi>t</mml:mi></mml:msubsup><mml:msub><mml:mi>λ</mml:mi><mml:mrow><mml:mn>0</mml:mn><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mi>′</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mi>d</mml:mi><mml:mi>u</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
      (<xref alt="Breslow, 1972" rid="ref-BreslowU003A1972" ref-type="bibr">Breslow,
      1972</xref>). Another important issue is left truncation which
      occurs at each transition that is not the origin state of the
      subject’s path. Bias due to left truncation is eliminated by using
      the well-known risk-set correction
      (<xref alt="Klein &amp; Moeschberger, 2006" rid="ref-KleinU003A2006" ref-type="bibr">Klein
      &amp; Moeschberger, 2006</xref>). Recurrent events, which occurs
      when subjects visit the same state multiple times, are
      accommodated by the robust standard errors
      (<xref alt="Andersen &amp; Gill, 1982" rid="ref-AndersenU003A1982" ref-type="bibr">Andersen
      &amp; Gill, 1982</xref>).</p>
      <p>Based on the estimates of the regression coefficients and the
      cumulative baseline hazard functions, all the distribution
      functions above can be estimated by replacing the integrals with
      sums over the observed failure times, replacing any unknown
      parameter by its estimator. Specifically, let
      <inline-formula><alternatives>
      <tex-math><![CDATA[\tau_{j^*,j}]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>τ</mml:mi><mml:mrow><mml:msup><mml:mi>j</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>
      be the largest observed event time of transition
      <inline-formula><alternatives>
      <tex-math><![CDATA[j^* \rightarrow j]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msup><mml:mi>j</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mo>→</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>.
      Then, <disp-formula><alternatives>
      <tex-math><![CDATA[\begin{gathered}
      \widehat{\Pr} (J_N=j | J_C=j^*,Z(0)=Z) \\
          =   \sum_{t_m \leq \tau_{j^*,j}} \exp\left( \widehat\beta_{j^*,j}^T Z\right) \widehat\lambda_{0j^*,j}(t_m) \exp \left\{-\sum_{k=1}^{|K_{j^*}|} \widehat\Lambda_{0j^*,k}(t_{m-1})\exp\left( \widehat\beta_{j^*,k}^T Z\right) \right\} \, ,  
          \end{gathered}]]></tex-math>
      <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mtable><mml:mtr><mml:mtd columnalign="center"><mml:mover><mml:mo>Pr</mml:mo><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>J</mml:mi><mml:mi>N</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false" form="prefix">|</mml:mo><mml:msub><mml:mi>J</mml:mi><mml:mi>C</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msup><mml:mi>j</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mo>,</mml:mo><mml:mi>Z</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>Z</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="center"><mml:mo>=</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>m</mml:mi></mml:msub><mml:mo>≤</mml:mo><mml:msub><mml:mi>τ</mml:mi><mml:mrow><mml:msup><mml:mi>j</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:munder><mml:mo>exp</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msubsup><mml:mover><mml:mi>β</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mrow><mml:msup><mml:mi>j</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow><mml:mi>T</mml:mi></mml:msubsup><mml:mi>Z</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:msub><mml:mover><mml:mi>λ</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mrow><mml:mn>0</mml:mn><mml:msup><mml:mi>j</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mi>m</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>exp</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">{</mml:mo><mml:mo>−</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mo stretchy="true" form="prefix">|</mml:mo><mml:msub><mml:mi>K</mml:mi><mml:msup><mml:mi>j</mml:mi><mml:mo>*</mml:mo></mml:msup></mml:msub><mml:mo stretchy="true" form="postfix">|</mml:mo></mml:mrow></mml:munderover><mml:msub><mml:mover><mml:mi>Λ</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mrow><mml:mn>0</mml:mn><mml:msup><mml:mi>j</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>m</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>exp</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msubsup><mml:mover><mml:mi>β</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mrow><mml:msup><mml:mi>j</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow><mml:mi>T</mml:mi></mml:msubsup><mml:mi>Z</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">}</mml:mo></mml:mrow><mml:mspace width="0.167em"></mml:mspace><mml:mo>,</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p>
      <p><disp-formula><tex-math><![CDATA[\begin{gathered}
      \widehat{\Pr} (T\leq t| J_N=j', J_C=j^* , Z(0)=Z)\\
          \hspace{0.5cm} = \frac{\sum_{t_m \leq t} \exp\left( \widehat\beta_{j^*,j'}^T Z\right) \widehat\lambda_{0j^*,j'}(t_m) \exp \left\{-\sum_{k=1}^{|K_{j^*}|} \widehat\Lambda_{0j^*,k}(t_{m-1})\exp\left( \widehat\beta_{j^*k}^T Z\right) \right\} }{ \sum_{t_m \leq \tau_{j^*,j'}} \exp\left( \widehat\beta_{j^*,j'}^T Z\right) \widehat\lambda_{0j^*,j'}(t_m) \exp \left\{-\sum_{k=1}^{K_{j^*}} \widehat\Lambda_{0j^*,k}(t_{m-1})\exp\left( \widehat\beta_{j^*,k}^T Z\right) \right\} } \, , 
          \end{gathered}]]></tex-math></disp-formula> and finally, given
      a new <inline-formula><alternatives>
      <tex-math><![CDATA[\breve{j}]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mover><mml:mi>j</mml:mi><mml:mo accent="true">̆</mml:mo></mml:mover></mml:math></alternatives></inline-formula>,
      the estimated probability of staying at state
      <inline-formula><alternatives>
      <tex-math><![CDATA[j']]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>j</mml:mi><mml:mi>′</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
      less than or equal <inline-formula><alternatives>
      <tex-math><![CDATA[t]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>t</mml:mi></mml:math></alternatives></inline-formula>
      time units is given by
      <disp-formula><tex-math><![CDATA[\begin{gathered}
      \widehat{\Pr} (T\leq t| J_N=\breve{j}, J_C=j' , Z(t')=Z) \\
          \hspace{0.5cm} = \frac{\sum_{t' < t_m \leq t} \exp\left( \widehat\beta_{j',\breve{j}}^T Z\right) \widehat\lambda_{0j',\breve{j}}(t_m) \exp \left\{-\sum_{k=1}^{|K_{j'}|} \widehat\Lambda_{0j',k}(t_{m-1})\exp\left( \widehat\beta_{j',k}^T Z\right) \right\} }{ \sum_{t' < t_m \leq \tau_{j',\breve{j}}} \exp\left( \widehat\beta_{j',\breve{j}}^T Z\right) \widehat\lambda_{0j',\breve{j}}(t_m) \exp \left\{-\sum_{k=1}^{K_{j'}} \widehat\Lambda_{0j',k}(t_{m-1})\exp\left( \widehat\beta_{j',k}^T Z\right) \right\} } \, .
          \end{gathered}]]></tex-math></disp-formula></p>
    </sec>
    <sec id="other-transition-specific-models">
      <title>Other transition-specific models</title>
      <p>The user can define other survival models and estimation
      procedures, such as accelerated failure time models, random
      survival forests
      (<xref alt="Ishwaran et al., 2008" rid="ref-IshwaranU003A2008" ref-type="bibr">Ishwaran
      et al., 2008</xref>) etc, for each transition, as explained in
      section Custom Fitters above.</p>
    </sec>
  </sec>
  <sec id="prediction---monte-carlo-simulation">
    <title>Prediction - Monte-Carlo Simulation</title>
    <p>Based on the multi-state model, we reconstruct the complete
    distribution of the path for a new observation, given the observed
    covariates <inline-formula><alternatives>
    <tex-math><![CDATA[W]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>W</mml:mi></mml:math></alternatives></inline-formula>.
    Based on the reconstructed distribution we estimate the probability
    of visiting each state, the total length of stay at each state and
    the total length of stay in the entire system.</p>
    <p>The above quantities can be predicted before entering the system
    and also during the stay at one of the systems’ states, while
    correctly taking into account the accumulated time already spent in
    the system and <inline-formula><alternatives>
    <tex-math><![CDATA[Z(\cdot)]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>Z</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mo>⋅</mml:mo><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>.</p>
    <p>We reconstruct the distribution of the path for a new observation
    by Monte-Carlo simulation. Assume the starting state (provided by
    the user) is <inline-formula><alternatives>
    <tex-math><![CDATA[j^*]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msup><mml:mi>j</mml:mi><mml:mo>*</mml:mo></mml:msup></mml:math></alternatives></inline-formula>.
    Then, the next state <inline-formula><alternatives>
    <tex-math><![CDATA[J_N]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>J</mml:mi><mml:mi>N</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
    is sampled based on the discrete conditional probabilities
    <disp-formula><alternatives>
    <tex-math><![CDATA[
    p_{j|j^*,Z}= \frac{\widehat{\Pr} (J_N=j | J_C=j^*, Z(0)=Z) }{\sum_{j'=1}^{|K_{j^*}|} \widehat{\Pr} (J_N=j' | J_C=j^*, Z(0)=Z)}  \, ,
    ]]></tex-math>
    <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mo stretchy="false" form="prefix">|</mml:mo><mml:msup><mml:mi>j</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mo>,</mml:mo><mml:mi>Z</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mover><mml:mo>Pr</mml:mo><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>J</mml:mi><mml:mi>N</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false" form="prefix">|</mml:mo><mml:msub><mml:mi>J</mml:mi><mml:mi>C</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msup><mml:mi>j</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mo>,</mml:mo><mml:mi>Z</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>Z</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mi>′</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mo stretchy="true" form="prefix">|</mml:mo><mml:msub><mml:mi>K</mml:mi><mml:msup><mml:mi>j</mml:mi><mml:mo>*</mml:mo></mml:msup></mml:msub><mml:mo stretchy="true" form="postfix">|</mml:mo></mml:mrow></mml:munderover><mml:mover><mml:mo>Pr</mml:mo><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>J</mml:mi><mml:mi>N</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>j</mml:mi><mml:mi>′</mml:mi><mml:mo stretchy="false" form="prefix">|</mml:mo><mml:msub><mml:mi>J</mml:mi><mml:mi>C</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msup><mml:mi>j</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mo>,</mml:mo><mml:mi>Z</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>Z</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:mfrac><mml:mspace width="0.167em"></mml:mspace><mml:mo>,</mml:mo></mml:mrow></mml:math></alternatives></disp-formula>
    where <inline-formula><alternatives>
    <tex-math><![CDATA[j \in K_{j^*}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi>K</mml:mi><mml:msup><mml:mi>j</mml:mi><mml:mo>*</mml:mo></mml:msup></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>.
    Once we sampled the next state, denoted by
    <inline-formula><alternatives>
    <tex-math><![CDATA[j']]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>j</mml:mi><mml:mi>′</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>,
    the time to be spent at state <inline-formula><alternatives>
    <tex-math><![CDATA[j^*]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msup><mml:mi>j</mml:mi><mml:mo>*</mml:mo></mml:msup></mml:math></alternatives></inline-formula>
    is sampled based on <disp-formula><alternatives>
    <tex-math><![CDATA[
    \widehat{\Pr} (T\leq t| J_N=j', J_C=j^* , Z(0)=Z) \, .
    ]]></tex-math>
    <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mover><mml:mo>Pr</mml:mo><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>T</mml:mi><mml:mo>≤</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false" form="prefix">|</mml:mo><mml:msub><mml:mi>J</mml:mi><mml:mi>N</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>j</mml:mi><mml:mi>′</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>J</mml:mi><mml:mi>C</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msup><mml:mi>j</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mo>,</mml:mo><mml:mi>Z</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>Z</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mspace width="0.167em"></mml:mspace><mml:mi>.</mml:mi></mml:mrow></mml:math></alternatives></disp-formula>
    This is done by sampling <inline-formula><alternatives>
    <tex-math><![CDATA[U \sim Uniform[0,1]]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>U</mml:mi><mml:mo>∼</mml:mo><mml:mi>U</mml:mi><mml:mi>n</mml:mi><mml:mi>i</mml:mi><mml:mi>f</mml:mi><mml:mi>o</mml:mi><mml:mi>r</mml:mi><mml:mi>m</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>,
    equating <disp-formula><alternatives>
    <tex-math><![CDATA[
    U=\widehat{\Pr} (T\leq t| J_N=j', J_C=j^* , Z(0)=Z)
    ]]></tex-math>
    <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>U</mml:mi><mml:mo>=</mml:mo><mml:mover><mml:mo>Pr</mml:mo><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>T</mml:mi><mml:mo>≤</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false" form="prefix">|</mml:mo><mml:msub><mml:mi>J</mml:mi><mml:mi>N</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>j</mml:mi><mml:mi>′</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>J</mml:mi><mml:mi>C</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msup><mml:mi>j</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mo>,</mml:mo><mml:mi>Z</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>Z</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></disp-formula>
    and solving for <inline-formula><alternatives>
    <tex-math><![CDATA[t]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>t</mml:mi></mml:math></alternatives></inline-formula>.
    Denote the sampled time by <inline-formula><alternatives>
    <tex-math><![CDATA[t']]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>t</mml:mi><mml:mi>′</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
    and update <inline-formula><alternatives>
    <tex-math><![CDATA[Z(t')]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>Z</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>t</mml:mi><mml:mi>′</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>.
    In case <inline-formula><alternatives>
    <tex-math><![CDATA[j']]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>j</mml:mi><mml:mi>′</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
    is a terminal state, the sampling path ends here. Otherwise, the
    current state is updated to <inline-formula><alternatives>
    <tex-math><![CDATA[J_C=j']]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>J</mml:mi><mml:mi>C</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>j</mml:mi><mml:mi>′</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>,
    and the following state is sampled by <inline-formula><alternatives>
    <tex-math><![CDATA[p_{j|j',Z(t')}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mo stretchy="false" form="prefix">|</mml:mo><mml:mi>j</mml:mi><mml:mi>′</mml:mi><mml:mo>,</mml:mo><mml:mi>Z</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>t</mml:mi><mml:mi>′</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>,
    <inline-formula><alternatives>
    <tex-math><![CDATA[j=1 \in K_{j'}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>∈</mml:mo><mml:msub><mml:mi>K</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mi>′</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>,
    <disp-formula><tex-math><![CDATA[
    p_{j|j',Z}= \\
    \frac{\sum_{t'<t_m \leq \tau_{j',j}} \exp\left(\widehat\beta_{j',j}^T Z\right)\widehat\lambda_{0j',j}(t_m)\exp\left\{-\sum_{k=1}^{|K_{j'}|}\widehat\Lambda_{0j',k}(t_{m-1})\exp\left(\widehat\beta_{j',k}^T Z\right) \right\} }
    {\sum_{\widetilde{j}=1}^{|K_{j'}|} \sum_{t'<t_m \leq \tau_{j',\widetilde{j}}} \exp\left(\widehat\beta_{j',\widetilde{j}}^T Z\right) \widehat\lambda_{0j',\widetilde{j}}(t_m) \exp\left\{-\sum_{k=1}^{|K_{j'}|}\widehat\Lambda_{0j',k}(t_{m-1})\exp\left(\widehat\beta_{j',k}^T Z\right) \right\}} \, .
    ]]></tex-math></disp-formula></p>
  </sec>
  <sec id="generating-random-multistate-survival-data">
    <title>Generating Random Multistate Survival Data</title>
    <p><monospace>PyMSM</monospace> allows the user to pre-define a
    multi-state model. For example, for Cox models, the user should
    provide transition-specific baseline hazards, vectors of regression
    coefficients, and a time-varying covariates update function if
    needed. After providing this information, the user can then simulate
    trajectories, thus creating a new multi-state data-set which may be
    valuable for a variety of purposes.</p>
  </sec>
</sec>
<sec id="acknowledgemnts">
  <title>Acknowledgemnts</title>
  <p>This project is based on Roimi 2021. We thank Jonathan Somer, Asaf
  Ben Arie, Rom Gutman, Tomer Meir and Uri Shalit for their work on the
  model, R code and valuable discussions. The work was partially
  supported by the Israel Science Foundation (ISF) grant number 767/21
  and by a grant from the Tel Aviv University Center for AI and Data
  Science (TAD).</p>
</sec>
</body>
<back>
<ref-list>
  <ref id="ref-RoimiU003A2021">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Roimi</surname><given-names>Michael</given-names></name>
        <name><surname>Gutman</surname><given-names>Rom</given-names></name>
        <name><surname>Somer</surname><given-names>Jonathan</given-names></name>
        <name><surname>Arie</surname><given-names>Asaf Ben</given-names></name>
        <name><surname>Calman</surname><given-names>Ido</given-names></name>
        <name><surname>Bar-Lavie</surname><given-names>Yaron</given-names></name>
        <name><surname>Gelbshtein</surname><given-names>Udi</given-names></name>
        <name><surname>Liverant-Taub</surname><given-names>Sigal</given-names></name>
        <name><surname>Ziv</surname><given-names>Arnona</given-names></name>
        <name><surname>Eytan</surname><given-names>Danny</given-names></name>
        <name><surname>Gorfine</surname><given-names>Malka</given-names></name>
        <name><surname>Shalit</surname><given-names>Uri</given-names></name>
      </person-group>
      <article-title>Development and validation of a machine learning model predicting illness trajectory and hospital utilization of COVID-19 patients: A nationwide study</article-title>
      <source>Journal of the American Medical Informatics Association</source>
      <publisher-name>Oxford University Press (OUP)</publisher-name>
      <year iso-8601-date="2021-02">2021</year><month>02</month>
      <volume>28</volume>
      <issue>6</issue>
      <uri>https://doi.org/10.1093/jamia/ocab005</uri>
      <pub-id pub-id-type="doi">10.1093/jamia/ocab005</pub-id>
      <fpage>1188</fpage>
      <lpage>1196</lpage>
    </element-citation>
  </ref>
  <ref id="ref-RossmanU003A2021">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Rossman</surname><given-names>Hagai</given-names></name>
        <name><surname>Meir</surname><given-names>Tomer</given-names></name>
        <name><surname>Somer</surname><given-names>Jonathan</given-names></name>
        <name><surname>Shilo</surname><given-names>Smadar</given-names></name>
        <name><surname>Gutman</surname><given-names>Rom</given-names></name>
        <name><surname>Arie</surname><given-names>Asaf Ben</given-names></name>
        <name><surname>Segal</surname><given-names>Eran</given-names></name>
        <name><surname>Shalit</surname><given-names>Uri</given-names></name>
        <name><surname>Gorfine</surname><given-names>Malka</given-names></name>
      </person-group>
      <article-title>Hospital load and increased COVID-19 related mortality in israel</article-title>
      <source>Nature Communications</source>
      <publisher-name>Springer Science; Business Media LLC</publisher-name>
      <year iso-8601-date="2021-03">2021</year><month>03</month>
      <volume>12</volume>
      <issue>1</issue>
      <uri>https://doi.org/10.1038/s41467-021-22214-z</uri>
      <pub-id pub-id-type="doi">10.1038/s41467-021-22214-z</pub-id>
    </element-citation>
  </ref>
  <ref id="ref-IshwaranU003A2008">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Ishwaran</surname><given-names>Hemant</given-names></name>
        <name><surname>Kogalur</surname><given-names>Udaya B.</given-names></name>
        <name><surname>Blackstone</surname><given-names>Eugene H.</given-names></name>
        <name><surname>Lauer</surname><given-names>Michael S.</given-names></name>
      </person-group>
      <article-title>Random survival forests</article-title>
      <source>The Annals of Applied Statistics</source>
      <publisher-name>Institute of Mathematical Statistics</publisher-name>
      <year iso-8601-date="2008-09">2008</year><month>09</month>
      <volume>2</volume>
      <issue>3</issue>
      <uri>https://doi.org/10.1214/08-aoas169</uri>
      <pub-id pub-id-type="doi">10.1214/08-aoas169</pub-id>
    </element-citation>
  </ref>
  <ref id="ref-AndersenU003A1991">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Andersen</surname></name>
        <name><surname>Hansen</surname></name>
        <name><surname>Keiding</surname></name>
      </person-group>
      <article-title>Non-and semi-parametric estimation of transition probabilities from censored observation of a non-homogeneous markov process</article-title>
      <source>Scandinavian Journal of Statistics</source>
      <publisher-name>JSTOR</publisher-name>
      <year iso-8601-date="1991">1991</year>
      <volume>18</volume>
      <issue>2</issue>
      <uri>https://www.jstor.org/stable/4616198</uri>
      <fpage>153</fpage>
      <lpage>167</lpage>
    </element-citation>
  </ref>
  <ref id="ref-AndersenU003A1982">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Andersen</surname></name>
        <name><surname>Gill</surname></name>
      </person-group>
      <article-title>Cox’s regression model for counting processes: A large sample study</article-title>
      <source>The Annals of Statistics</source>
      <publisher-name>Institute of Mathematical Statistics</publisher-name>
      <year iso-8601-date="1982-12">1982</year><month>12</month>
      <volume>10</volume>
      <issue>4</issue>
      <uri>https://www.jstor.org/stable/2240714</uri>
      <pub-id pub-id-type="doi">10.1214/aos/1176345976</pub-id>
    </element-citation>
  </ref>
  <ref id="ref-KleinU003A2006">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Klein</surname><given-names>J. P.</given-names></name>
        <name><surname>Moeschberger</surname><given-names>M. L.</given-names></name>
      </person-group>
      <article-title>Survival analysis: Techniques for censored and truncated data</article-title>
      <publisher-name>Springer Science &amp; Business Media.</publisher-name>
      <year iso-8601-date="2006">2006</year>
      <uri>https://link.springer.com/book/10.1007/b97377</uri>
      <pub-id pub-id-type="doi">10.1111/j.1541-0420.2006.00589_9.x</pub-id>
    </element-citation>
  </ref>
  <ref id="ref-BreslowU003A1972">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Breslow</surname><given-names>N</given-names></name>
      </person-group>
      <article-title>Disussion of regression models and life-tables by cox, dr</article-title>
      <source>J. Roy. Statist. Assoc., B</source>
      <year iso-8601-date="1972">1972</year>
      <volume>34</volume>
      <fpage>216</fpage>
      <lpage>217</lpage>
    </element-citation>
  </ref>
  <ref id="ref-PölsterlU003A2020">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Pölsterl</surname><given-names>Sebastian</given-names></name>
      </person-group>
      <article-title>Scikit-survival: A library for time-to-event analysis built on top of scikit-learn</article-title>
      <source>Journal of Machine Learning Research</source>
      <year iso-8601-date="2020">2020</year>
      <volume>21</volume>
      <issue>212</issue>
      <uri>http://jmlr.org/papers/v21/20-729.html</uri>
      <fpage>1</fpage>
      <lpage>6</lpage>
    </element-citation>
  </ref>
  <ref id="ref-Davidson-PilonU003A2019">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Davidson-Pilon</surname><given-names>Cameron</given-names></name>
      </person-group>
      <article-title>Lifelines: Survival analysis in python</article-title>
      <source>Journal of Open Source Software</source>
      <publisher-name>The Open Journal</publisher-name>
      <year iso-8601-date="2019">2019</year>
      <volume>4</volume>
      <issue>40</issue>
      <uri>https://doi.org/10.21105/joss.01317</uri>
      <pub-id pub-id-type="doi">10.21105/joss.01317</pub-id>
      <fpage>1317</fpage>
      <lpage></lpage>
    </element-citation>
  </ref>
</ref-list>
</back>
</article>
