<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN"
                  "JATS-publishing1.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" dtd-version="1.2" article-type="other">
<front>
<journal-meta>
<journal-id></journal-id>
<journal-title-group>
<journal-title>Journal of Open Source Software</journal-title>
<abbrev-journal-title>JOSS</abbrev-journal-title>
</journal-title-group>
<issn publication-format="electronic">2475-9066</issn>
<publisher>
<publisher-name>Open Journals</publisher-name>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="publisher-id">6049</article-id>
<article-id pub-id-type="doi">10.21105/joss.06049</article-id>
<title-group>
<article-title>mathlib: A Scala package for readable, verifiable and
sustainable simulations of formal theory</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author">
<contrib-id contrib-id-type="orcid">https://orcid.org/0000-0002-1522-0343</contrib-id>
<name>
<surname>Blokpoel</surname>
<given-names>Mark</given-names>
</name>
<xref ref-type="aff" rid="aff-1"/>
</contrib>
<aff id="aff-1">
<institution-wrap>
<institution>Donders Institute for Brain, Cognition, and Behaviour,
Radboud University, The Netherlands</institution>
</institution-wrap>
</aff>
</contrib-group>
<pub-date date-type="pub" publication-format="electronic" iso-8601-date="2023-08-23">
<day>23</day>
<month>8</month>
<year>2023</year>
</pub-date>
<volume>9</volume>
<issue>99</issue>
<fpage>6049</fpage>
<permissions>
<copyright-statement>Authors of papers retain copyright and release the
work under a Creative Commons Attribution 4.0 International License (CC
BY 4.0)</copyright-statement>
<copyright-year>2022</copyright-year>
<copyright-holder>The article authors</copyright-holder>
<license license-type="open-access" xlink:href="https://creativecommons.org/licenses/by/4.0/">
<license-p>Authors of papers retain copyright and release the work under
a Creative Commons Attribution 4.0 International License (CC BY
4.0)</license-p>
</license>
</permissions>
<kwd-group kwd-group-type="author">
<kwd>psychology</kwd>
<kwd>cognitive science</kwd>
<kwd>simulations</kwd>
<kwd>formal theory</kwd>
<kwd>computational modeling</kwd>
<kwd>Scala</kwd>
</kwd-group>
</article-meta>
</front>
<body>
<sec id="summary">
  <title>Summary</title>
  <p>Formal theory and computational modeling are critical in cognitive
  science and psychology. Formal systems (e.g., set theory, functions,
  first-order logic, graph theory) allow scientists to ‚Äòconceptually
  analyze, specify, and formalize intuitions that otherwise remain
  unexamined‚Äô
  (<xref alt="Guest &amp; Martin, 2021" rid="ref-guest_martinU003A2021" ref-type="bibr">Guest
  &amp; Martin, 2021</xref>). They make otherwise underspecified
  theories precise and open for critical reflection
  (<xref alt="van Rooij &amp; Baggio, 2021" rid="ref-vanrooij_baggioU003A2021" ref-type="bibr">van
  Rooij &amp; Baggio, 2021</xref>). A theory can be formally specified
  in a computational model using mathematical concepts such as set
  theory, graph theory, and probability theory. The specification is
  often followed by analysis to understand precisely what assumptions
  and consequences the formal theory entails. An important method of
  analysis is computer simulation, which allows scientists to explore
  complex model behaviours and derive predictions that otherwise cannot
  be analytically derived<xref ref-type="fn" rid="fn1">1</xref>.</p>
  <p><monospace>mathlib</monospace> is a library for Scala
  (<xref alt="Odersky, 2008" rid="ref-oderskyU003A2008" ref-type="bibr">Odersky,
  2008</xref>) supporting functional programming that resembles
  mathematical expressions such as set theory and graph theory. This
  library was developed to complement the theory development method
  outlined in the open education book Theoretical modeling for cognitive
  science and psychology by Blokpoel &amp; van Rooij
  (<xref alt="2021" rid="ref-blokpoel_vanrooijU003A2021" ref-type="bibr">2021</xref>).
  To date <monospace>mathlib</monospace> is the only library that
  facilitates implementing computational-level simulations for fully
  specified formal theories.</p>
  <p>The goal of this library is to help users to implement simulations
  of their formal theories. Code written in Scala using
  <monospace>mathlib</monospace> is:</p>
  <list list-type="bullet">
    <list-item>
      <p>easy to <bold>read</bold>, because
      <monospace>mathlib</monospace> syntax closely resembles
      mathematical notation</p>
    </list-item>
    <list-item>
      <p>easy to <bold>verify</bold>, by proving that the code exactly
      implements the theoretical model (or not)</p>
    </list-item>
    <list-item>
      <p>easy to <bold>sustain</bold>, as older versions of Scala and
      <monospace>mathlib</monospace> can easily be run on newer
      machines</p>
    </list-item>
  </list>
</sec>
<sec id="statement-of-need">
  <title>Statement of need</title>
  <p><monospace>mathlib</monospace> supports scholars in writing
  <bold>readable</bold> and <bold>verifiable</bold> code. Writing code
  is not easy, writing code for which we can know that it computes what
  the specification (i.e., the formal theory) states is even harder.
  Given the critical role of theory and computer simulations in
  cognitive science, it is important that scholars can verify that the
  code does what the authors intend it to do. This can be facilitated by
  having a programming language where the syntax and semantics closely
  matches that of the specification. Since formal theories are specified
  using mathematical notation
  (<xref alt="Blokpoel &amp; van Rooij, 2021" rid="ref-blokpoel_vanrooijU003A2021" ref-type="bibr">Blokpoel
  &amp; van Rooij, 2021</xref>;
  <xref alt="Guest &amp; Martin, 2021" rid="ref-guest_martinU003A2021" ref-type="bibr">Guest
  &amp; Martin, 2021</xref>;
  <xref alt="Marr, 1982" rid="ref-marrU003A1982" ref-type="bibr">Marr,
  1982</xref>), functional programming languages bring a lot to the
  table in terms of syntactic and semantic resemblance to mathematical
  concepts and notation. <monospace>mathlib</monospace> adds
  mathematical concepts and notation to the functional programming
  language Scala
  (<xref alt="Odersky, 2008" rid="ref-oderskyU003A2008" ref-type="bibr">Odersky,
  2008</xref>). At the time of writing, the current version (0.9.1)
  supports set theory and graph theory. To appreciate the readability of
  functional code, relative to the formal specification, consider the
  following two code snippets. Both implement the same mathematical
  expression <inline-formula><alternatives>
  <tex-math><![CDATA[\arg\max_{a\in A}f(a)]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo>arg</mml:mo><mml:msub><mml:mo>max</mml:mo><mml:mrow><mml:mi>a</mml:mi><mml:mo>‚àà</mml:mo><mml:mi>A</mml:mi></mml:mrow></mml:msub><mml:mi>f</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>,
  where <inline-formula><alternatives>
  <tex-math><![CDATA[A]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>A</mml:mi></mml:math></alternatives></inline-formula>
  is a set of strings and <inline-formula><alternatives>
  <tex-math><![CDATA[f(.)]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>f</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>.</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
  counts the length of each string. In both snippets the set
  <inline-formula><alternatives>
  <tex-math><![CDATA[A]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>A</mml:mi></mml:math></alternatives></inline-formula>
  is translated to <monospace>words</monospace> to comply with default
  Scala style. A non-functional implementation could look like this,
  where semantics (i.e., the meaning or function of the code) is more
  difficult to analyze due to its use of mutable variables and a
  loop.</p>
  <code language="scala">def f(a: String): Int = a.length

def expression(words: Set[String]): String = {
  var maxLength: Int = 0
  var longestWord: String = &quot;&quot;
  for(word &lt;- words) {
    if(f(word) &gt; maxLength) {
      maxLength = f(word)
      longestWord = word
    }
  }
  longestWord
}

expression(Set(&quot;a&quot;, &quot;aa&quot;))</code>
  <p>A functional implementation leveraging
  <monospace>mathlib</monospace> can look like this, which closely
  resembles the mathematical expression in form and function.</p>
  <code language="scala">def f(a: String): Int = a.length

def expression(words: Set[String]): String = {
  argMax(words, f _)
    .random.get
}

expression(Set(&quot;a&quot;, &quot;aa&quot;))</code>
  <p>In the next section, we provide two concrete examples to illustrate
  how Scala and <monospace>mathlib</monospace> make code more accessible
  to verify the relationship between simulation and theory.</p>
  <p><monospace>mathlib</monospace> and Scala support scholars in
  writing <bold>sustainable</bold> code. It is important that academic
  contributions remain accessible for reflection and critique. This
  includes simulations that also have theoretical import. Simulation
  results may need to be verified or future scholars may wish to expand
  upon the work. It is not sufficient to archive code, because in
  practice programming contributions in academia are easily lost because
  of incompatibility issues between older software and newer operating
  systems. Scala (and consequently <monospace>mathlib</monospace>) runs
  on the Java Virtual Machine (JVM) and has state-of-the-art versioning.
  The programmer can specify exactly which version of Scala and
  <monospace>mathlib</monospace> needs to be retrieved to run the code
  on any system that supports the JVM. Even when newer versions of Scala
  or <monospace>mathlib</monospace> may potentially break older code,
  this versioning system allows future users to easily run, adapt or
  expand older code.</p>
  <p><monospace>mathlib</monospace> is unique because its design
  encourages the computational cognitive scientist to write readable,
  verifiable, and sustainable code for simulations of formal theories.
  This is not to say that one cannot apply these principles in other
  languages, but it may require building the mathematical infrastructure
  that <monospace>mathlib</monospace> supports.
  <monospace>mathlib</monospace> differs from other libraries in that it
  focuses on usability and transparency for simulations of formal
  theories specifically, whereas other libraries that implement similar
  functionality focus on computational expressiveness and
  efficiency.</p>
</sec>
<sec id="illustrations">
  <title>Illustrations</title>
  <p>We present two illustrations to show the relationship between
  simulations implemented in Scala and <monospace>mathlib</monospace>
  and formal theories.</p>
  <sec id="illustration-1-subset-choice">
    <title>Illustration 1: Subset choice</title>
    <p>The following formal theory is taken from the textbook by
    Blokpoel &amp; van Rooij
    (<xref alt="2021" rid="ref-blokpoel_vanrooijU003A2021" ref-type="bibr">2021</xref>).
    It specifies people‚Äôs capacity to select a subset of items, given
    the value of individual items and pairs. For more details on this
    topic, see Chapter 4 of the textbook.</p>
    <p><sc>Subset choice</sc></p>
    <p><italic>Input:</italic> A set of items
    <inline-formula><alternatives>
    <tex-math><![CDATA[I]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>I</mml:mi></mml:math></alternatives></inline-formula>,
    a value function for single items <inline-formula><alternatives>
    <tex-math><![CDATA[v:I\rightarrow \mathbb{Z}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>v</mml:mi><mml:mo>:</mml:mo><mml:mi>I</mml:mi><mml:mo>‚Üí</mml:mo><mml:mi>‚Ñ§</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
    and a binary value function for pairs of items
    <inline-formula><alternatives>
    <tex-math><![CDATA[b:I \times I \rightarrow \mathbb{Z}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>b</mml:mi><mml:mo>:</mml:mo><mml:mi>I</mml:mi><mml:mo>√ó</mml:mo><mml:mi>I</mml:mi><mml:mo>‚Üí</mml:mo><mml:mi>‚Ñ§</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>.</p>
    <p><italic>Output:</italic> A subset of items
    <inline-formula><alternatives>
    <tex-math><![CDATA[I'\subseteq I]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>I</mml:mi><mml:mi>‚Ä≤</mml:mi><mml:mo>‚äÜ</mml:mo><mml:mi>I</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
    (or <inline-formula><alternatives>
    <tex-math><![CDATA[I'\in\mathcal{P}(I)]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>I</mml:mi><mml:mi>‚Ä≤</mml:mi><mml:mo>‚àà</mml:mo><mml:mi>ùí´</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>I</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>)
    that maximizes the combined value of the selected items accordingly,
    i.e., <inline-formula><alternatives>
    <tex-math><![CDATA[\arg\max_{I'\in\mathcal{P}(I)}\sum_{i \in I'}v(i) + \sum_{i, j \in I'}b(i,j)]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo>arg</mml:mo><mml:msub><mml:mo>max</mml:mo><mml:mrow><mml:mi>I</mml:mi><mml:mi>‚Ä≤</mml:mi><mml:mo>‚àà</mml:mo><mml:mi>ùí´</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>I</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:msub><mml:msub><mml:mo>‚àë</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>‚àà</mml:mo><mml:mi>I</mml:mi><mml:mi>‚Ä≤</mml:mi></mml:mrow></mml:msub><mml:mi>v</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:msub><mml:mo>‚àë</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>‚àà</mml:mo><mml:mi>I</mml:mi><mml:mi>‚Ä≤</mml:mi></mml:mrow></mml:msub><mml:mi>b</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>.</p>
    <p>Assuming familiarity with the formal theory, the
    <monospace>mathlib</monospace> implementation and Table
    <xref alt="1" rid="tabU003Asubset">1</xref> below illustrate how to
    interpret and verify the code relative to the mathematical
    expressions in the formal theory. In this code illustration, the
    following functionality is provided by
    <monospace>mathlib</monospace>: <monospace>sum(., .)</monospace>,
    <monospace>argMax(., .)</monospace> and
    <monospace>powerset(.)</monospace>. A demo of this code can be found
    in <monospace>mathlib.demos.SubsetChoice</monospace>.</p>
    <code language="scala">type Item = String

def subsetChoice(
                  items: Set[Item],
                  v: Item =&gt; Double,
                  b: (Item, Item) =&gt; Double
                ): Set[Item] = {

  def value(subset: Set[Item]): Double =
    sum(subset, v) + sum(subset.uniquePairs, b)

  val allOptimalSolutions = argMax(powerset(items), value)
  allOptimalSolutions.random.get
}</code>
    <table-wrap>
      <caption>
        <p>Mappings between formal expression and
        <monospace>mathlib</monospace> implementation.
        <styled-content id="tabU003Asubset"></styled-content></p>
      </caption>
      <table>
        <colgroup>
          <col width="24%" />
          <col width="76%" />
        </colgroup>
        <thead>
          <tr>
            <th>Formal expression</th>
            <th><monospace>mathlib</monospace> implementation and
            description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>n.a.</td>
            <td><monospace>Item</monospace></td>
          </tr>
          <tr>
            <td></td>
            <td><italic>Custom type for items.</italic></td>
          </tr>
          <tr>
            <td><inline-formula><alternatives>
            <tex-math><![CDATA[I]]></tex-math>
            <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>I</mml:mi></mml:math></alternatives></inline-formula></td>
            <td><monospace>items: Set[Item]</monospace></td>
          </tr>
          <tr>
            <td></td>
            <td><italic>A set of items.</italic></td>
          </tr>
          <tr>
            <td><inline-formula><alternatives>
            <tex-math><![CDATA[v:I\rightarrow \mathbb{Z}]]></tex-math>
            <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>v</mml:mi><mml:mo>:</mml:mo><mml:mi>I</mml:mi><mml:mo>‚Üí</mml:mo><mml:mi>‚Ñ§</mml:mi></mml:mrow></mml:math></alternatives></inline-formula></td>
            <td><monospace>v: (Item =&gt; Double)</monospace></td>
          </tr>
          <tr>
            <td></td>
            <td><italic>Value function for single items.</italic></td>
          </tr>
          <tr>
            <td><inline-formula><alternatives>
            <tex-math><![CDATA[b:I \times I \rightarrow \mathbb{Z}]]></tex-math>
            <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>b</mml:mi><mml:mo>:</mml:mo><mml:mi>I</mml:mi><mml:mo>√ó</mml:mo><mml:mi>I</mml:mi><mml:mo>‚Üí</mml:mo><mml:mi>‚Ñ§</mml:mi></mml:mrow></mml:math></alternatives></inline-formula></td>
            <td><monospace>b: ((Item, Item) =&gt; Double)</monospace></td>
          </tr>
          <tr>
            <td></td>
            <td><italic>Value function for pairs of items.</italic></td>
          </tr>
          <tr>
            <td>n.a.</td>
            <td><monospace>def value(subset: Set[Item]): Double</monospace></td>
          </tr>
          <tr>
            <td></td>
            <td><italic>Function wrapper for the combined value of a
            subset.</italic></td>
          </tr>
          <tr>
            <td><inline-formula><alternatives>
            <tex-math><![CDATA[\sum_{i \in I'}v(i)]]></tex-math>
            <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mo>‚àë</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>‚àà</mml:mo><mml:mi>I</mml:mi><mml:mi>‚Ä≤</mml:mi></mml:mrow></mml:msub><mml:mi>v</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula></td>
            <td><monospace>sum(subset, v)</monospace></td>
          </tr>
          <tr>
            <td></td>
            <td><italic>Sum of single item values, where
            <monospace>subset</monospace> is
            <inline-formula><alternatives>
            <tex-math><![CDATA[I']]></tex-math>
            <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>I</mml:mi><mml:mi>‚Ä≤</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>.</italic></td>
          </tr>
          <tr>
            <td><inline-formula><alternatives>
            <tex-math><![CDATA[\sum_{i, j \in I'}b(i,j)]]></tex-math>
            <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mo>‚àë</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>‚àà</mml:mo><mml:mi>I</mml:mi><mml:mi>‚Ä≤</mml:mi></mml:mrow></mml:msub><mml:mi>b</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula></td>
            <td><monospace>sum(subset.uniquePairs, b)</monospace></td>
          </tr>
          <tr>
            <td></td>
            <td><italic>Sum of pair-wise item values, where
            <monospace>uniquePairs</monospace> generates all pairs
            <monospace>(x, y)</monospace> in
            <monospace>subset</monospace> with
            <monospace>x!=y</monospace>.</italic></td>
          </tr>
          <tr>
            <td><inline-formula><alternatives>
            <tex-math><![CDATA[\arg\max_{I'\in\mathcal{P}(I)}\dots]]></tex-math>
            <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo>arg</mml:mo><mml:msub><mml:mo>max</mml:mo><mml:mrow><mml:mi>I</mml:mi><mml:mi>‚Ä≤</mml:mi><mml:mo>‚àà</mml:mo><mml:mi>ùí´</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>I</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:msub><mml:mi>‚Ä¶</mml:mi></mml:mrow></mml:math></alternatives></inline-formula></td>
            <td><monospace>argMax(powerset(items), value)</monospace></td>
          </tr>
          <tr>
            <td></td>
            <td>Returns the element from the powerset of items that
            maximizes <monospace>value</monospace>.</td>
          </tr>
        </tbody>
      </table>
    </table-wrap>
  </sec>
  <sec id="illustration-2-coherence">
    <title>Illustration 2: Coherence</title>
    <p>Coherence theory
    (<xref alt="Thagard &amp; Verbeurgt, 1998" rid="ref-thagardU003A1998" ref-type="bibr">Thagard
    &amp; Verbeurgt, 1998</xref>) aims to explain people‚Äôs capacity to
    infer a consistent set of beliefs given constraints between them.
    For example, the belief ‚Äòit rains‚Äô may have a negative constraint
    with ‚Äòwearing shorts‚Äô. To believe that it rains and not wearing
    shorts is consistent, but to believe that it rains and to wear
    shorts is inconsistent. In case of consistency, the constraint is
    said to be <italic>satisfied</italic>. Coherence theory conjectures
    that people infer truth-values for their beliefs so as to maximize
    the sum of weights of all satisfied constraints. For a more detailed
    introduction to Coherence theory, see
    (<xref alt="Thagard &amp; Verbeurgt, 1998" rid="ref-thagardU003A1998" ref-type="bibr">Thagard
    &amp; Verbeurgt, 1998</xref>) and Chapter 5 in
    (<xref alt="Blokpoel &amp; van Rooij, 2021" rid="ref-blokpoel_vanrooijU003A2021" ref-type="bibr">Blokpoel
    &amp; van Rooij, 2021</xref>)</p>
    <p><sc>Coherence</sc></p>
    <p><italic>Input:</italic> A graph <inline-formula><alternatives>
    <tex-math><![CDATA[G=(V,E)]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>G</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
    with vertex set <inline-formula><alternatives>
    <tex-math><![CDATA[V]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>V</mml:mi></mml:math></alternatives></inline-formula>
    and edge set <inline-formula><alternatives>
    <tex-math><![CDATA[E\subseteq V\times V]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>E</mml:mi><mml:mo>‚äÜ</mml:mo><mml:mi>V</mml:mi><mml:mo>√ó</mml:mo><mml:mi>V</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
    that partitions into positive constraints
    <inline-formula><alternatives>
    <tex-math><![CDATA[C^+]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msup><mml:mi>C</mml:mi><mml:mo>+</mml:mo></mml:msup></mml:math></alternatives></inline-formula>
    and negative constraints <inline-formula><alternatives>
    <tex-math><![CDATA[C^-]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msup><mml:mi>C</mml:mi><mml:mo>‚àí</mml:mo></mml:msup></mml:math></alternatives></inline-formula>
    (i.e., <inline-formula><alternatives>
    <tex-math><![CDATA[C^+\cup C^-=E]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msup><mml:mi>C</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo>‚à™</mml:mo><mml:msup><mml:mi>C</mml:mi><mml:mo>‚àí</mml:mo></mml:msup><mml:mo>=</mml:mo><mml:mi>E</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
    and <inline-formula><alternatives>
    <tex-math><![CDATA[C^+\cap C^-=\varnothing]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msup><mml:mi>C</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo>‚à©</mml:mo><mml:msup><mml:mi>C</mml:mi><mml:mo>‚àí</mml:mo></mml:msup><mml:mo>=</mml:mo><mml:mi>‚åÄ</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>)
    and a weight function <inline-formula><alternatives>
    <tex-math><![CDATA[w: E \rightarrow \mathbb{R}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>w</mml:mi><mml:mo>:</mml:mo><mml:mi>E</mml:mi><mml:mo>‚Üí</mml:mo><mml:mi>‚Ñù</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>.</p>
    <p><italic>Output:</italic> A truth value assignment
    <inline-formula><alternatives>
    <tex-math><![CDATA[T:V \rightarrow \{true, false\}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>T</mml:mi><mml:mo>:</mml:mo><mml:mi>V</mml:mi><mml:mo>‚Üí</mml:mo><mml:mo stretchy="false" form="prefix">{</mml:mo><mml:mi>t</mml:mi><mml:mi>r</mml:mi><mml:mi>u</mml:mi><mml:mi>e</mml:mi><mml:mo>,</mml:mo><mml:mi>f</mml:mi><mml:mi>a</mml:mi><mml:mi>l</mml:mi><mml:mi>s</mml:mi><mml:mi>e</mml:mi><mml:mo stretchy="false" form="postfix">}</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>
    such that <inline-formula><alternatives>
    <tex-math><![CDATA[Coh(T)=Coh^+(T)+Coh^-(T)]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>C</mml:mi><mml:mi>o</mml:mi><mml:mi>h</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>C</mml:mi><mml:mi>o</mml:mi><mml:msup><mml:mi>h</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>C</mml:mi><mml:mi>o</mml:mi><mml:msup><mml:mi>h</mml:mi><mml:mo>‚àí</mml:mo></mml:msup><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
    is maximum. Here, <disp-formula><alternatives>
    <tex-math><![CDATA[
    Coh^+(T)=\displaystyle\sum_{(u,v)\in C^+}
    \begin{cases}
    w((u,v))\text{ if }T(u) = T(v)\\
    0\text{ otherwise}
    \end{cases}
    ]]></tex-math>
    <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>C</mml:mi><mml:mi>o</mml:mi><mml:msup><mml:mi>h</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:munder><mml:mo>‚àë</mml:mo><mml:mrow><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>‚àà</mml:mo><mml:msup><mml:mi>C</mml:mi><mml:mo>+</mml:mo></mml:msup></mml:mrow></mml:munder><mml:mrow><mml:mo stretchy="true" form="prefix">{</mml:mo><mml:mtable><mml:mtr><mml:mtd columnalign="left" style="text-align: left"><mml:mi>w</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mrow><mml:mspace width="0.333em"></mml:mspace><mml:mtext mathvariant="normal"> if </mml:mtext><mml:mspace width="0.333em"></mml:mspace></mml:mrow><mml:mi>T</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left" style="text-align: left"><mml:mn>0</mml:mn><mml:mrow><mml:mspace width="0.333em"></mml:mspace><mml:mtext mathvariant="normal"> otherwise</mml:mtext></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:math></alternatives></disp-formula>
    and <disp-formula><alternatives>
    <tex-math><![CDATA[
    Coh^-(T)=\displaystyle\sum_{(u,v)\in C^-}
    \begin{cases}
    w((u,v))\text{ if }T(u) \ne T(v)\\
    0\text{ otherwise}
    \end{cases}
    ]]></tex-math>
    <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>C</mml:mi><mml:mi>o</mml:mi><mml:msup><mml:mi>h</mml:mi><mml:mo>‚àí</mml:mo></mml:msup><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:munder><mml:mo>‚àë</mml:mo><mml:mrow><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>‚àà</mml:mo><mml:msup><mml:mi>C</mml:mi><mml:mo>‚àí</mml:mo></mml:msup></mml:mrow></mml:munder><mml:mrow><mml:mo stretchy="true" form="prefix">{</mml:mo><mml:mtable><mml:mtr><mml:mtd columnalign="left" style="text-align: left"><mml:mi>w</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mrow><mml:mspace width="0.333em"></mml:mspace><mml:mtext mathvariant="normal"> if </mml:mtext><mml:mspace width="0.333em"></mml:mspace></mml:mrow><mml:mi>T</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>‚â†</mml:mo><mml:mi>T</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left" style="text-align: left"><mml:mn>0</mml:mn><mml:mrow><mml:mspace width="0.333em"></mml:mspace><mml:mtext mathvariant="normal"> otherwise</mml:mtext></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:math></alternatives></disp-formula></p>
    <p>Assuming familiarity with the formal theory, the
    <monospace>mathlib</monospace> implementation and Table
    <xref alt="2" rid="tabU003Acoherence">2</xref> below illustrate how
    to interpret and verify the code relative to the mathematical
    expressions in the formal theory. In this code illustration, the
    following functionality is provided by
    <monospace>mathlib</monospace>: <monospace>WUnDiGraph</monospace>,
    <monospace>WUnDiEdge</monospace>, <monospace>Node</monospace>,
    <monospace>sum(., .)</monospace> and
    <monospace>allMappings(.)</monospace>. A demo of this code can be
    found in <monospace>mathlib.demos.Coherence</monospace>.</p>
    <code language="scala">def coherence(
               network: WUnDiGraph[String],
               positiveConstraints: Set[WUnDiEdge[Node[String]]]
             ): Map[Node[String], Boolean] = {
  val negativeConstraints: Set[WUnDiEdge[Node[String]]] =
    network.edges \ positiveConstraints

  def cohPlus(assignment: Map[Node[String], Boolean]): Double = {
    def isSatisfied(pc: WUnDiEdge[Node[String]]): Double =
      if (assignment(pc.left) == assignment(pc.right)) pc.weight
      else 0.0

    sum(positiveConstraints, isSatisfied _)
  }

  def cohMinus(assignment: Map[Node[String], Boolean]): Double = {
    def isSatisfied(pc: WUnDiEdge[Node[String]]): Double =
      if (assignment(pc.left) != assignment(pc.right)) pc.weight
      else 0.0

    sum(negativeConstraints, isSatisfied _)
  }

  def coh(assignment: Map[Node[String], Boolean]): Double =
    cohPlus(assignment) + cohMinus(assignment)

  val allPossibleTruthValueAssignments =
    network.vertices.allMappings(Set(true, false))
  val optimalSolutions =
    argMax(allPossibleTruthValueAssignments, coh)
  optimalSolutions.random.get
}</code>
    <table-wrap>
      <caption>
        <p>Mappings between formal expression and
        <monospace>mathlib</monospace> implementation.
        <styled-content id="tabU003Acoherence"></styled-content></p>
      </caption>
      <table>
        <colgroup>
          <col width="21%" />
          <col width="79%" />
        </colgroup>
        <thead>
          <tr>
            <th>Formal expression</th>
            <th><monospace>mathlib</monospace> implementation and
            description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><inline-formula><alternatives>
            <tex-math><![CDATA[G]]></tex-math>
            <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>G</mml:mi></mml:math></alternatives></inline-formula></td>
            <td><monospace>network: WUnDiGraph[String]</monospace></td>
          </tr>
          <tr>
            <td></td>
            <td><italic>Undirected weighted graph with
            labels.</italic></td>
          </tr>
          <tr>
            <td><inline-formula><alternatives>
            <tex-math><![CDATA[C^+]]></tex-math>
            <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msup><mml:mi>C</mml:mi><mml:mo>+</mml:mo></mml:msup></mml:math></alternatives></inline-formula></td>
            <td><monospace>positiveConstraints: Set[WUnDiEdge[Node[String]]]</monospace></td>
          </tr>
          <tr>
            <td></td>
            <td><italic>Set of positive constraints as weighted
            edges.</italic></td>
          </tr>
          <tr>
            <td><inline-formula><alternatives>
            <tex-math><![CDATA[C^-]]></tex-math>
            <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msup><mml:mi>C</mml:mi><mml:mo>‚àí</mml:mo></mml:msup></mml:math></alternatives></inline-formula></td>
            <td><monospace>negativeConstraints: Set[WUnDiEdge[Node[String]]]</monospace></td>
          </tr>
          <tr>
            <td></td>
            <td><italic>Set of negative constraints, computed by
            subtracting the positive constraints from all edges
            in</italic>
            <monospace>network</monospace><italic>.</italic></td>
          </tr>
          <tr>
            <td><inline-formula><alternatives>
            <tex-math><![CDATA[w]]></tex-math>
            <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>w</mml:mi></mml:math></alternatives></inline-formula></td>
            <td><italic>Weights are represented not by an explicit
            function, but by a weighted graph.</italic></td>
          </tr>
          <tr>
            <td><inline-formula><alternatives>
            <tex-math><![CDATA[T:V\rightarrow \{true, false\}]]></tex-math>
            <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>T</mml:mi><mml:mo>:</mml:mo><mml:mi>V</mml:mi><mml:mo>‚Üí</mml:mo><mml:mo stretchy="false" form="prefix">{</mml:mo><mml:mi>t</mml:mi><mml:mi>r</mml:mi><mml:mi>u</mml:mi><mml:mi>e</mml:mi><mml:mo>,</mml:mo><mml:mi>f</mml:mi><mml:mi>a</mml:mi><mml:mi>l</mml:mi><mml:mi>s</mml:mi><mml:mi>e</mml:mi><mml:mo stretchy="false" form="postfix">}</mml:mo></mml:mrow></mml:math></alternatives></inline-formula></td>
            <td><monospace>allPossibleTruthValueAssignments</monospace></td>
          </tr>
          <tr>
            <td></td>
            <td><italic>The truth value assignments are explicitly
            listed by generating all mappings between vertices
            and</italic>
            <monospace>Set(true, false)</monospace><italic>.</italic></td>
          </tr>
          <tr>
            <td><inline-formula><alternatives>
            <tex-math><![CDATA[Coh^+(T)]]></tex-math>
            <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>C</mml:mi><mml:mi>o</mml:mi><mml:msup><mml:mi>h</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula></td>
            <td><monospace>cohPlus(assignment: Map[Node[String], Boolean]): Double</monospace></td>
          </tr>
          <tr>
            <td></td>
            <td><italic>Returns the sum of weights of all satisfied
            positive constraints.</italic></td>
          </tr>
          <tr>
            <td><inline-formula><alternatives>
            <tex-math><![CDATA[Coh^-(T)]]></tex-math>
            <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>C</mml:mi><mml:mi>o</mml:mi><mml:msup><mml:mi>h</mml:mi><mml:mo>‚àí</mml:mo></mml:msup><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula></td>
            <td><monospace>cohMinus(assignment: Map[Node[String], Boolean]): Double</monospace></td>
          </tr>
          <tr>
            <td></td>
            <td><italic>Returns the sum of weights of all satisfied
            negative constraints.</italic></td>
          </tr>
          <tr>
            <td><inline-formula><alternatives>
            <tex-math><![CDATA[Coh(T)]]></tex-math>
            <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>C</mml:mi><mml:mi>o</mml:mi><mml:mi>h</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula></td>
            <td><monospace>coh(assignment: Map[Node[String], Boolean]): Double</monospace></td>
          </tr>
          <tr>
            <td></td>
            <td><italic>Returns the sum of weights of all satisfied
            constraints.</italic></td>
          </tr>
          <tr>
            <td>n.a.</td>
            <td><monospace>optimalSolutions</monospace></td>
          </tr>
          <tr>
            <td></td>
            <td><italic>Compute all truth value assignments with maximum
            coherence.</italic></td>
          </tr>
          <tr>
            <td>n.a.</td>
            <td><monospace>optimalSolutions.random.get</monospace></td>
          </tr>
          <tr>
            <td></td>
            <td><italic>The formal specification is met when any maximum
            truth value assignment is returned, so we return a random
            maximum one.</italic></td>
          </tr>
        </tbody>
      </table>
    </table-wrap>
  </sec>
</sec>
<sec id="resources">
  <title>Resources</title>
  <list list-type="bullet">
    <list-item>
      <p>Github repository:
      <ext-link ext-link-type="uri" xlink:href="https://github.com/markblokpoel/mathlib">https://github.com/markblokpoel/mathlib</ext-link></p>
    </list-item>
    <list-item>
      <p>Website:
      <ext-link ext-link-type="uri" xlink:href="https://markblokpoel.github.io/mathlib">https://markblokpoel.github.io/mathlib</ext-link></p>
    </list-item>
    <list-item>
      <p>Scaladoc:
      <ext-link ext-link-type="uri" xlink:href="https://markblokpoel.github.io/mathlib/scaladoc">https://markblokpoel.github.io/mathlib/scaladoc</ext-link></p>
    </list-item>
  </list>
</sec>
<sec id="acknowledgements">
  <title>Acknowledgements</title>
  <p>We thank the Computational Cognitive Science group at the Donders
  Center for Cognition (Nijmegen, The Netherlands) for useful
  discussions and feedback, in particular, Laura van de Braak, Olivia
  Guest, and Iris van Rooij. We also thank the reviewers Larkin Liu,
  Russel Richie, and Stephen Mann and the editor Daniel Katz for their
  useful feedback which has greatly improved this paper.</p>
  <p>This project was supported by Netherlands Organization for
  Scientific Research Gravitation Grant of the Language in Interaction
  consortium 024.001.006, the Radboud School for Artificial
  Intelligence, and the Donders Institute, Donders Center for
  Cognition.</p>
</sec>
</body>
<back>
<ref-list>
  <title></title>
  <ref id="ref-blokpoel_vanrooijU003A2021">
    <element-citation publication-type="book">
      <person-group person-group-type="author">
        <name><surname>Blokpoel</surname><given-names>M.</given-names></name>
        <name><surname>van Rooij</surname><given-names>I.</given-names></name>
      </person-group>
      <source>Theoretical modeling for cognitive science and psychology</source>
      <year iso-8601-date="2021">2021</year>
      <uri>https://computationalcognitivescience.github.io/lovelace/</uri>
    </element-citation>
  </ref>
  <ref id="ref-guest_martinU003A2021">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Guest</surname><given-names>O.</given-names></name>
        <name><surname>Martin</surname><given-names>A. E.</given-names></name>
      </person-group>
      <article-title>How computational modeling can force theory building in psychological science</article-title>
      <source>Perspectives on Psychological Science</source>
      <year iso-8601-date="2021">2021</year>
      <volume>16</volume>
      <uri>https://journals.sagepub.com/doi/full/10.1177/1745691620970585</uri>
      <pub-id pub-id-type="doi">10.1177/1745691620970585</pub-id>
    </element-citation>
  </ref>
  <ref id="ref-thagardU003A1998">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Thagard</surname><given-names>Paul</given-names></name>
        <name><surname>Verbeurgt</surname><given-names>Karsten</given-names></name>
      </person-group>
      <article-title>Coherence as constraint satisfaction</article-title>
      <source>Cognitive Science</source>
      <year iso-8601-date="1998">1998</year>
      <volume>22</volume>
      <issue>1</issue>
      <pub-id pub-id-type="doi">10.1207/s15516709cog2201_1</pub-id>
      <fpage>24</fpage>
      <lpage></lpage>
    </element-citation>
  </ref>
  <ref id="ref-vanrooij_baggioU003A2021">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>van Rooij</surname><given-names>I.</given-names></name>
        <name><surname>Baggio</surname><given-names>G.</given-names></name>
      </person-group>
      <article-title>Theory before the test: How to build high-verisimilitude explanatory theories in psychological science</article-title>
      <source>Perspectives on Psychological Science</source>
      <year iso-8601-date="2021">2021</year>
      <volume>16</volume>
      <uri>https://journals.sagepub.com/doi/full/10.1177/1745691620970604</uri>
      <pub-id pub-id-type="doi">10.1177/1745691620970604</pub-id>
    </element-citation>
  </ref>
  <ref id="ref-marrU003A1982">
    <element-citation publication-type="book">
      <person-group person-group-type="author">
        <name><surname>Marr</surname><given-names>D.</given-names></name>
      </person-group>
      <source>Vision: A computational investigation into the human representation and processing of visual information</source>
      <publisher-name>W.H. Freeman, San Francisco, CA</publisher-name>
      <year iso-8601-date="1982">1982</year>
      <pub-id pub-id-type="doi">10.7551/mitpress/9780262514620.001.0001</pub-id>
    </element-citation>
  </ref>
  <ref id="ref-oderskyU003A2008">
    <element-citation publication-type="book">
      <person-group person-group-type="author">
        <name><surname>Odersky</surname><given-names>M.</given-names></name>
      </person-group>
      <source>Programming in Scala</source>
      <publisher-name>Mountain View, California: Artima</publisher-name>
      <year iso-8601-date="2008">2008</year>
    </element-citation>
  </ref>
</ref-list>
<fn-group>
  <fn id="fn1">
    <label>1</label><p>Computer simulations can also help scientists
    discover properties of the model that they would not have thought to
    analytically derive, even when in principle the property can be
    analytically derived.</p>
  </fn>
</fn-group>
</back>
</article>
