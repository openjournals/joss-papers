<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN"
                  "JATS-publishing1.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" dtd-version="1.2" article-type="other">
<front>
<journal-meta>
<journal-id></journal-id>
<journal-title-group>
<journal-title>Journal of Open Source Software</journal-title>
<abbrev-journal-title>JOSS</abbrev-journal-title>
</journal-title-group>
<issn publication-format="electronic">2475-9066</issn>
<publisher>
<publisher-name>Open Journals</publisher-name>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="publisher-id">8329</article-id>
<article-id pub-id-type="doi">10.21105/joss.08329</article-id>
<title-group>
<article-title>Piecewise: Flexible piecewise functions for fast integral
transforms in Julia</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author">
<contrib-id contrib-id-type="orcid">https://orcid.org/0000-0002-0787-008X</contrib-id>
<name>
<surname>Berthod</surname>
<given-names>Christophe</given-names>
</name>
<xref ref-type="aff" rid="aff-1"/>
</contrib>
<aff id="aff-1">
<institution-wrap>
<institution>Department of Quantum Matter Physics, University of Geneva,
1211 Geneva, Switzerland</institution>
</institution-wrap>
</aff>
</contrib-group>
<pub-date date-type="pub" publication-format="electronic" iso-8601-date="2025-02-18">
<day>18</day>
<month>2</month>
<year>2025</year>
</pub-date>
<volume>10</volume>
<issue>113</issue>
<fpage>8329</fpage>
<permissions>
<copyright-statement>Authors of papers retain copyright and release the
work under a Creative Commons Attribution 4.0 International License (CC
BY 4.0)</copyright-statement>
<copyright-year>2025</copyright-year>
<copyright-holder>The article authors</copyright-holder>
<license license-type="open-access" xlink:href="https://creativecommons.org/licenses/by/4.0/">
<license-p>Authors of papers retain copyright and release the work under
a Creative Commons Attribution 4.0 International License (CC BY
4.0)</license-p>
</license>
</permissions>
<kwd-group kwd-group-type="author">
<kwd>julia</kwd>
<kwd>piecewise function</kwd>
<kwd>integral transform</kwd>
</kwd-group>
</article-meta>
</front>
<body>
<sec id="summary">
  <title>Summary</title>
  <p>A piecewise function of a real variable
  <inline-formula><alternatives>
  <tex-math><![CDATA[x]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>x</mml:mi></mml:math></alternatives></inline-formula>
  returns a value computed from a rule that can be different in each
  interval of the values of <inline-formula><alternatives>
  <tex-math><![CDATA[x]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>x</mml:mi></mml:math></alternatives></inline-formula>.
  The Julia
  (<xref alt="Bezanson et al., 2017" rid="ref-Bezanson-2017" ref-type="bibr">Bezanson
  et al., 2017</xref>) module <monospace>Piecewise</monospace> provides
  an implementation of piecewise functions, where the user is free to
  choose the rules. A mechanism allows for fitting a piecewise function
  made of user-defined formulas to a real function of a real variable.
  With appropriately chosen formulas, various integral transforms of the
  piecewise function become directly available without relying on
  quadratures. The module <monospace>Piecewise</monospace> defines seven
  formula that enable the fast calculation of the moments of the
  piecewise function. The module <monospace>PiecewiseHilbert</monospace>
  supplements these formula with methods enabling a fast Hilbert
  transform. The module <monospace>PiecewiseLorentz</monospace> extends
  some of these formula to enable what we call a Lorentz transform. This
  code was written to solve a quantum physics problem involving several
  coupled integral equations
  (<xref alt="Berthod, 2025" rid="ref-MagnetoTransport.jl" ref-type="bibr">Berthod,
  2025</xref>;
  <xref alt="Morpurgo et al., 2024" rid="ref-Morpurgo-2024" ref-type="bibr">Morpurgo
  et al., 2024</xref>,
  <xref alt="2025" rid="ref-Morpurgo-2025" ref-type="bibr">2025</xref>).</p>
</sec>
<sec id="statement-of-need">
  <title>Statement of need</title>
  <p>The interpolation problem, which consists in constructing a
  continuous function out of discrete data, is ubiquitous in many areas
  of science and technology. This problem has been traditionally solved
  by means of global or piecewise polynomial functions
  (<xref alt="Bhagavan et al., 2024" rid="ref-Bhagavan-2024" ref-type="bibr">Bhagavan
  et al., 2024</xref>;
  <xref alt="Kittisopikul et al., 2023" rid="ref-Interpolations.jl" ref-type="bibr">Kittisopikul
  et al., 2023</xref>;
  <xref alt="Wikibooks, 2021" rid="ref-Numerical-Methods-2021" ref-type="bibr">Wikibooks,
  2021</xref>). The various interpolation schemes differ by the order of
  the polynomials, the choice of the sampling points when this choice is
  possible, and the additional conditions required when the solution is
  not uniquely determined by the data. Beside drawing a smooth curve
  through points in a graph, one important use of interpolations is for
  constructing a cheap but accurate approximation of a
  computer-intensive function. Powerful tools have been developed for
  smooth functions that are well approximated by polynomial interpolants
  using Chebyshev points
  (<xref alt="Driscoll et al., 2014" rid="ref-Chebfun" ref-type="bibr">Driscoll
  et al., 2014</xref>;
  <xref alt="Olver &amp; Townsend, 2014" rid="ref-ApproxFun.jl-2014" ref-type="bibr">Olver
  &amp; Townsend, 2014</xref>). However, if the function presents
  critical points like discontinuities or singularities, all polynomial
  interpolations fail in the neighborhood of these points, due to the
  absence of a convergent Taylor series. When the underlying function
  has critical points and accuracy is an issue, there is a need for
  piecewise interpolation schemes that are based on nonanalytic
  functions rather than polynomials.</p>
  <p>The mathematical problems involving integral equations (i.e., when
  the unknown function appears inside an integral) are often solved
  numerically by discretizing the integral and setting up an iteration.
  This introduces a discretization error. A choice of the discrete grid
  that minimizes the error would generally be nonuniform and require
  <italic>a priori</italic> knowledge of the solution. An optimization
  of the grid is possible through iterative refinement. However, if the
  actual solution has critical points, the iterative refinement will
  likely fail. Another approach is to represent the solution at
  iteration <inline-formula><alternatives>
  <tex-math><![CDATA[n]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>n</mml:mi></mml:math></alternatives></inline-formula>
  as a piecewise function, evaluate the integrals using quadratures, and
  fit a new piecewise function to the solution computed at iteration
  <inline-formula><alternatives>
  <tex-math><![CDATA[n+1]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></alternatives></inline-formula>.
  This algorithm may not be faster than the discretization approach, but
  it eliminates the discretization bias. Furthermore, the critical
  points can in principle be captured in a piecewise function involving
  appropriate nonanalytic functions. The procedure requires recursively
  fitting a set of elementary functions, including nonanalytic ones that
  are problem dependent, to a given function, until a sufficient
  accuracy is achieved in each piece. To our knowledge, no Julia package
  offers this functionality.</p>
  <p>A subclass of all integral equations comprises those involving
  linear integral transforms of the kind <inline-formula><alternatives>
  <tex-math><![CDATA[(K\circ f)(\mathbf{X})=\int_{-\infty}^{\infty}dx\,f(x)K(x,\mathbf{X})]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>K</mml:mi><mml:mo>‚àò</mml:mo><mml:mi>f</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>ùêó</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msubsup><mml:mo>‚à´</mml:mo><mml:mrow><mml:mi>‚àí</mml:mi><mml:mi>‚àû</mml:mi></mml:mrow><mml:mi>‚àû</mml:mi></mml:msubsup><mml:mi>d</mml:mi><mml:mi>x</mml:mi><mml:mspace width="0.167em"></mml:mspace><mml:mi>f</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mi>K</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>ùêó</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>,
  where <inline-formula><alternatives>
  <tex-math><![CDATA[f(x)]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>f</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
  is a function of a real variable <inline-formula><alternatives>
  <tex-math><![CDATA[x]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>x</mml:mi></mml:math></alternatives></inline-formula>
  and <inline-formula><alternatives>
  <tex-math><![CDATA[K(x,\mathbf{X})]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>K</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>ùêó</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
  is a kernel depending on <inline-formula><alternatives>
  <tex-math><![CDATA[x]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>x</mml:mi></mml:math></alternatives></inline-formula>
  and another, possibly multidimensional, variable
  <inline-formula><alternatives>
  <tex-math><![CDATA[\mathbf{X}]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>ùêó</mml:mi></mml:math></alternatives></inline-formula>.
  For instance, the <inline-formula><alternatives>
  <tex-math><![CDATA[n]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>n</mml:mi></mml:math></alternatives></inline-formula>-th
  moment of a distribution is the integral transform of this
  distribution with kernel <inline-formula><alternatives>
  <tex-math><![CDATA[K(x,n)=x^n]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>K</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msup><mml:mi>x</mml:mi><mml:mi>n</mml:mi></mml:msup></mml:mrow></mml:math></alternatives></inline-formula>.
  Other examples include the Fourier transform with
  <inline-formula><alternatives>
  <tex-math><![CDATA[K(x,k)=e^{-ikx}]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>K</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mi>‚àí</mml:mi><mml:mi>i</mml:mi><mml:mi>k</mml:mi><mml:mi>x</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></alternatives></inline-formula>,
  the Laplace transform with <inline-formula><alternatives>
  <tex-math><![CDATA[K(x,s)=\theta(x)e^{-sx}]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>K</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>Œ∏</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mi>‚àí</mml:mi><mml:mi>s</mml:mi><mml:mi>x</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></alternatives></inline-formula>,
  <inline-formula><alternatives>
  <tex-math><![CDATA[\theta(x)]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>Œ∏</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
  being the Heaviside step function, the Hilbert transform with
  <inline-formula><alternatives>
  <tex-math><![CDATA[K(x,y)=1/(y-x+i0^+)]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>K</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mi>/</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>y</mml:mi><mml:mo>‚àí</mml:mo><mml:mi>x</mml:mi><mml:mo>+</mml:mo><mml:mi>i</mml:mi><mml:msup><mml:mn>0</mml:mn><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>,
  or more generally <inline-formula><alternatives>
  <tex-math><![CDATA[K(x,z)=1/(z-x)]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>K</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>z</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mi>/</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>z</mml:mi><mml:mo>‚àí</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
  with <inline-formula><alternatives>
  <tex-math><![CDATA[z\in\mathbb{C}\setminus\mathbb{R}]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>z</mml:mi><mml:mo>‚àà</mml:mo><mml:mi>‚ÑÇ</mml:mi><mml:mo>\</mml:mo><mml:mi>‚Ñù</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
  a complex number with finite imaginary part. If the function
  <inline-formula><alternatives>
  <tex-math><![CDATA[f(x)]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>f</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
  is represented as a piecewise function, and if the various elementary
  functions <inline-formula><alternatives>
  <tex-math><![CDATA[F_i(x)]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
  used in this piecewise representation are such, that the solution of
  the differential equation <inline-formula><alternatives>
  <tex-math><![CDATA[\frac{d}{dx}P_i(x,\mathbf{X})=F_i(x)K(x,\mathbf{X})]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mfrac><mml:mi>d</mml:mi><mml:mrow><mml:mi>d</mml:mi><mml:mi>x</mml:mi></mml:mrow></mml:mfrac><mml:msub><mml:mi>P</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>ùêó</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mi>F</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mi>K</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>ùêó</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
  is known analytically, then <inline-formula><alternatives>
  <tex-math><![CDATA[(K\circ f)(\mathbf{X})]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>K</mml:mi><mml:mo>‚àò</mml:mo><mml:mi>f</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>ùêó</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
  is immediately available by evaluating the functions
  <inline-formula><alternatives>
  <tex-math><![CDATA[P_i(x,\mathbf{X})]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>ùêó</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
  at the boundaries of each piece. This may significantly outperform the
  evaluation of <inline-formula><alternatives>
  <tex-math><![CDATA[(K\circ f)(\mathbf{X})]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>K</mml:mi><mml:mo>‚àò</mml:mo><mml:mi>f</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>ùêó</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
  using quadratures, especially near the critical points of
  <inline-formula><alternatives>
  <tex-math><![CDATA[f(x)]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>f</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>,
  where the quadratures typically converge slowly, if they converge at
  all. Thus, an environment where problem-dependent functions
  <inline-formula><alternatives>
  <tex-math><![CDATA[F_i(x)]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
  may be defined and used in piecewise functions, together with
  kernel-dependent functions <inline-formula><alternatives>
  <tex-math><![CDATA[P_i(x,\mathbf{X})]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>ùêó</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>,
  is desirable.</p>
</sec>
<sec id="the-piecewise-modules">
  <title>The <monospace>Piecewise</monospace> modules</title>
  <p>The module <monospace>Piecewise</monospace> provides such an
  environment based on three structures. A structure called
  <monospace>Formula</monospace> holds a user-defined function depending
  on a given number of parameters, together with possible restrictions
  regarding the values of these parameters with respect to the interval
  in which the formula is used. A second structure called
  <monospace>Piece</monospace> holds an interval, a rule that can be a
  sum of <monospace>Formula</monospace> objects, and the parameters to
  be passed to these formula. Finally, a structure called
  <monospace>PiecewiseFunction</monospace> holds a collection of
  <monospace>Piece</monospace> objects. The module comes with a small
  set of pre-defined <monospace>Formula</monospace> that should cover a
  wide variety of cases and a method for fitting a
  <monospace>PiecewiseFunction</monospace> object to a given function.
  The pre-defined <monospace>Formula</monospace> earn additional methods
  in the module <monospace>PiecewiseHilbert</monospace>, such that the
  Hilbert transform of piecewise functions using these formula can be
  evaluated without using quadratures. The module
  <monospace>PiecewiseLorentz</monospace> offers this functionality for
  another integral transform (see the
  <ext-link ext-link-type="uri" xlink:href="https://christopheberthod.github.io/Piecewise.jl/dev/lorentz.html">documentation</ext-link>).</p>
</sec>
<sec id="examples">
  <title>Examples</title>
  <list list-type="order">
    <list-item>
      <p>Two tutorials are available as Jupyter notebooks:</p>
    </list-item>
  </list>
  <list list-type="bullet">
    <list-item>
      <p><ext-link ext-link-type="uri" xlink:href="https://github.com/ChristopheBerthod/Piecewise.jl/blob/main/notebooks/Tutorial-1.ipynb">Tutorial
      1</ext-link>: Constructing approximations with
      <ext-link ext-link-type="uri" xlink:href="https://christopheberthod.github.io/Piecewise.jl/dev/index.html#Piecewise.piecewisefit"><monospace>Piecewise.piecewisefit</monospace></ext-link></p>
    </list-item>
    <list-item>
      <p><ext-link ext-link-type="uri" xlink:href="https://github.com/ChristopheBerthod/Piecewise.jl/blob/main/notebooks/Tutorial-2.ipynb">Tutorial
      2</ext-link>: Solving an implicit equation using
      <ext-link ext-link-type="uri" xlink:href="https://christopheberthod.github.io/Piecewise.jl/dev/hilbert.html"><monospace>PiecewiseHilbert</monospace></ext-link></p>
    </list-item>
  </list>
  <list list-type="order">
    <list-item>
      <label>2.</label>
      <p>For a complete use case, see
      <ext-link ext-link-type="uri" xlink:href="https://github.com/ChristopheBerthod/MagnetoTransport.jl"><monospace>MagnetoTransport.jl</monospace></ext-link>.</p>
    </list-item>
    <list-item>
      <label>3.</label>
      <p>For an example of nonlinear integral equation solved using
      <monospace>Piecewise</monospace>, see van der Marel &amp; Berthod
      (<xref alt="2024" rid="ref-vanderMarel-2024" ref-type="bibr">2024</xref>).</p>
    </list-item>
    <list-item>
      <label>4.</label>
      <p>A simple demonstration is provided below. It is an abbreviated
      form of
      <ext-link ext-link-type="uri" xlink:href="https://github.com/ChristopheBerthod/Piecewise.jl/blob/main/notebooks/Tutorial-1.ipynb">Tutorial
      1</ext-link>, where ample explanation and details are given.</p>
    </list-item>
  </list>
  <p>Electronic density of states (DOS) functions typically have
  critical points. The DOS is derived from a dispersion relation
  <inline-formula><alternatives>
  <tex-math><![CDATA[\varepsilon(\mathbf{k})]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>Œµ</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>ùê§</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
  as <inline-formula><alternatives>
  <tex-math><![CDATA[N(E)=\int\frac{\mathrm{d}^dk}{(2\pi)^d}\delta\big(E-\varepsilon(\mathbf{k})\big)]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>N</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mo>‚à´</mml:mo><mml:mfrac><mml:mrow><mml:msup><mml:mi mathvariant="normal">d</mml:mi><mml:mi>d</mml:mi></mml:msup><mml:mi>k</mml:mi></mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>2</mml:mn><mml:mi>œÄ</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mi>d</mml:mi></mml:msup></mml:mfrac><mml:mi>Œ¥</mml:mi><mml:mo minsize="1.2" maxsize="1.2" stretchy="false" form="prefix">(</mml:mo><mml:mi>E</mml:mi><mml:mo>‚àí</mml:mo><mml:mi>Œµ</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>ùê§</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo minsize="1.2" maxsize="1.2" stretchy="false" form="postfix">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>
  in dimension <inline-formula><alternatives>
  <tex-math><![CDATA[d]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>d</mml:mi></mml:math></alternatives></inline-formula>,
  where <inline-formula><alternatives>
  <tex-math><![CDATA[\delta(\cdot)]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>Œ¥</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>‚ãÖ</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
  is the Dirac delta function. <inline-formula><alternatives>
  <tex-math><![CDATA[N(E)]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>N</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
  has critical points whenever <inline-formula><alternatives>
  <tex-math><![CDATA[\nabla\varepsilon(\mathbf{k})=0]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>‚àá</mml:mi><mml:mi>Œµ</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>ùê§</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></alternatives></inline-formula>
  for some <inline-formula><alternatives>
  <tex-math><![CDATA[\mathbf{k}]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>ùê§</mml:mi></mml:math></alternatives></inline-formula>.
  The DOS is an ingredient of many calculations, but in general it is
  not known analytically. In the following illustration, we construct a
  one-piece approximation with relative accuracy below
  <inline-formula><alternatives>
  <tex-math><![CDATA[10^{-5}]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msup><mml:mn>10</mml:mn><mml:mrow><mml:mi>‚àí</mml:mi><mml:mn>5</mml:mn></mml:mrow></mml:msup></mml:math></alternatives></inline-formula>
  for such a DOS function.</p>
  <p>Electrons hopping with unit energy between neighboring sites of a
  two-dimensional square lattice with unit lattice parameter have a
  dispersion relation <inline-formula><alternatives>
  <tex-math><![CDATA[\varepsilon(\mathbf{k})=2(\cos k_x+\cos k_y)]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>Œµ</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>ùê§</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mo>cos</mml:mo><mml:msub><mml:mi>k</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:mo>cos</mml:mo><mml:msub><mml:mi>k</mml:mi><mml:mi>y</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>.
  This case is peculiar in that the DOS is known analytically:
  <inline-formula><alternatives>
  <tex-math><![CDATA[N(E)=K\big(1-(E/4)^2\big)\theta(4-|E|)/(2\pi^2)]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>N</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>K</mml:mi><mml:mo minsize="1.2" maxsize="1.2" stretchy="false" form="prefix">(</mml:mo><mml:mn>1</mml:mn><mml:mo>‚àí</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>E</mml:mi><mml:mi>/</mml:mi><mml:mn>4</mml:mn><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo minsize="1.2" maxsize="1.2" stretchy="false" form="postfix">)</mml:mo><mml:mi>Œ∏</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>4</mml:mn><mml:mo>‚àí</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">|</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="true" form="postfix">|</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mi>/</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>2</mml:mn><mml:msup><mml:mi>œÄ</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
  with <inline-formula><alternatives>
  <tex-math><![CDATA[K]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>K</mml:mi></mml:math></alternatives></inline-formula>
  the elliptic function. It has two discontinuities at
  <inline-formula><alternatives>
  <tex-math><![CDATA[E=\pm4]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>E</mml:mi><mml:mo>=</mml:mo><mml:mi>¬±</mml:mi><mml:mn>4</mml:mn></mml:mrow></mml:math></alternatives></inline-formula>
  and a logarithmic singularity at <inline-formula><alternatives>
  <tex-math><![CDATA[E=0]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>E</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></alternatives></inline-formula>.</p>
  <p>We proceed as follows to construct a piecewise approximation to the
  DOS.</p>
  <list list-type="order">
    <list-item>
      <p>We define the DOS (here: an explicit formula; in general: the
      result of a numerical quadrature).</p>
    </list-item>
    <list-item>
      <p>We remove the known logarithmic singularity ‚Äî represented as a
      <monospace>PiecewiseFunction</monospace> ‚Äî from the DOS.</p>
    </list-item>
    <list-item>
      <p>We fit a polynomial to the residual (the algorithm
      automatically chooses order 9 to achieve the requested accuracy)
      and we add the logarithmic singularity back.</p>
    </list-item>
    <list-item>
      <p>We check the error of the approximation.</p>
    </list-item>
  </list>
  <code language="julia">julia&gt; using SpecialFunctions: ellipk
julia&gt; using Piecewise

julia&gt; # DOS function. Due to the dependence on E^2, ellipk(1 - (E / 4)^2)
julia&gt; # loses accuracy for |E| &lt; 1e-4. We use the known expansion instead.
julia&gt; N(E) = (abs(E) &lt; 1e-4 ? log(16 / abs(E)) : abs(E) &gt; 4 ? 0.0 :
           ellipk(1 - (E / 4)^2)) / (2 * œÄ^2);

julia&gt; # Piecewise function representing the logarithmic singularity
julia&gt; singularity = PiecewiseFunction(:even,
           Piece((0, 4), (false, true), LOG, [0, -1 / (2 * œÄ^2)]));

julia&gt; # Remove the singularity before fitting and add it back afterwards
julia&gt; # PiecewiseFunction objects can be summed.
julia&gt; f = piecewisefit(E -&gt; N(E) - singularity(E),
           (0, 4), [POLY], parity=:even, rtol=5e-6);
julia&gt; f += singularity
&lt; Piecewise even function with 1 piece and support [-4.0, 4.0] &gt;

julia&gt; # Check that the relative error is smaller than 1e-5
julia&gt; maximum(LinRange(-4, 4, 1000) .|&gt; E -&gt; abs(f(E) ./ N(E) - 1)) &lt; 1e-5
true

julia&gt; # Printing a PiecewiseFunction shows the constructor for that object.
julia&gt; #¬†The exact numbers may vary, as randomness is involved in the fitting.
julia&gt; println(f)
PiecewiseFunction(:even, [
    Piece((0.0, 4.0), (false, true), [POLY, LOG],
        [[1.404609620501190e-01, 1.174637035445451e-04, 2.462481494536943e-03,
        -1.995071066151247e-03, 1.349285972889321e-03, -6.607932327688245e-04,
        2.158678002039584e-04, -4.417944490515085e-05, 5.103263826300048e-06,
        -2.533300199959029e-07], [0.000000000000000e+00,
        -5.066059182116889e-02]])
])</code>
</sec>
</body>
<back>
<ref-list>
  <title></title>
  <ref id="ref-Bezanson-2017">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Bezanson</surname><given-names>Jeff</given-names></name>
        <name><surname>Edelman</surname><given-names>Alan</given-names></name>
        <name><surname>Karpinski</surname><given-names>Stefan</given-names></name>
        <name><surname>Shah</surname><given-names>Viral B.</given-names></name>
      </person-group>
      <article-title>Julia: A fresh approach to numerical computing</article-title>
      <source>SIAM Review</source>
      <year iso-8601-date="2017">2017</year>
      <volume>59</volume>
      <issue>1</issue>
      <pub-id pub-id-type="doi">10.1137/141000671</pub-id>
      <fpage>65</fpage>
      <lpage></lpage>
    </element-citation>
  </ref>
  <ref id="ref-Morpurgo-2024">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Morpurgo</surname><given-names>Giacomo</given-names></name>
        <name><surname>Rademaker</surname><given-names>Louk</given-names></name>
        <name><surname>Berthod</surname><given-names>Christophe</given-names></name>
        <name><surname>Giamarchi</surname><given-names>Thierry</given-names></name>
      </person-group>
      <article-title>Hall response of locally correlated two-dimensional electrons at low density</article-title>
      <source>Physical Review Research</source>
      <year iso-8601-date="2024">2024</year>
      <volume>6</volume>
      <pub-id pub-id-type="doi">10.1103/PhysRevResearch.6.013112</pub-id>
      <fpage>013112</fpage>
      <lpage></lpage>
    </element-citation>
  </ref>
  <ref id="ref-Morpurgo-2025">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Morpurgo</surname><given-names>Giacomo</given-names></name>
        <name><surname>Berthod</surname><given-names>Christophe</given-names></name>
        <name><surname>Giamarchi</surname><given-names>Thierry</given-names></name>
      </person-group>
      <article-title>Universal low-density power laws of the dc conductivity and Hall constant in the self-consistent Born approximation</article-title>
      <source>Physical Review Research</source>
      <year iso-8601-date="2025">2025</year>
      <volume>7</volume>
      <pub-id pub-id-type="doi">10.1103/nzrk-yfqk</pub-id>
      <fpage>033038</fpage>
      <lpage></lpage>
    </element-citation>
  </ref>
  <ref id="ref-MagnetoTransport.jl">
    <element-citation>
      <person-group person-group-type="author">
        <name><surname>Berthod</surname><given-names>Christophe</given-names></name>
      </person-group>
      <article-title>Linear magneto-transport with a local self-energy in Julia</article-title>
      <publisher-name>https://github.com/ChristopheBerthod/MagnetoTransport.jl</publisher-name>
      <year iso-8601-date="2025">2025</year>
    </element-citation>
  </ref>
  <ref id="ref-Numerical-Methods-2021">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Wikibooks</surname></name>
      </person-group>
      <article-title>Introduction to numerical methods ‚Äî Wikibooks, the free textbook project</article-title>
      <year iso-8601-date="2021">2021</year>
      <uri>https://en.wikibooks.org/wiki/Introduction_to_Numerical_Methods/Interpolation</uri>
    </element-citation>
  </ref>
  <ref id="ref-Bhagavan-2024">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Bhagavan</surname><given-names>Sathvik</given-names></name>
        <name><surname>de Koning</surname><given-names>Bart</given-names></name>
        <name><surname>Maddhashiya</surname><given-names>Shubham</given-names></name>
        <name><surname>Rackauckas</surname><given-names>Christopher</given-names></name>
      </person-group>
      <article-title>DataInterpolations.jl: Fast interpolations of 1D data</article-title>
      <source>Journal of Open Source Software</source>
      <year iso-8601-date="2024">2024</year>
      <volume>9</volume>
      <issue>101</issue>
      <pub-id pub-id-type="doi">10.21105/joss.06917</pub-id>
      <fpage>6917</fpage>
      <lpage></lpage>
    </element-citation>
  </ref>
  <ref id="ref-Interpolations.jl">
    <element-citation>
      <person-group person-group-type="author">
        <name><surname>Kittisopikul</surname><given-names>Mark</given-names></name>
        <name><surname>Holy</surname><given-names>Timothy E.</given-names></name>
        <name><surname>Aschan</surname><given-names>Tomas</given-names></name>
      </person-group>
      <article-title>JuliaMath/Interpolations.jl: v0.15.1</article-title>
      <publisher-name>https://github.com/JuliaMath/Interpolations.jl</publisher-name>
      <year iso-8601-date="2023">2023</year>
    </element-citation>
  </ref>
  <ref id="ref-vanderMarel-2024">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>van der Marel</surname><given-names>Dirk</given-names></name>
        <name><surname>Berthod</surname><given-names>Christophe</given-names></name>
      </person-group>
      <article-title>Superconductivity in metallic hydrogen</article-title>
      <source>Newton</source>
      <year iso-8601-date="2024">2024</year>
      <volume>1</volume>
      <pub-id pub-id-type="doi">10.1016/j.newton.2024.100002</pub-id>
      <fpage>100002</fpage>
      <lpage></lpage>
    </element-citation>
  </ref>
  <ref id="ref-Chebfun">
    <element-citation publication-type="book">
      <source>Chebfun Guide</source>
      <person-group person-group-type="editor">
        <name><surname>Driscoll</surname><given-names>T. A.</given-names></name>
        <name><surname>Hale</surname><given-names>N.</given-names></name>
        <name><surname>Trefethen</surname><given-names>L. N.</given-names></name>
      </person-group>
      <publisher-name>https://www.chebfun.org; Pafnuty Publications</publisher-name>
      <publisher-loc>Oxford</publisher-loc>
      <year iso-8601-date="2014">2014</year>
    </element-citation>
  </ref>
  <ref id="ref-ApproxFun.jl-2014">
    <element-citation publication-type="paper-conference">
      <person-group person-group-type="author">
        <name><surname>Olver</surname><given-names>Sheehan</given-names></name>
        <name><surname>Townsend</surname><given-names>Alex</given-names></name>
      </person-group>
      <article-title>A practical framework for infinite-dimensional linear algebra</article-title>
      <source>Proceedings of the 1st workshop for high performance technical computing in dynamic languages ‚Äì HPTCDL ‚Äò14</source>
      <publisher-name>IEEE</publisher-name>
      <year iso-8601-date="2014">2014</year>
      <pub-id pub-id-type="doi">10.1109/HPTCDL.2014.10</pub-id>
    </element-citation>
  </ref>
</ref-list>
</back>
</article>
