<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN"
                  "JATS-publishing1.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" dtd-version="1.2" article-type="other">
<front>
<journal-meta>
<journal-id></journal-id>
<journal-title-group>
<journal-title>Journal of Open Source Software</journal-title>
<abbrev-journal-title>JOSS</abbrev-journal-title>
</journal-title-group>
<issn publication-format="electronic">2475-9066</issn>
<publisher>
<publisher-name>Open Journals</publisher-name>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="publisher-id">4900</article-id>
<article-id pub-id-type="doi">10.21105/joss.04900</article-id>
<title-group>
<article-title>PyKronecker: A Python Library for the Efficient
Manipulation of Kronecker Products and Related
Structures</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author">
<name>
<surname>Antonian</surname>
<given-names>Edward</given-names>
</name>
<xref ref-type="aff" rid="aff-1"/>
</contrib>
<contrib contrib-type="author">
<name>
<surname>Peters</surname>
<given-names>Gareth W.</given-names>
</name>
<xref ref-type="aff" rid="aff-2"/>
</contrib>
<contrib contrib-type="author">
<name>
<surname>Chantler</surname>
<given-names>Michael</given-names>
</name>
<xref ref-type="aff" rid="aff-1"/>
</contrib>
<aff id="aff-1">
<institution-wrap>
<institution>Heriot-Watt University, United Kingdom</institution>
</institution-wrap>
</aff>
<aff id="aff-2">
<institution-wrap>
<institution>University of California Santa Barbara, United States of
America</institution>
</institution-wrap>
</aff>
</contrib-group>
<pub-date date-type="pub" publication-format="electronic" iso-8601-date="2022-09-27">
<day>27</day>
<month>9</month>
<year>2022</year>
</pub-date>
<volume>8</volume>
<issue>81</issue>
<fpage>4900</fpage>
<permissions>
<copyright-statement>Authors of papers retain copyright and release the
work under a Creative Commons Attribution 4.0 International License (CC
BY 4.0)</copyright-statement>
<copyright-year>2022</copyright-year>
<copyright-holder>The article authors</copyright-holder>
<license license-type="open-access" xlink:href="https://creativecommons.org/licenses/by/4.0/">
<license-p>Authors of papers retain copyright and release the work under
a Creative Commons Attribution 4.0 International License (CC BY
4.0)</license-p>
</license>
</permissions>
<kwd-group kwd-group-type="author">
<kwd>Python</kwd>
<kwd>Numpy</kwd>
<kwd>Jax</kwd>
<kwd>Kronecker product</kwd>
<kwd>Kronecker sum</kwd>
<kwd>linear system</kwd>
<kwd>GPU</kwd>
</kwd-group>
</article-meta>
</front>
<body>
<sec id="summary">
  <title>Summary</title>
  <p>Matrix operators composed of Kronecker products and related
  objects, such as Kronecker sums, arise in many areas of applied
  mathematics including signal processing, semidefinite programming, and
  quantum computing
  (<xref alt="Loan, 2000" rid="ref-loan2000" ref-type="bibr">Loan,
  2000</xref>). As such, a computational toolkit for manipulating
  Kronecker-based systems, in a way that is both efficient and
  idiomatic, has the potential to aid research in many fields.
  PyKronecker aims to deliver this in the Python programming language by
  providing a simple API that integrates well with the widely-used NumPy
  library
  (<xref alt="Harris et al., 2020" rid="ref-harris2020" ref-type="bibr">Harris
  et al., 2020</xref>), and that supports automatic differentiation and
  accelerated computation on GPU/TPU hardware using Jax
  (<xref alt="Bradbury et al., 2018" rid="ref-jax2018" ref-type="bibr">Bradbury
  et al., 2018</xref>).</p>
  <sec id="kronecker-products">
    <title>Kronecker products</title>
    <p>The Kronecker product of an <inline-formula><alternatives>
    <tex-math><![CDATA[(n \times n)]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>n</mml:mi><mml:mo>Ã—</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>
    matrix <inline-formula><alternatives>
    <tex-math><![CDATA[\mathbf{A}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mstyle mathvariant="bold"><mml:mi>ğ€</mml:mi></mml:mstyle></mml:math></alternatives></inline-formula>
    and an <inline-formula><alternatives>
    <tex-math><![CDATA[(m \times m)]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>m</mml:mi><mml:mo>Ã—</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>
    matrix <inline-formula><alternatives>
    <tex-math><![CDATA[\mathbf{B}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mstyle mathvariant="bold"><mml:mi>ğ</mml:mi></mml:mstyle></mml:math></alternatives></inline-formula>,
    denoted <inline-formula><alternatives>
    <tex-math><![CDATA[\mathbf{A} \otimes \mathbf{B}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mstyle mathvariant="bold"><mml:mi>ğ€</mml:mi></mml:mstyle><mml:mo>âŠ—</mml:mo><mml:mstyle mathvariant="bold"><mml:mi>ğ</mml:mi></mml:mstyle></mml:mrow></mml:math></alternatives></inline-formula>,
    is defined by <disp-formula><alternatives>
    <tex-math><![CDATA[
    \mathbf{A} \otimes \mathbf{B} = 
    \begin{bmatrix} 
    \mathbf{A}_{1,1} \mathbf{B} & \dots  & \mathbf{A}_{1,n} \mathbf{B} \\
    \vdots   & \ddots & \vdots   \\
    \mathbf{A}_{n,1} \mathbf{B} & \dots  & \mathbf{A}_{n,n} \mathbf{B}
    \end{bmatrix}.
    ]]></tex-math>
    <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mstyle mathvariant="bold"><mml:mi>ğ€</mml:mi></mml:mstyle><mml:mo>âŠ—</mml:mo><mml:mstyle mathvariant="bold"><mml:mi>ğ</mml:mi></mml:mstyle><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mtable><mml:mtr><mml:mtd columnalign="center"><mml:msub><mml:mstyle mathvariant="bold"><mml:mi>ğ€</mml:mi></mml:mstyle><mml:mrow><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mstyle mathvariant="bold"><mml:mi>ğ</mml:mi></mml:mstyle></mml:mtd><mml:mtd columnalign="center"><mml:mi>â€¦</mml:mi></mml:mtd><mml:mtd columnalign="center"><mml:msub><mml:mstyle mathvariant="bold"><mml:mi>ğ€</mml:mi></mml:mstyle><mml:mrow><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mstyle mathvariant="bold"><mml:mi>ğ</mml:mi></mml:mstyle></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="center"><mml:mi>â‹®</mml:mi></mml:mtd><mml:mtd columnalign="center"><mml:mo>â‹±</mml:mo></mml:mtd><mml:mtd columnalign="center"><mml:mi>â‹®</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="center"><mml:msub><mml:mstyle mathvariant="bold"><mml:mi>ğ€</mml:mi></mml:mstyle><mml:mrow><mml:mi>n</mml:mi><mml:mo>,</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mstyle mathvariant="bold"><mml:mi>ğ</mml:mi></mml:mstyle></mml:mtd><mml:mtd columnalign="center"><mml:mi>â€¦</mml:mi></mml:mtd><mml:mtd columnalign="center"><mml:msub><mml:mstyle mathvariant="bold"><mml:mi>ğ€</mml:mi></mml:mstyle><mml:mrow><mml:mi>n</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mstyle mathvariant="bold"><mml:mi>ğ</mml:mi></mml:mstyle></mml:mtd></mml:mtr></mml:mtable><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow><mml:mi>.</mml:mi></mml:mrow></mml:math></alternatives></disp-formula></p>
    <p>The resultant operator has shape <inline-formula><alternatives>
    <tex-math><![CDATA[(nm \times nm)]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>n</mml:mi><mml:mi>m</mml:mi><mml:mo>Ã—</mml:mo><mml:mi>n</mml:mi><mml:mi>m</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>
    and, as such, can act on vectors of length
    <inline-formula><alternatives>
    <tex-math><![CDATA[nm]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>n</mml:mi><mml:mi>m</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>.
    The Kronecker sum of <inline-formula><alternatives>
    <tex-math><![CDATA[\mathbf{A}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mstyle mathvariant="bold"><mml:mi>ğ€</mml:mi></mml:mstyle></mml:math></alternatives></inline-formula>
    and <inline-formula><alternatives>
    <tex-math><![CDATA[\mathbf{B}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mstyle mathvariant="bold"><mml:mi>ğ</mml:mi></mml:mstyle></mml:math></alternatives></inline-formula>,
    denoted <inline-formula><alternatives>
    <tex-math><![CDATA[\mathbf{A} \oplus \mathbf{B}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mstyle mathvariant="bold"><mml:mi>ğ€</mml:mi></mml:mstyle><mml:mo>âŠ•</mml:mo><mml:mstyle mathvariant="bold"><mml:mi>ğ</mml:mi></mml:mstyle></mml:mrow></mml:math></alternatives></inline-formula>
    can be defined in terms of the Kronecker product as
    <disp-formula><alternatives>
    <tex-math><![CDATA[
    \mathbf{A} \oplus \mathbf{B} = \mathbf{A} \otimes \mathbf{I}_m + \mathbf{I}_n \otimes \mathbf{B},
    ]]></tex-math>
    <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mstyle mathvariant="bold"><mml:mi>ğ€</mml:mi></mml:mstyle><mml:mo>âŠ•</mml:mo><mml:mstyle mathvariant="bold"><mml:mi>ğ</mml:mi></mml:mstyle><mml:mo>=</mml:mo><mml:mstyle mathvariant="bold"><mml:mi>ğ€</mml:mi></mml:mstyle><mml:mo>âŠ—</mml:mo><mml:msub><mml:mstyle mathvariant="bold"><mml:mi>ğˆ</mml:mi></mml:mstyle><mml:mi>m</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mstyle mathvariant="bold"><mml:mi>ğˆ</mml:mi></mml:mstyle><mml:mi>n</mml:mi></mml:msub><mml:mo>âŠ—</mml:mo><mml:mstyle mathvariant="bold"><mml:mi>ğ</mml:mi></mml:mstyle><mml:mo>,</mml:mo></mml:mrow></mml:math></alternatives></disp-formula>
    where <inline-formula><alternatives>
    <tex-math><![CDATA[\mathbf{I}_d]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mstyle mathvariant="bold"><mml:mi>ğˆ</mml:mi></mml:mstyle><mml:mi>d</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
    is the <inline-formula><alternatives>
    <tex-math><![CDATA[d]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>d</mml:mi></mml:math></alternatives></inline-formula>-dimensional
    identity matrix, resulting in an operator of the same size as
    <inline-formula><alternatives>
    <tex-math><![CDATA[\mathbf{A} \otimes \mathbf{B}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mstyle mathvariant="bold"><mml:mi>ğ€</mml:mi></mml:mstyle><mml:mo>âŠ—</mml:mo><mml:mstyle mathvariant="bold"><mml:mi>ğ</mml:mi></mml:mstyle></mml:mrow></mml:math></alternatives></inline-formula>.
    By applying these definitions recursively, the Kronecker product or
    sum of more than two matrices can also be defined. In general, the
    Kronecker product/sum of <inline-formula><alternatives>
    <tex-math><![CDATA[k]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>k</mml:mi></mml:math></alternatives></inline-formula>
    square matrices <inline-formula><alternatives>
    <tex-math><![CDATA[\{ \mathbf{A}^{(i)} \}_{i=1}^k]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo stretchy="false" form="prefix">{</mml:mo><mml:msup><mml:mstyle mathvariant="bold"><mml:mi>ğ€</mml:mi></mml:mstyle><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:msup><mml:msubsup><mml:mo stretchy="false" form="postfix">}</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula>,
    with shapes <inline-formula><alternatives>
    <tex-math><![CDATA[\{n_i \times n_i\}_{i=1}^k]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo stretchy="false" form="prefix">{</mml:mo><mml:msub><mml:mi>n</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>Ã—</mml:mo><mml:msub><mml:mi>n</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msubsup><mml:mo stretchy="false" form="postfix">}</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula>
    can be written respectively as <disp-formula><alternatives>
    <tex-math><![CDATA[
    \bigotimes_{i=1}^k \mathbf{A}^{(i)} = \mathbf{A}^{(1)} \otimes \mathbf{A}^{(2)} \otimes \dots \otimes \mathbf{A}^{(k)}
    ]]></tex-math>
    <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:munderover><mml:mo>â¨‚</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:munderover><mml:msup><mml:mstyle mathvariant="bold"><mml:mi>ğ€</mml:mi></mml:mstyle><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:msup><mml:mstyle mathvariant="bold"><mml:mi>ğ€</mml:mi></mml:mstyle><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:msup><mml:mo>âŠ—</mml:mo><mml:msup><mml:mstyle mathvariant="bold"><mml:mi>ğ€</mml:mi></mml:mstyle><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:msup><mml:mo>âŠ—</mml:mo><mml:mi>â€¦</mml:mi><mml:mo>âŠ—</mml:mo><mml:msup><mml:mstyle mathvariant="bold"><mml:mi>ğ€</mml:mi></mml:mstyle><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:math></alternatives></disp-formula>
    and <disp-formula><alternatives>
    <tex-math><![CDATA[
    \bigoplus_{i=1}^k \mathbf{A}^{(i)} = \mathbf{A}^{(1)} \oplus \mathbf{A}^{(2)} \oplus \dots \oplus \mathbf{A}^{(k)}.
    ]]></tex-math>
    <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:munderover><mml:mo>â¨</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:munderover><mml:msup><mml:mstyle mathvariant="bold"><mml:mi>ğ€</mml:mi></mml:mstyle><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:msup><mml:mstyle mathvariant="bold"><mml:mi>ğ€</mml:mi></mml:mstyle><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:msup><mml:mo>âŠ•</mml:mo><mml:msup><mml:mstyle mathvariant="bold"><mml:mi>ğ€</mml:mi></mml:mstyle><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:msup><mml:mo>âŠ•</mml:mo><mml:mi>â€¦</mml:mi><mml:mo>âŠ•</mml:mo><mml:msup><mml:mstyle mathvariant="bold"><mml:mi>ğ€</mml:mi></mml:mstyle><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:msup><mml:mi>.</mml:mi></mml:mrow></mml:math></alternatives></disp-formula>
    The resultant operators can act on either vectors of length
    <inline-formula><alternatives>
    <tex-math><![CDATA[N = \prod_{i=1}^k n_i]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>N</mml:mi><mml:mo>=</mml:mo><mml:msubsup><mml:mo>âˆ</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:msubsup><mml:msub><mml:mi>n</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>,
    or equivalently tensors of shape <inline-formula><alternatives>
    <tex-math><![CDATA[(n_1, n_2, \dots n_k)]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>n</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mi>â€¦</mml:mi><mml:msub><mml:mi>n</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>.</p>
  </sec>
  <sec id="efficient-implementation-of-kronecker-vector-multiplication">
    <title>Efficient implementation of Kronecker-Vector
    Multiplication</title>
    <p>Whilst a naive implementation of matrix-vector multiplication in
    this space has time and memory complexity of
    <inline-formula><alternatives>
    <tex-math><![CDATA[O(N^2)]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>O</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msup><mml:mi>N</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
    a much more efficient implementation can be achieved. Work on this
    topic can be traced back to Roth
    (<xref alt="1934" rid="ref-Roth1934" ref-type="bibr">1934</xref>),
    however the first direct treatment can be found in Pereyra &amp;
    Scherer
    (<xref alt="1973" rid="ref-Pereyra1973" ref-type="bibr">1973</xref>)
    and Boor
    (<xref alt="1979" rid="ref-DeBoor1979" ref-type="bibr">1979</xref>),
    both of which describe an efficient algorithm for the multiplication
    of a Kronecker product matrix onto a vector/tensor in algebraic
    terms. Later work such as Davio
    (<xref alt="1981" rid="ref-Davio1981" ref-type="bibr">1981</xref>),
    Buis &amp; Dyksen
    (<xref alt="1996" rid="ref-Buis1996" ref-type="bibr">1996</xref>)
    and Fackler
    (<xref alt="2019" rid="ref-Fackler2019" ref-type="bibr">2019</xref>)
    focused on optimising this algorithm further by considering other
    practical issues such as available hardware and physical memory
    layout. In particular, Fackler
    (<xref alt="2019" rid="ref-Fackler2019" ref-type="bibr">2019</xref>)
    proposes the <italic>kronx</italic> algorithm, which forms the basis
    for the implementation found in PyKronecker, with some differences
    resulting from the C-style row-major memory layout used in Python as
    opposed to the Fortran-style column-major layout of Matlab, which
    was the target language of the aforementioned paper. In practice, by
    applying the kronx algorithm, the required memory and time
    complexity is reduced to <inline-formula><alternatives>
    <tex-math><![CDATA[O(N)]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>O</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>N</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
    and <inline-formula><alternatives>
    <tex-math><![CDATA[O(N \sum_{i=1}^k n_i)]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>O</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>N</mml:mi><mml:msubsup><mml:mo>âˆ‘</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:msubsup><mml:msub><mml:mi>n</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
    respectively. This makes it possible to solve many problems that
    would otherwise be intractable.</p>
  </sec>
</sec>
<sec id="statement-of-need">
  <title>Statement of need</title>
  <p>PyKronecker is aimed at researchers in any area of applied
  mathematics where systems involving Kronecker products arise. It has
  been designed with the following specific goals in mind.</p>
  <list list-type="alpha-lower">
    <list-item>
      <label>a)</label>
      <p><italic>To provide a simple and intuitive object-oriented
      interface for manipulating systems involving Kronecker-products
      with Python</italic>.</p>
    </list-item>
  </list>
  <p>In PyKronecker, expressions are written in terms of a high-level
  operator abstraction. Users can define new composite operators by
  applying familiar matrix operations such as scaling, matrix
  addition/multiplication and transposition. This allows Kronecker
  operators to be manipulated as if they are large NumPy arrays,
  removing the need to write efficient but sometimes cryptic expressions
  involving the individual sub-matrices. This can greatly simplify code,
  making it easier to read, debug and refactor, allowing users to focus
  on their research goals without concerning themselves with underlying
  performance.</p>
  <list list-type="alpha-lower">
    <list-item>
      <label>b)</label>
      <p><italic>To execute matrix-vector multiplications in a way that
      is maximally efficient and runs on parallel GPU/TPU
      hardware.</italic></p>
    </list-item>
  </list>
  <p>Significant effort has gone into optimising the execution of
  matrix-vector and matrix-tensor multiplications. In particular, this
  comprises the kronx algorithm, Just In Time (JIT) compilation, and
  parallel processing on GPU/TPU hardware. As a result of this,
  PyKronecker is able to achieve very fast execution times compared to
  alternative implementations (see Table 1) .</p>
  <list list-type="alpha-lower">
    <list-item>
      <label>c)</label>
      <p><italic>To allow automatic differentiation for complex loss
      functions involving Kronecker products.</italic></p>
    </list-item>
  </list>
  <p>Many widely-used optimisation algorithms in Machine Learning (ML),
  such as stochastic gradient descent, rely on rapidly evaluating the
  derivative of an objective function. Automatic differentiation has
  played a key role in accelerating ML research by removing the need to
  manually derive analytical gradients
  (<xref alt="Baydin et al., 2018" rid="ref-baydin2018" ref-type="bibr">Baydin
  et al., 2018</xref>). By integrating with the Jax library, PyKronecker
  enables automatic differentiation of complex functions involving
  Kronecker products out of the box.</p>
  <p>To the best of the our knowledge, no existing software achieves all
  three of these aims.</p>
  <sec id="comparison-with-existing-libraries">
    <title>Comparison with existing libraries</title>
    <p>One potential alternative in Python is the PyLops library which
    provides an interface for general functionally-defined linear
    operators, and includes a Kronecker product implementation
    (<xref alt="Ravasi &amp; Vasconcelos, 2020" rid="ref-Ravasi2020" ref-type="bibr">Ravasi
    &amp; Vasconcelos, 2020</xref>). It also supports GPU acceleration
    with CuPy
    (<xref alt="Okuta et al., 2017" rid="ref-okuta2017" ref-type="bibr">Okuta
    et al., 2017</xref>). However, as a more general library, PyLops
    does not provide support for the Kronecker product of more than two
    matrices, implement a Kronecker sum operator, implement
    matrix-tensor multiplication, or provide automatic differentiation.
    It is also significantly slower than PyKronecker when operating on
    simple NumPy arrays.</p>
    <p>Another alternative is the library Kronecker.jl
    (<xref alt="Stock et al., 2020" rid="ref-Stock2020" ref-type="bibr">Stock
    et al., 2020</xref>), implemented in the Julia programming language
    (<xref alt="Bezanson et al., 2017" rid="ref-bezanson2017" ref-type="bibr">Bezanson
    et al., 2017</xref>). Kronecker.jl has many of the same aims as
    PyKronecker and has a a clean interface, making use of Juliaâ€™s
    support for unicode and infix functions to create Kronecker products
    with a custom <inline-formula><alternatives>
    <tex-math><![CDATA[\otimes]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mo>âŠ—</mml:mo></mml:math></alternatives></inline-formula>
    operator. However, at this time, the library does not support GPU
    acceleration or automatic differentiation, although the former is in
    development.</p>
    <p>Table 1. shows a feature comparison of these libraries, along
    with the kronx algorithm implemented in â€œvanillaâ€ (i.e., running on
    the CPU without JIT compilation) NumPy. The table also shows the
    time to compute the multiplication of a Kronecker product against a
    vector in two scenarios. In the first scenario, the Kronecker
    product is constructed from two matrices of size
    <inline-formula><alternatives>
    <tex-math><![CDATA[(400 \times 400)]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>400</mml:mn><mml:mo>Ã—</mml:mo><mml:mn>400</mml:mn><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>
    and <inline-formula><alternatives>
    <tex-math><![CDATA[(500 \times 500)]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>500</mml:mn><mml:mo>Ã—</mml:mo><mml:mn>500</mml:mn><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>,
    and in the second scenario Kronecker product is constructed from
    three matrices of size <inline-formula><alternatives>
    <tex-math><![CDATA[(100 \times 100)]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>100</mml:mn><mml:mo>Ã—</mml:mo><mml:mn>100</mml:mn><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>,
    <inline-formula><alternatives>
    <tex-math><![CDATA[(150 \times 150)]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>150</mml:mn><mml:mo>Ã—</mml:mo><mml:mn>150</mml:mn><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>
    and <inline-formula><alternatives>
    <tex-math><![CDATA[(200 \times 200)]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>200</mml:mn><mml:mo>Ã—</mml:mo><mml:mn>200</mml:mn><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>,
    respectively. Experiments were performed with an Intel Core 2.80GHz
    i7-7700HQ CPU, and an Nvidia 1050Ti GPU. In both cases, PyKronecker
    on the GPU is the fastest by a significant margin.</p>
    <table-wrap>
      <table>
        <colgroup>
          <col width="18%" />
          <col width="6%" />
          <col width="10%" />
          <col width="12%" />
          <col width="24%" />
          <col width="30%" />
        </colgroup>
        <thead>
          <tr>
            <th>Implementation</th>
            <th>Python</th>
            <th>Auto-diff</th>
            <th>GPU support</th>
            <th>Compute time (400, 500)</th>
            <th>Compute time (100, 150, 200)</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>NumPy</td>
            <td>Yes</td>
            <td>No</td>
            <td>No</td>
            <td>5.04 ms Â± 343 Âµs</td>
            <td>38.9 ms Â± 4.07 ms</td>
          </tr>
          <tr>
            <td>Kronecker.jl</td>
            <td>No</td>
            <td>No</td>
            <td>No</td>
            <td>9.61 ms Â± 881 Âµs</td>
            <td>380 ms Â± 6.15 ms</td>
          </tr>
          <tr>
            <td>PyLops (CPU)</td>
            <td>Yes</td>
            <td>No</td>
            <td>No</td>
            <td>17.9 ms Â± 986 Âµs</td>
            <td>478 ms Â± 4.79 ms</td>
          </tr>
          <tr>
            <td>PyLops (GPU)</td>
            <td>Yes</td>
            <td>No</td>
            <td>Yes</td>
            <td>54.6 ms Â± 1.04 ms</td>
            <td>4.06 s Â± 182 ms</td>
          </tr>
          <tr>
            <td>PyKronecker (CPU)</td>
            <td>Yes</td>
            <td>Yes</td>
            <td>No</td>
            <td>1.92 ms Â± 136 Âµs</td>
            <td>15.1 ms Â± 2.24 ms</td>
          </tr>
          <tr>
            <td>PyKronecker (GPU)</td>
            <td>Yes</td>
            <td>Yes</td>
            <td>Yes</td>
            <td>261 Âµs Â± 17.3 Âµs</td>
            <td>220 Âµs Â± 59.5 Âµs</td>
          </tr>
        </tbody>
      </table>
    </table-wrap>
  </sec>
</sec>
<sec id="outlook-and-future-work">
  <title>Outlook and Future Work</title>
  <p>There are several features that we are developing to expand the
  functionality of PyKronecker. The first is to provide support for
  non-square operators. In a typical problem, the Kronecker operators
  encountered represent simple linear transformations which preserve
  dimensionality. However, there are a significant minority of contexts
  where this is not the case. The inclusion of this feature would
  increase the range of possible applications. Secondly, we would like
  to add support for sparse matrices. This would enable computation with
  larger matrices and faster execution times where applicable. However
  this would require integration with Jaxâ€™s sparse module, which is
  currently under development. Finally, for convenience, it may be
  useful to add some commonly used algorithms such as the conjugate
  gradient method for solving linear systems
  (<xref alt="Shewchuk, 1994" rid="ref-shewchuk1994" ref-type="bibr">Shewchuk,
  1994</xref>), least squares, and various matrix decompositions such as
  eigenvalue, Cholesky and LU.</p>
</sec>
<sec id="acknowledgements">
  <title>Acknowledgements</title>
  <p>Thank you to Chris Krapu for valuable discussions, especially with
  regard to integrating PyKronecker with Jax, and automatic
  differentiation.</p>
</sec>
</body>
<back>
<ref-list>
  <ref id="ref-loan2000">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Loan</surname><given-names>Charles F.Van</given-names></name>
      </person-group>
      <article-title>The ubiquitous Kronecker product</article-title>
      <source>Journal of Computational and Applied Mathematics</source>
      <year iso-8601-date="2000">2000</year>
      <volume>123</volume>
      <issue>1</issue>
      <issn>0377-0427</issn>
      <uri>https://doi.org/10.1016/S0377-0427(00)00393-9</uri>
      <pub-id pub-id-type="doi">10.1016/S0377-0427(00)00393-9</pub-id>
      <fpage>85</fpage>
      <lpage>100</lpage>
    </element-citation>
  </ref>
  <ref id="ref-harris2020">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Harris</surname><given-names>Charles R.</given-names></name>
        <name><surname>Millman</surname><given-names>K. Jarrod</given-names></name>
        <name><surname>Walt</surname><given-names>StÃ©fan J. van der</given-names></name>
        <name><surname>Gommers</surname><given-names>Ralf</given-names></name>
        <name><surname>Virtanen</surname><given-names>Pauli</given-names></name>
        <name><surname>Cournapeau</surname><given-names>David</given-names></name>
        <name><surname>Wieser</surname><given-names>Eric</given-names></name>
        <name><surname>Taylor</surname><given-names>Julian</given-names></name>
        <name><surname>Berg</surname><given-names>Sebastian</given-names></name>
        <name><surname>Smith</surname><given-names>Nathaniel J.</given-names></name>
        <name><surname>Kern</surname><given-names>Robert</given-names></name>
        <name><surname>Picus</surname><given-names>Matti</given-names></name>
        <name><surname>Hoyer</surname><given-names>Stephan</given-names></name>
        <name><surname>Kerkwijk</surname><given-names>Marten H. van</given-names></name>
        <name><surname>Brett</surname><given-names>Matthew</given-names></name>
        <name><surname>Haldane</surname><given-names>Allan</given-names></name>
        <name><surname>RÃ­o</surname><given-names>Jaime FernÃ¡ndez del</given-names></name>
        <name><surname>Wiebe</surname><given-names>Mark</given-names></name>
        <name><surname>Peterson</surname><given-names>Pearu</given-names></name>
        <name><surname>GÃ©rard-Marchant</surname><given-names>Pierre</given-names></name>
        <name><surname>Sheppard</surname><given-names>Kevin</given-names></name>
        <name><surname>Reddy</surname><given-names>Tyler</given-names></name>
        <name><surname>Weckesser</surname><given-names>Warren</given-names></name>
        <name><surname>Abbasi</surname><given-names>Hameer</given-names></name>
        <name><surname>Gohlke</surname><given-names>Christoph</given-names></name>
        <name><surname>Oliphant</surname><given-names>Travis E.</given-names></name>
      </person-group>
      <article-title>Array programming with NumPy</article-title>
      <source>Nature</source>
      <publisher-name>Springer Science; Business Media LLC</publisher-name>
      <year iso-8601-date="2020-09">2020</year><month>09</month>
      <volume>585</volume>
      <issue>7825</issue>
      <uri>https://doi.org/10.1038/s41586-020-2649-2</uri>
      <pub-id pub-id-type="doi">10.1038/s41586-020-2649-2</pub-id>
      <fpage>357</fpage>
      <lpage>362</lpage>
    </element-citation>
  </ref>
  <ref id="ref-jax2018">
    <element-citation publication-type="book">
      <person-group person-group-type="author">
        <name><surname>Bradbury</surname><given-names>James</given-names></name>
        <name><surname>Frostig</surname><given-names>Roy</given-names></name>
        <name><surname>Hawkins</surname><given-names>Peter</given-names></name>
        <name><surname>Johnson</surname><given-names>Matthew James</given-names></name>
        <name><surname>Leary</surname><given-names>Chris</given-names></name>
        <name><surname>Maclaurin</surname><given-names>Dougal</given-names></name>
        <name><surname>Necula</surname><given-names>George</given-names></name>
        <name><surname>Paszke</surname><given-names>Adam</given-names></name>
        <name><surname>VanderPlas</surname><given-names>Jake</given-names></name>
        <name><surname>Wanderman-Milne</surname><given-names>Skye</given-names></name>
        <name><surname>Zhang</surname><given-names>Qiao</given-names></name>
      </person-group>
      <source>JAX: Composable transformations of Python+NumPy programs</source>
      <year iso-8601-date="2018">2018</year>
      <uri>http://github.com/google/jax</uri>
    </element-citation>
  </ref>
  <ref id="ref-Ravasi2020">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Ravasi</surname><given-names>Matteo</given-names></name>
        <name><surname>Vasconcelos</surname><given-names>Ivan</given-names></name>
      </person-group>
      <article-title>PyLopsâ€”a linear-operator python library for scalable algebra and optimization</article-title>
      <source>SoftwareX</source>
      <year iso-8601-date="2020">2020</year>
      <volume>11</volume>
      <issn>2352-7110</issn>
      <uri>https://www.sciencedirect.com/science/article/pii/S2352711019301086</uri>
      <pub-id pub-id-type="doi">10.1016/j.softx.2019.100361</pub-id>
      <fpage>100361</fpage>
      <lpage></lpage>
    </element-citation>
  </ref>
  <ref id="ref-Stock2020">
    <element-citation publication-type="paper-conference">
      <person-group person-group-type="author">
        <name><surname>Stock</surname><given-names>Michiel</given-names></name>
        <name><surname>Pahikkala</surname><given-names>Tapio</given-names></name>
        <name><surname>Airola</surname><given-names>Antti</given-names></name>
        <name><surname>Baets</surname><given-names>Bernard De</given-names></name>
      </person-group>
      <article-title>A general-purpose toolbox for efficient Kronecker-based learning</article-title>
      <year iso-8601-date="2020">2020</year>
      <uri>https://doi.org/10.21105/jcon.00015</uri>
      <pub-id pub-id-type="doi">10.21105/jcon.00015</pub-id>
    </element-citation>
  </ref>
  <ref id="ref-baydin2018">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Baydin</surname><given-names>Atilim Gunes</given-names></name>
        <name><surname>Pearlmutter</surname><given-names>Barak A</given-names></name>
        <name><surname>Radul</surname><given-names>Alexey Andreyevich</given-names></name>
        <name><surname>Siskind</surname><given-names>Jeffrey Mark</given-names></name>
      </person-group>
      <article-title>Automatic differentiation in machine learning: A survey</article-title>
      <source>Journal of Marchine Learning Research</source>
      <publisher-name>Microtome Publishing</publisher-name>
      <year iso-8601-date="2018">2018</year>
      <volume>18</volume>
      <uri>https://doi.org/10.48550/arXiv.1502.05767</uri>
      <pub-id pub-id-type="doi">10.48550/arXiv.1502.05767</pub-id>
      <fpage>1</fpage>
      <lpage>43</lpage>
    </element-citation>
  </ref>
  <ref id="ref-okuta2017">
    <element-citation publication-type="paper-conference">
      <person-group person-group-type="author">
        <name><surname>Okuta</surname><given-names>Ryosuke</given-names></name>
        <name><surname>Unno</surname><given-names>Yuya</given-names></name>
        <name><surname>Nishino</surname><given-names>Daisuke</given-names></name>
        <name><surname>Hido</surname><given-names>Shohei</given-names></name>
        <name><surname>Loomis</surname><given-names>Crissman</given-names></name>
      </person-group>
      <article-title>CuPy: A NumPy-compatible library for NVIDIA GPU calculations</article-title>
      <source>Proceedings of workshop on machine learning systems (LearningSys) in the thirty-first annual conference on neural information processing systems (NIPS)</source>
      <year iso-8601-date="2017">2017</year>
      <uri>http://learningsys.org/nips17/assets/papers/paper_16.pdf</uri>
    </element-citation>
  </ref>
  <ref id="ref-bezanson2017">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Bezanson</surname><given-names>Jeff</given-names></name>
        <name><surname>Edelman</surname><given-names>Alan</given-names></name>
        <name><surname>Karpinski</surname><given-names>Stefan</given-names></name>
        <name><surname>Shah</surname><given-names>Viral B</given-names></name>
      </person-group>
      <article-title>Julia: A fresh approach to numerical computing</article-title>
      <source>SIAM review</source>
      <publisher-name>SIAM</publisher-name>
      <year iso-8601-date="2017">2017</year>
      <volume>59</volume>
      <issue>1</issue>
      <uri>https://doi.org/10.1137/141000671</uri>
      <pub-id pub-id-type="doi">10.1137/141000671</pub-id>
      <fpage>65</fpage>
      <lpage>98</lpage>
    </element-citation>
  </ref>
  <ref id="ref-shewchuk1994">
    <element-citation publication-type="paper-conference">
      <person-group person-group-type="author">
        <name><surname>Shewchuk</surname><given-names>Jonathan Richard</given-names></name>
      </person-group>
      <article-title>An introduction to the conjugate gradient method without the agonizing pain</article-title>
      <year iso-8601-date="1994">1994</year>
      <uri>https://www.cs.cmu.edu/~quake-papers/painless-conjugate-gradient.pdf</uri>
    </element-citation>
  </ref>
  <ref id="ref-Roth1934">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Roth</surname><given-names>W E</given-names></name>
      </person-group>
      <article-title>On direct product matrices</article-title>
      <source>Bulletin of the American Mathematical Society</source>
      <year iso-8601-date="1934">1934</year>
      <uri>https://doi.org/10.2307/3609497</uri>
      <pub-id pub-id-type="doi">10.2307/3609497</pub-id>
    </element-citation>
  </ref>
  <ref id="ref-Pereyra1973">
    <element-citation publication-type="report">
      <person-group person-group-type="author">
        <name><surname>Pereyra</surname><given-names>V</given-names></name>
        <name><surname>Scherer</surname><given-names>G</given-names></name>
      </person-group>
      <article-title>Efficient computer manipulation of tensor products with applications to multidimensional approximation</article-title>
      <year iso-8601-date="1973">1973</year>
      <volume>27</volume>
      <uri>https://doi.org/10.1090/s0025-5718-1973-0395196-6</uri>
      <pub-id pub-id-type="doi">10.1090/s0025-5718-1973-0395196-6</pub-id>
    </element-citation>
  </ref>
  <ref id="ref-DeBoor1979">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Boor</surname><given-names>Carl De</given-names></name>
      </person-group>
      <article-title>Efficient computer manipulation of tensor products</article-title>
      <source>ACM Transactions on Mathematmal Software</source>
      <year iso-8601-date="1979">1979</year>
      <volume>5</volume>
      <uri>https://doi.org/10.1145/355826.355831</uri>
      <pub-id pub-id-type="doi">10.1145/355826.355831</pub-id>
      <fpage>173</fpage>
      <lpage>182</lpage>
    </element-citation>
  </ref>
  <ref id="ref-Davio1981">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Davio</surname><given-names>Marc</given-names></name>
      </person-group>
      <article-title>Kronecker products and shuffle algebra</article-title>
      <source>IEEE Transactions on Computers</source>
      <year iso-8601-date="1981">1981</year>
      <volume>C-30</volume>
      <uri>https://doi.org/10.1109/TC.1981.6312174</uri>
      <pub-id pub-id-type="doi">10.1109/TC.1981.6312174</pub-id>
      <fpage>116</fpage>
      <lpage>125</lpage>
    </element-citation>
  </ref>
  <ref id="ref-Buis1996">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Buis</surname><given-names>Paul E</given-names></name>
        <name><surname>Dyksen</surname><given-names>Wayne R</given-names></name>
      </person-group>
      <article-title>Efficient vector and parallel manipulation tensor products</article-title>
      <source>ACM Transactions on Mathematical Software</source>
      <year iso-8601-date="1996">1996</year>
      <uri>https://doi.org/10.1145/225545.225548</uri>
      <pub-id pub-id-type="doi">10.1145/225545.225548</pub-id>
    </element-citation>
  </ref>
  <ref id="ref-Fackler2019">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Fackler</surname><given-names>Paul L.</given-names></name>
      </person-group>
      <article-title>Algorithm 993: Efficient computation with Kronecker products</article-title>
      <source>ACM Trans. Math. Softw.</source>
      <publisher-name>Association for Computing Machinery</publisher-name>
      <publisher-loc>New York, NY, USA</publisher-loc>
      <year iso-8601-date="2019-05">2019</year><month>05</month>
      <volume>45</volume>
      <issue>2</issue>
      <uri>https://doi.org/10.1145/3291041</uri>
      <pub-id pub-id-type="doi">10.1145/3291041</pub-id>
    </element-citation>
  </ref>
</ref-list>
</back>
</article>
