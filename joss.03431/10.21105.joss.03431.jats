<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN"
                  "JATS-publishing1.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" dtd-version="1.2" article-type="other">
<front>
<journal-meta>
<journal-id></journal-id>
<journal-title-group>
<journal-title>Journal of Open Source Software</journal-title>
<abbrev-journal-title>JOSS</abbrev-journal-title>
</journal-title-group>
<issn publication-format="electronic">2475-9066</issn>
<publisher>
<publisher-name>Open Journals</publisher-name>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="publisher-id">3431</article-id>
<article-id pub-id-type="doi">10.21105/joss.03431</article-id>
<title-group>
<article-title>Computer-Aided Generation of N-shift RWS</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author">
<contrib-id contrib-id-type="orcid">https://orcid.org/0000-0002-6650-5365</contrib-id>
<name>
<surname>Bolling</surname>
<given-names>Benjamin Edward</given-names>
</name>
<xref ref-type="aff" rid="aff-1"/>
</contrib>
<aff id="aff-1">
<institution-wrap>
<institution>European Spallation Source ERIC</institution>
</institution-wrap>
</aff>
</contrib-group>
<pub-date date-type="pub" publication-format="electronic" iso-8601-date="2021-09-25">
<day>25</day>
<month>9</month>
<year>2021</year>
</pub-date>
<volume>8</volume>
<issue>82</issue>
<fpage>3431</fpage>
<permissions>
<copyright-statement>Authors of papers retain copyright and release the
work under a Creative Commons Attribution 4.0 International License (CC
BY 4.0)</copyright-statement>
<copyright-year>2022</copyright-year>
<copyright-holder>The article authors</copyright-holder>
<license license-type="open-access" xlink:href="https://creativecommons.org/licenses/by/4.0/">
<license-p>Authors of papers retain copyright and release the work under
a Creative Commons Attribution 4.0 International License (CC BY
4.0)</license-p>
</license>
</permissions>
<kwd-group kwd-group-type="author">
<kwd>Python</kwd>
<kwd>Workforce scheduling</kwd>
<kwd>Shift</kwd>
<kwd>Two-shift</kwd>
<kwd>Three-shift</kwd>
<kwd>Rotating Shift Work</kwd>
<kwd>Rotational Workforce</kwd>
<kwd>Scheduling</kwd>
<kwd>Schedules</kwd>
<kwd>Combinatoric-Generator</kwd>
<kwd>Cartesian-Product</kwd>
</kwd-group>
</article-meta>
</front>
<body>
<sec id="statement-of-need">
  <title>Statement of Need</title>
  <p>All around the world, research institutes and industrial complexes
  make use of workforces working multiple shifts per day in order to
  utilise maximum efficiency and profitability of the facility. Creating
  shift work schedules has, however, always been a challenging task,
  especially such that are equal for all workers and at the same time
  distributes the shifts evenly and properly to prevent staff burnout
  (<xref alt="Becker, 2020" rid="ref-TristanU003A2020" ref-type="bibr">Becker,
  2020</xref>).</p>
  <p>The purpose and aim of this package is to support research
  institutes and industrial complexes at which non-standard working
  hours are applicable with a computational tool to create rotational
  workforce schedules by providing the user (schedule-maker) with all
  possible schedules for a set of input constraints/conditions (such as
  shift lengths, weekly working hours and -resting time) by constructing
  and utilising a Combinatoric Generator and a Cartesian Product
  calculator.</p>
  <p>Comparing to already available software that (by the
  developer/author) could be found, this method uses a computational
  semi-automatic approach rather than the more traditional manual
  creation of schedules. This computational approach is also able to
  check and identify every combination that could satisfy the required
  rotational workforce schedule, if there are any that fully satisfy the
  requirements. Hence, this application can be used as an aid for
  schedule-makers by being either supplied with ready schedules or by
  schedules working as good starting points. It can therefore also be
  considered as an attempt to implement a slightly different method,
  which e.g. together with other shift scheduling methods may be
  combined to find more strategic methods for building rotational shift
  workforce schedules.</p>
  <p>Another approach and need of the application is to serve as a
  support function for creating rotational shift workforce schedules for
  large-scale scientific research facilities such as particle
  accelerators, at which the workforce size is many time very
  constrained. In those situations, the creation of schedules can be
  very complex and difficult, making a tool such as this useful. In
  other cases, it can be used to prove that the constraints are too
  tight and that these cannot be fulfilled by any schedule, saving time
  for shift schedulers and hence also for the research facility.</p>
  <p>This package provides a graphical user interface (based on PyQt5
  (<xref alt="Riverbank Computing Limited, 2016" rid="ref-PyQtReference" ref-type="bibr">Riverbank
  Computing Limited, 2016</xref>)) tool for generating and constructing
  acceptable shift arrays if there are any possible arrays following all
  user-defined constraints. These can be exported to the file formats
  ODS, CSV, and txt, with the arrays ready to be used as they are or as
  templates for further modifications (e.g. swapping shifts between
  workers and hence taking into account individual workers’ needs).</p>
  <sec id="introduction">
    <title>Introduction</title>
    <p>In order to achieve schedules for the workers that treats
    everyone equally, the focus of this package is on so-called
    rotational workforce schedules (RWSs). Rotational workforce
    schedules means that the schedule rotates after time, and hence, the
    other option would be static shift schedules. In this project, the
    term ‘shift arrays’ is defined to represent all possible schedules
    following a list of constraints, originating from e.g. country laws,
    organisational needs, and/or workforce requests.</p>
  </sec>
  <sec id="computational-approach-and-results">
    <title>Computational Approach and Results</title>
    <p>In this approach, each worker has the same schedule shifted by
    one week, resulting in that all workers follow the same schedule.
    The project has been divided into two phases, <italic>Boolean Shift
    Arrays</italic> (in which boolean shift arrays are generated) and
    <italic>From Boolean Shift Arrays to a RWS</italic> (in which a
    selected boolean shift array is shaped into its final RWS layout).
    The high-level software architecture flow and a user flowchart can
    be seen in
    <xref alt="[fig:flow]" rid="figU003Aflow">[fig:flow]</xref> and
    <xref alt="[fig:userflow]" rid="figU003Auserflow">[fig:userflow]</xref>,
    respectively.</p>
    <sec id="boolean-shift-arrays-phase-1">
      <title>Boolean Shift Arrays (phase 1)</title>
      <p>A boolean shift array is defined such that 1 means that the
      worker is working and 0 that the worker is not. The input species
      (also known as constraints) and their respective values used are
      shown in Table 1 below.</p>
      <p>Table 1: Constraints, i.e. the variables and their meanings,
      and some example values.</p>
      <table-wrap>
        <table>
          <thead>
            <tr>
              <th align="left">Variable</th>
              <th align="center">Meaning</th>
              <th align="center">Value</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left"><inline-formula><alternatives>
              <tex-math><![CDATA[N]]></tex-math>
              <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>N</mml:mi></mml:math></alternatives></inline-formula></td>
              <td align="center">number of shifts per days</td>
              <td align="center">2</td>
            </tr>
            <tr>
              <td align="left"><inline-formula><alternatives>
              <tex-math><![CDATA[n_{cf}]]></tex-math>
              <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>n</mml:mi><mml:mrow><mml:mi>c</mml:mi><mml:mi>f</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula></td>
              <td align="center">number of days off clustered</td>
              <td align="center">-</td>
            </tr>
            <tr>
              <td align="left"><inline-formula><alternatives>
              <tex-math><![CDATA[n_{S}]]></tex-math>
              <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>n</mml:mi><mml:mi>S</mml:mi></mml:msub></mml:math></alternatives></inline-formula></td>
              <td align="center">number of shifts per shift cycle</td>
              <td align="center">18</td>
            </tr>
            <tr>
              <td align="left"><inline-formula><alternatives>
              <tex-math><![CDATA[n_{W}]]></tex-math>
              <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>n</mml:mi><mml:mi>W</mml:mi></mml:msub></mml:math></alternatives></inline-formula></td>
              <td align="center">number of weeks to cycle over</td>
              <td align="center">4</td>
            </tr>
            <tr>
              <td align="left"><inline-formula><alternatives>
              <tex-math><![CDATA[n_{wd}]]></tex-math>
              <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>n</mml:mi><mml:mrow><mml:mi>w</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula></td>
              <td align="center">number of working days per week</td>
              <td align="center">7</td>
            </tr>
            <tr>
              <td align="left"><inline-formula><alternatives>
              <tex-math><![CDATA[n_{wS}]]></tex-math>
              <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>n</mml:mi><mml:mrow><mml:mi>w</mml:mi><mml:mi>S</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula></td>
              <td align="center">Number of workers per shift
              (minimum)</td>
              <td align="center">1</td>
            </tr>
            <tr>
              <td align="left"><inline-formula><alternatives>
              <tex-math><![CDATA[t_{d}]]></tex-math>
              <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>t</mml:mi><mml:mi>d</mml:mi></mml:msub></mml:math></alternatives></inline-formula></td>
              <td align="center">daily minimum continuous resting
              time</td>
              <td align="center">11</td>
            </tr>
            <tr>
              <td align="left"><inline-formula><alternatives>
              <tex-math><![CDATA[t_{r}]]></tex-math>
              <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>t</mml:mi><mml:mi>r</mml:mi></mml:msub></mml:math></alternatives></inline-formula></td>
              <td align="center">weekly minimum single continuous
              resting time</td>
              <td align="center">36</td>
            </tr>
            <tr>
              <td align="left"><inline-formula><alternatives>
              <tex-math><![CDATA[t_{s}]]></tex-math>
              <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>t</mml:mi><mml:mi>s</mml:mi></mml:msub></mml:math></alternatives></inline-formula></td>
              <td align="center">shift lengths</td>
              <td align="center">8.33</td>
            </tr>
            <tr>
              <td align="left"><inline-formula><alternatives>
              <tex-math><![CDATA[t_{W}]]></tex-math>
              <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>t</mml:mi><mml:mi>W</mml:mi></mml:msub></mml:math></alternatives></inline-formula></td>
              <td align="center">weekly working hours per worker</td>
              <td align="center">36.00</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
      <p>Since each week also resembles a worker, the shift array can be
      set up as a matrix with 7 columns (each representing the days of a
      week) and <inline-formula><alternatives>
      <tex-math><![CDATA[n_{W}/7]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mi>W</mml:mi></mml:msub><mml:mi>/</mml:mi><mml:mn>7</mml:mn></mml:mrow></mml:math></alternatives></inline-formula>
      rows (each representing a worker). The columns can then be summed
      to achieve the shift occupancy (or how many people are working
      each shift). Thus, the phase1 algorithm only allows shift arrays
      to pass for which all shifts are occupied by at least one worker,
      with a shift represented by the first
      <inline-formula><alternatives>
      <tex-math><![CDATA[n_{wd}]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>n</mml:mi><mml:mrow><mml:mi>w</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>
      days for each week. In order to extend to not only use single
      shifts but also 2- or 3-shifts, a logical condition was added into
      the algorithm: For <inline-formula><alternatives>
      <tex-math><![CDATA[N]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>N</mml:mi></mml:math></alternatives></inline-formula>
      shifts per day, each day has to be filled with at least
      <inline-formula><alternatives>
      <tex-math><![CDATA[N]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>N</mml:mi></mml:math></alternatives></inline-formula>
      workers.</p>
      <p>In order to avoid all working days from being clustered
      together, the constraint for weekly minimum single continuous
      resting time is added (<inline-formula><alternatives>
      <tex-math><![CDATA[t_{r}]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>t</mml:mi><mml:mi>r</mml:mi></mml:msub></mml:math></alternatives></inline-formula>).
      The algorithm ensures that all passed shift arrays have at least
      <inline-formula><alternatives>
      <tex-math><![CDATA[t_r]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>t</mml:mi><mml:mi>r</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
      hours of free-time over any given 7-day period.</p>
      <p>The number of shifts per shift array is, in this algorithm,
      calculated by</p>
      <p><disp-formula><alternatives>
      <tex-math><![CDATA[n_{S} = \text{ceil}(t_W / t_s)]]></tex-math>
      <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mi>S</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mtext mathvariant="normal">ceil</mml:mtext><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mi>W</mml:mi></mml:msub><mml:mi>/</mml:mi><mml:msub><mml:mi>t</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></disp-formula></p>
      <p>to have the reason for using ceiling function (and not the
      floor function) being the argument that it is better with a couple
      of more hours than fewer. In order to cluster days off
      (<inline-formula><alternatives>
      <tex-math><![CDATA[n_{cf}]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>n</mml:mi><mml:mrow><mml:mi>c</mml:mi><mml:mi>f</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>),
      the algorithm’s GUI has an optional additional constraint that
      serves this purpose and simply does not allow shift arrays with
      zeroes in clusters less than this through.</p>
      <p>By using the input <inline-formula><alternatives>
      <tex-math><![CDATA[n_W \times n_{wd}]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mi>W</mml:mi></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>n</mml:mi><mml:mrow><mml:mi>w</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>
      as the iterable and <inline-formula><alternatives>
      <tex-math><![CDATA[n_{S}]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>n</mml:mi><mml:mi>S</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
      as the length of subsequences of elements from the iterable, the
      same methodology as the <italic>combinations</italic> function of
      the <italic>itertools</italic> module in Python
      (<xref alt="Python Software Foundation, 2020" rid="ref-PythonReference" ref-type="bibr">Python
      Software Foundation, 2020</xref>) (a combinatoric generator) is
      used for creating each shift array. It can be simply described as
      creating an array of combinations (in this case, zeroes and ones
      corresponding to a day off or shift work, respectively) with a
      specific length (number of days in a cycle). By imposing the other
      inputs as constraints on whether a shift array should be appended
      to accepted shift arrays, the reason for not using the built-in
      Python module becomes clear: Python’s built-in module returns all
      array combinations that are possible without any imposed
      constraints, which quickly escalates to becoming too large for a
      personal computer’s internal memory to handle.</p>
      <p>With this, the final result is an array of shift arrays in
      which each shift array is filled with
      <inline-formula><alternatives>
      <tex-math><![CDATA[7n_{S}]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mn>7</mml:mn><mml:msub><mml:mi>n</mml:mi><mml:mi>S</mml:mi></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>
      ones and <inline-formula><alternatives>
      <tex-math><![CDATA[n_{W}(7-n_{S})]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mi>W</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>7</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mi>n</mml:mi><mml:mi>S</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
      zeroes whilst obeying the above mentioned constraints.</p>
      <p>As there are <inline-formula><alternatives>
      <tex-math><![CDATA[{n\choose r}]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mfrac linethickness="0"><mml:mi>n</mml:mi><mml:mi>r</mml:mi></mml:mfrac><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>
      ways to choose r elements from a set of n elements, the number of
      possible combinations (<inline-formula><alternatives>
      <tex-math><![CDATA[C]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>C</mml:mi></mml:math></alternatives></inline-formula>)
      can be expressed by using the factorial of the binomial
      coefficient:</p>
      <p><disp-formula><alternatives>
      <tex-math><![CDATA[C = \frac{n!}{r! \times (n-r)!}.]]></tex-math>
      <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>C</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>n</mml:mi><mml:mi>!</mml:mi></mml:mrow><mml:mrow><mml:mi>r</mml:mi><mml:mi>!</mml:mi><mml:mo>×</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mi>!</mml:mi></mml:mrow></mml:mfrac><mml:mi>.</mml:mi></mml:mrow></mml:math></alternatives></disp-formula></p>
      <p>with <inline-formula><alternatives>
      <tex-math><![CDATA[n]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>n</mml:mi></mml:math></alternatives></inline-formula>
      being the number of days in total in a shift cycle and
      <inline-formula><alternatives>
      <tex-math><![CDATA[r]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>r</mml:mi></mml:math></alternatives></inline-formula>
      being the number of working days per worker in the shift
      cycle.</p>
      <p>Translating this into the variables defined in Table 1 yields
      the total number of combinations (without constraints), which is
      hence also the maximum number of accepted combinations:</p>
      <p><disp-formula><alternatives>
      <tex-math><![CDATA[C = \frac{n_{W} \times n_{wd}!}{n_{S}!(n_{W} \times n_{wd} - n_{S}!)}.]]></tex-math>
      <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>C</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mi>W</mml:mi></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>n</mml:mi><mml:mrow><mml:mi>w</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:msub><mml:mi>!</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mi>S</mml:mi></mml:msub><mml:mi>!</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>n</mml:mi><mml:mi>W</mml:mi></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>n</mml:mi><mml:mrow><mml:mi>w</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>n</mml:mi><mml:mi>S</mml:mi></mml:msub><mml:mi>!</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:mfrac><mml:mi>.</mml:mi></mml:mrow></mml:math></alternatives></disp-formula></p>
    </sec>
    <sec id="from-boolean-shift-arrays-to-rws-phase-2">
      <title>From Boolean Shift Arrays to RWS (phase 2)</title>
      <p>In this phase, a new list of combinations with free days
      clustered in pairs has been generated and a combination selected
      to proceed with (combination 212 as it has two out of four
      weekends off (note the zeroes in the bottom table in
      <xref alt="[fig:phase1]" rid="figU003Aphase1">[fig:phase1]</xref>
      to the right).</p>
      <p>Pressing the <italic>Find solutions</italic> results in what is
      shown in
      <xref alt="[fig:phase2]" rid="figU003Aphase2">[fig:phase2]</xref>
      (right figure). A schedule can also be constructed completely by
      hand, but note that the algorithm will find all possible
      combinations that obey the given constraints. The algorithm is a
      Cartesian Product calculator, in which each set is a list of
      shifts (1 = Day, 2 = Evening, etc.) with one set per working
      day:</p>
      <p><disp-formula><alternatives>
      <tex-math><![CDATA[\text{combinations} =
      \begin{pmatrix}
      1\\
      2\\
      \vdots
      \end{pmatrix} \times
      \begin{pmatrix}
      1\\
      2\\
      \vdots
      \end{pmatrix}  \times \hdots \times
      \begin{pmatrix}
      1\\
      2\\
      \vdots
      \end{pmatrix} =
      \prod_{i=1}^{n_{wd}}
      \begin{pmatrix}
      1\\
      2\\
      \vdots
      \end{pmatrix}_{i}
      =
      \begin{cases}
      [1\text{ }1\text{ }\hdots\text{ }1]\\
      [1\text{ }1\text{ }\hdots\text{ }2]\\
      \vdots\\
      [2\text{ }2\text{ }\hdots\text{ }1]\\
      [2\text{ }2\text{ }\hdots\text{ }2]
      \end{cases}]]></tex-math>
      <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mtext mathvariant="normal">combinations</mml:mtext><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mtable><mml:mtr><mml:mtd columnalign="center" style="text-align: center"><mml:mn>1</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="center" style="text-align: center"><mml:mn>2</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="center" style="text-align: center"><mml:mi>⋮</mml:mi></mml:mtd></mml:mtr></mml:mtable><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>×</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mtable><mml:mtr><mml:mtd columnalign="center" style="text-align: center"><mml:mn>1</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="center" style="text-align: center"><mml:mn>2</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="center" style="text-align: center"><mml:mi>⋮</mml:mi></mml:mtd></mml:mtr></mml:mtable><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>×</mml:mo><mml:mi>…</mml:mi><mml:mo>×</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mtable><mml:mtr><mml:mtd columnalign="center" style="text-align: center"><mml:mn>1</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="center" style="text-align: center"><mml:mn>2</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="center" style="text-align: center"><mml:mi>⋮</mml:mi></mml:mtd></mml:mtr></mml:mtable><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:munderover><mml:mo>∏</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mrow><mml:mi>w</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:msub></mml:munderover><mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mtable><mml:mtr><mml:mtd columnalign="center" style="text-align: center"><mml:mn>1</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="center" style="text-align: center"><mml:mn>2</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="center" style="text-align: center"><mml:mi>⋮</mml:mi></mml:mtd></mml:mtr></mml:mtable><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">{</mml:mo><mml:mtable><mml:mtr><mml:mtd columnalign="left" style="text-align: left"><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mn>1</mml:mn><mml:mrow><mml:mspace width="0.333em"></mml:mspace><mml:mtext mathvariant="normal"> </mml:mtext><mml:mspace width="0.333em"></mml:mspace></mml:mrow><mml:mn>1</mml:mn><mml:mrow><mml:mspace width="0.333em"></mml:mspace><mml:mtext mathvariant="normal"> </mml:mtext><mml:mspace width="0.333em"></mml:mspace></mml:mrow><mml:mi>…</mml:mi><mml:mrow><mml:mspace width="0.333em"></mml:mspace><mml:mtext mathvariant="normal"> </mml:mtext><mml:mspace width="0.333em"></mml:mspace></mml:mrow><mml:mn>1</mml:mn><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left" style="text-align: left"><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mn>1</mml:mn><mml:mrow><mml:mspace width="0.333em"></mml:mspace><mml:mtext mathvariant="normal"> </mml:mtext><mml:mspace width="0.333em"></mml:mspace></mml:mrow><mml:mn>1</mml:mn><mml:mrow><mml:mspace width="0.333em"></mml:mspace><mml:mtext mathvariant="normal"> </mml:mtext><mml:mspace width="0.333em"></mml:mspace></mml:mrow><mml:mi>…</mml:mi><mml:mrow><mml:mspace width="0.333em"></mml:mspace><mml:mtext mathvariant="normal"> </mml:mtext><mml:mspace width="0.333em"></mml:mspace></mml:mrow><mml:mn>2</mml:mn><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left" style="text-align: left"><mml:mi>⋮</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left" style="text-align: left"><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mn>2</mml:mn><mml:mrow><mml:mspace width="0.333em"></mml:mspace><mml:mtext mathvariant="normal"> </mml:mtext><mml:mspace width="0.333em"></mml:mspace></mml:mrow><mml:mn>2</mml:mn><mml:mrow><mml:mspace width="0.333em"></mml:mspace><mml:mtext mathvariant="normal"> </mml:mtext><mml:mspace width="0.333em"></mml:mspace></mml:mrow><mml:mi>…</mml:mi><mml:mrow><mml:mspace width="0.333em"></mml:mspace><mml:mtext mathvariant="normal"> </mml:mtext><mml:mspace width="0.333em"></mml:mspace></mml:mrow><mml:mn>1</mml:mn><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left" style="text-align: left"><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mn>2</mml:mn><mml:mrow><mml:mspace width="0.333em"></mml:mspace><mml:mtext mathvariant="normal"> </mml:mtext><mml:mspace width="0.333em"></mml:mspace></mml:mrow><mml:mn>2</mml:mn><mml:mrow><mml:mspace width="0.333em"></mml:mspace><mml:mtext mathvariant="normal"> </mml:mtext><mml:mspace width="0.333em"></mml:mspace></mml:mrow><mml:mi>…</mml:mi><mml:mrow><mml:mspace width="0.333em"></mml:mspace><mml:mtext mathvariant="normal"> </mml:mtext><mml:mspace width="0.333em"></mml:mspace></mml:mrow><mml:mn>2</mml:mn><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:math></alternatives></disp-formula></p>
      <p>where each array in the resulting product is considered as a
      possible shift schedule matrix. Imposing constraints (resting time
      between shifts and ensuring all shifts are filled) on each
      combinations results in solutions from which the user can choose
      between.</p>
      <p>Since all combinations are stored in a matrix form before
      different combinations are removed from the final solutions
      matrix, large datasets require severe amount of internal memory
      for the Cartesian Product method to work. For this, a controlling
      script has been implemented which calculates a pre-estimate of
      required internal memory. Approximating that each character in the
      shiftarray takes up 8 byte of memory yields</p>
      <p><disp-formula><alternatives>
      <tex-math><![CDATA[IM \approx N_{size} = N^{n_{S}} \times n_S,]]></tex-math>
      <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>I</mml:mi><mml:mi>M</mml:mi><mml:mo>≈</mml:mo><mml:msub><mml:mi>N</mml:mi><mml:mrow><mml:mi>s</mml:mi><mml:mi>i</mml:mi><mml:mi>z</mml:mi><mml:mi>e</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msup><mml:mi>N</mml:mi><mml:msub><mml:mi>n</mml:mi><mml:mi>S</mml:mi></mml:msub></mml:msup><mml:mo>×</mml:mo><mml:msub><mml:mi>n</mml:mi><mml:mi>S</mml:mi></mml:msub><mml:mo>,</mml:mo></mml:mrow></mml:math></alternatives></disp-formula></p>
      <p>where <inline-formula><alternatives>
      <tex-math><![CDATA[N_{size}]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>N</mml:mi><mml:mrow><mml:mi>s</mml:mi><mml:mi>i</mml:mi><mml:mi>z</mml:mi><mml:mi>e</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>
      is the total number of zeroes and ones in the full matrix. If the
      estimated size of the resulting matrix from the operation exceeds
      1Gb, the user is prompted whether to continue with the default
      Cartesian Product method or to use a less internal memory
      demanding recursive method.</p>
    </sec>
  </sec>
  <sec id="comparison-to-similar-softwares">
    <title>Comparison to similar softwares</title>
    <p>Different commercial softwares are available for shift scheduling
    using computational methods. In 2004, Burke
    (<xref alt="2004" rid="ref-BurkeU003A2004" ref-type="bibr">2004</xref>)
    made a comprehensive literature review of a wide range of
    approaches, including optimising approaches (mathematical
    programming), multi-criteria approaches (goal programming),
    artificial intelligence methods, heuristic approaches, and
    metaheuristic approaches. Common for these approaches is that they
    use the constraints by the user and are able to provide more-or-less
    ready schedule(s), with the limitations for the mathematical
    approaches not being appropriate and requiring post-generation work.
    Goal programming defines a target for each criterion and their
    relative priorities Burke
    (<xref alt="2004" rid="ref-BurkeU003A2004" ref-type="bibr">2004</xref>)
    by applying mathematical programming or by tackling metaheuristics
    within a multi-objective framework. The complexities from goal
    programming arise from that real world problems are difficult to
    solve without some optimisation from a planner.</p>
    <p>Many approaches utilising artificial intelligence imitate human
    reasoning and may hence produce reasonable schedules, such as
    Petrovic &amp; Berghe
    (<xref alt="2002" rid="ref-PATATU003A2002" ref-type="bibr">2002</xref>)
    which takes into account parameters such as the appropriate skill
    mix and staff-to-patient ratios.</p>
    <p>Laporte &amp; Pesant
    (<xref alt="2004" rid="ref-LaporteU003A2004" ref-type="bibr">2004</xref>)
    developed a constraint programming algorithm for the construction of
    rotating shift schedules with the algorithm building the schedules
    per column (per day), looking for allowed shift stretches (including
    days off). The pros of their method over this project is that the
    required computing power is lower than in this project as the shift
    patterns. However, the method populates the shift schedules with the
    shift species and does not allow the user to perform the middle step
    from this project, which is selecting the shift- and
    rest-day-patterns (referred to as a combination). Therefore, the
    cons of their algorithm in comparison to this would be that the
    number of solutions could be very high and require a large amount of
    computer storage. Moreover, their method had difficulties to obtain
    evenly spaced full weekends off, which the shift pattern scroll tool
    in this project can be utilised for finding (see bottom of
    <xref alt="[fig:phase1]" rid="figU003Aphase1">[fig:phase1]</xref>).</p>
  </sec>
  <sec id="conclusions">
    <title>Conclusions</title>
    <p>In this project, an algorithm has been constructed which generate
    schedules for different number of weeks to cycle over. The current
    issue is that the computational complexity (and hence the required
    computation time) increases with the number of weeks per cycle (see
    Table 2 and in Figure 1 in
    <ext-link ext-link-type="uri" xlink:href="https://github.com/benjaminbolling/RSW/blob/master/docs/benchmarking.md">benchmarking</ext-link>).
    This means that for a higher amount of weeks in a shift cycle, this
    application will need further development in order to have more
    efficient ways of finding the solutions and/or deployment of the
    application onto super-computers for generating the Boolean
    Arrays.</p>
    <p>For up to 5 weeks in a shift cycle it is possible to use a
    general-purpose computer such as the benchmarking Apple MacBook Pro
    with specifications defined in Table 1 in
    <ext-link ext-link-type="uri" xlink:href="https://github.com/benjaminbolling/RSW/blob/master/docs/benchmarking.md">benchmarking</ext-link>.
    It has thus been demonstrated that the application can be used to
    generate 1, 2 and 3-shift schedules. The software in this project
    has also been compared to a few existing methods via a short
    literature study, showing that it offers both benefits and
    disadvantages.</p>
    <p>Future development plans include adding functionalities in phase
    1 such as filtering on number of free weekends and taking into
    account competences of the shift workers (to ensure full coverage of
    potential shift competence requirements). An important future
    development needed is restructuring part of the algorithm to lower
    the required processing power and hence time needed. Another future
    development plan includes importing an existing schedule with labels
    as a CSV-file directly into phase 2 such that modifications and/or
    checks can be done to assure the schedule is compliant with local
    rules for the workers. These improvements would further strengthen
    the usability of this application.</p>
  </sec>
  <sec id="figures">
    <title>Figures</title>
    <fig>
      <caption><p>The RWSing Application’s
      launcher.<styled-content id="figU003Alauncher"></styled-content></p></caption>
      <graphic mimetype="image" mime-subtype="png" xlink:href="media/docs/fig0.png" />
    </fig>
    <fig>
      <caption><p>The RWSing Application’s algorithm’s “phase 1 GUI”, in
      which the combinations have been
      generated.<styled-content id="figU003Aphase1"></styled-content></p></caption>
      <graphic mimetype="image" mime-subtype="png" xlink:href="media/docs/fig1.png" />
    </fig>
    <fig>
      <caption><p>The RWSing Application’s algorithm’s “phase 2 GUI” as
      launched from the “phase 1 GUI” and with the second Thursday’s
      shift changed to an evening shift (left) and after finding
      solutions, showing the first solution
      (right).<styled-content id="figU003Aphase2"></styled-content></p></caption>
      <graphic mimetype="image" mime-subtype="png" xlink:href="media/docs/fig2.png" />
    </fig>
    <fig>
      <caption><p>The RWSing Application’s high-level software
      architecture
      flow.<styled-content id="figU003Aflow"></styled-content></p></caption>
      <graphic mimetype="image" mime-subtype="png" xlink:href="media/docs/soft_arch_flow.png" />
    </fig>
    <fig>
      <caption><p>The RWSing Application’s high-level user
      flowchart.<styled-content id="figU003Auserflow"></styled-content></p></caption>
      <graphic mimetype="image" mime-subtype="png" xlink:href="media/docs/user_flowchart.png" />
    </fig>
  </sec>
  <sec id="acknowledgements">
    <title>Acknowledgements</title>
    <p>The author wants to thank his direct line-manager at European
    Spallation Source for asking the question if it would be possible to
    create a software for generating shift schedules, which lead to the
    idea of creating this project and after a while lead to this final
    state. The author also wants to thank the reviewers for taking their
    time reviewing this project.</p>
  </sec>
</sec>
</body>
<back>
<ref-list>
  <ref id="ref-PythonReference">
    <element-citation>
      <person-group person-group-type="author">
        <string-name>Python Software Foundation</string-name>
      </person-group>
      <article-title>Python Language Reference</article-title>
      <year iso-8601-date="2020">2020</year>
      <uri>http://www.python.org</uri>
      <pub-id pub-id-type="doi">10.1201/9781584889304-33</pub-id>
    </element-citation>
  </ref>
  <ref id="ref-PyQtReference">
    <element-citation>
      <person-group person-group-type="author">
        <string-name>Riverbank Computing Limited</string-name>
      </person-group>
      <article-title>PyQt5: Python bindings for the Qt cross platform UI and application toolkit</article-title>
      <year iso-8601-date="2016">2016</year>
      <uri>https://www.riverbankcomputing.com/software/pyqt/</uri>
    </element-citation>
  </ref>
  <ref id="ref-TristanU003A2020">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Becker</surname><given-names>Tristan</given-names></name>
      </person-group>
      <article-title>A decomposition heuristic for rotational workforce scheduling</article-title>
      <source>Journal of Scheduling</source>
      <year iso-8601-date="2020">2020</year>
      <volume>23</volume>
      <pub-id pub-id-type="doi">10.1007/s10951-020-00659-2</pub-id>
      <fpage>539</fpage>
      <lpage>554</lpage>
    </element-citation>
  </ref>
  <ref id="ref-LaporteU003A2004">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Laporte</surname><given-names>Gilbert</given-names></name>
        <name><surname>Pesant</surname><given-names>Gilles</given-names></name>
      </person-group>
      <article-title>A general multi-shift scheduling system</article-title>
      <source>The Journal of the Operational Research Society</source>
      <year iso-8601-date="2004">2004</year>
      <volume>55</volume>
      <pub-id pub-id-type="doi">10.1057/palgrave.jors.2601789</pub-id>
      <fpage>1208</fpage>
      <lpage>1217</lpage>
    </element-citation>
  </ref>
  <ref id="ref-BurkeU003A2004">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Burke</surname><given-names>De Causmaecker</given-names><suffix>E.</suffix></name>
      </person-group>
      <article-title>The state of the art of nurse rostering</article-title>
      <source>Journal of Scheduling</source>
      <year iso-8601-date="2004">2004</year>
      <volume>7(6)</volume>
      <pub-id pub-id-type="doi">10.1023/B:JOSH.0000046076.75950.0b</pub-id>
      <fpage>441</fpage>
      <lpage>499</lpage>
    </element-citation>
  </ref>
  <ref id="ref-PATATU003A2002">
    <element-citation publication-type="paper-conference">
      <person-group person-group-type="author">
        <name><surname>Petrovic</surname><given-names>G. Beddoe</given-names><suffix>S.</suffix></name>
        <name><surname>Berghe</surname><given-names>G. Vanden</given-names></name>
      </person-group>
      <article-title>Storing and adapting repair experiences in personnel rostering</article-title>
      <source>Practice and theory of automated timetabling, fourth international conference</source>
      <year iso-8601-date="2002">2002</year>
      <fpage>185</fpage>
      <lpage>186</lpage>
    </element-citation>
  </ref>
</ref-list>
</back>
</article>
