<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN"
                  "JATS-publishing1.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" dtd-version="1.2" article-type="other">
<front>
<journal-meta>
<journal-id></journal-id>
<journal-title-group>
<journal-title>Journal of Open Source Software</journal-title>
<abbrev-journal-title>JOSS</abbrev-journal-title>
</journal-title-group>
<issn publication-format="electronic">2475-9066</issn>
<publisher>
<publisher-name>Open Journals</publisher-name>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="publisher-id">8396</article-id>
<article-id pub-id-type="doi">10.21105/joss.08396</article-id>
<title-group>
<article-title>MatrixFuns.jl: Matrix functions in Julia</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author">
<contrib-id contrib-id-type="orcid">https://orcid.org/0000-0003-3349-9517</contrib-id>
<name>
<surname>Quan</surname>
<given-names>Xue</given-names>
</name>
<xref ref-type="aff" rid="aff-1"/>
<xref ref-type="aff" rid="aff-2"/>
</contrib>
<contrib contrib-type="author">
<contrib-id contrib-id-type="orcid">https://orcid.org/0000-0002-3999-0289</contrib-id>
<name>
<surname>Levitt</surname>
<given-names>Antoine</given-names>
</name>
<xref ref-type="aff" rid="aff-1"/>
</contrib>
<aff id="aff-1">
<institution-wrap>
<institution>Laboratoire de Mathématiques d’Orsay, Université
Paris-Saclay, France</institution>
</institution-wrap>
</aff>
<aff id="aff-2">
<institution-wrap>
<institution>School of Mathematical Sciences, Beijing Normal University,
China</institution>
</institution-wrap>
</aff>
</contrib-group>
<pub-date date-type="pub" publication-format="electronic" iso-8601-date="2025-06-05">
<day>5</day>
<month>6</month>
<year>2025</year>
</pub-date>
<volume>10</volume>
<issue>112</issue>
<fpage>8396</fpage>
<permissions>
<copyright-statement>Authors of papers retain copyright and release the
work under a Creative Commons Attribution 4.0 International License (CC
BY 4.0)</copyright-statement>
<copyright-year>2025</copyright-year>
<copyright-holder>The article authors</copyright-holder>
<license license-type="open-access" xlink:href="https://creativecommons.org/licenses/by/4.0/">
<license-p>Authors of papers retain copyright and release the work under
a Creative Commons Attribution 4.0 International License (CC BY
4.0)</license-p>
</license>
</permissions>
<kwd-group kwd-group-type="author">
<kwd>Matrix functions</kwd>
<kwd>Fréchet derivatives</kwd>
<kwd>Divided differences</kwd>
<kwd>Julia</kwd>
</kwd-group>
</article-meta>
</front>
<body>
<sec id="summary">
  <title>Summary</title>
  <p>The computation of matrix functions (i.e.,
  <inline-formula><alternatives>
  <tex-math><![CDATA[f(A)]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>f</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
  for <inline-formula><alternatives>
  <tex-math><![CDATA[A]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>A</mml:mi></mml:math></alternatives></inline-formula>
  a <inline-formula><alternatives>
  <tex-math><![CDATA[n \times n]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>n</mml:mi><mml:mo>×</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
  matrix and <inline-formula><alternatives>
  <tex-math><![CDATA[f : \mathbb{C} \to \mathbb{C}]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>f</mml:mi><mml:mo>:</mml:mo><mml:mi>ℂ</mml:mi><mml:mo>→</mml:mo><mml:mi>ℂ</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>)
  and their Fréchet derivatives plays a crucial role in many fields of
  science
  (<xref alt="Higham, 2008" rid="ref-Higham2008" ref-type="bibr">Higham,
  2008</xref>), and in particular in electronic structure calculations
  within density functional theory and response calculations. For
  Hermitian <inline-formula><alternatives>
  <tex-math><![CDATA[A]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>A</mml:mi></mml:math></alternatives></inline-formula>,
  computing <inline-formula><alternatives>
  <tex-math><![CDATA[f(A)]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>f</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
  can be done efficiently and stably by diagonalization. In the
  non-normal case, however, diagonalization is unstable and alternative
  schemes have to be used. Even in the Hermitian case, the evaluation of
  Fréchet derivatives requires (high-order) divided differences, which
  by Opitz’s formula
  (<xref alt="de Boor, 2005" rid="ref-deBoor2005" ref-type="bibr">de
  Boor, 2005</xref>) is equivalent to the exact computation of
  <inline-formula><alternatives>
  <tex-math><![CDATA[f(A)]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>f</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
  for non-normal <inline-formula><alternatives>
  <tex-math><![CDATA[A]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>A</mml:mi></mml:math></alternatives></inline-formula>.</p>
  <p>In this work, we develop <monospace>MatrixFuns.jl</monospace> a
  Julia package
  (<xref alt="Bezanson et al., 2017" rid="ref-julia" ref-type="bibr">Bezanson
  et al., 2017</xref>) to provide the robust computation of matrix
  functions for arbitrary square matrices and higher-order Fréchet
  derivatives for Hermitian matrices. This package is tailored towards
  high accuracy with relatively small matrices and relatively
  complicated functions <inline-formula><alternatives>
  <tex-math><![CDATA[f]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>f</mml:mi></mml:math></alternatives></inline-formula>.
  Our work is based on the Schur-Parlett algorithm
  (<xref alt="Davies &amp; Higham, 2003" rid="ref-DaviesHigham03" ref-type="bibr">Davies
  &amp; Higham, 2003</xref>;
  <xref alt="Higham &amp; Al-Mohy, 2010" rid="ref-HighamMohy10" ref-type="bibr">Higham
  &amp; Al-Mohy, 2010</xref>), with the following modifications:</p>
  <list list-type="bullet">
    <list-item>
      <p>It supports functions that are discontinuous, or have sharp
      variations.</p>
    </list-item>
    <list-item>
      <p>It does not require the computation of arbitrary-order
      derivatives of <inline-formula><alternatives>
      <tex-math><![CDATA[f]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>f</mml:mi></mml:math></alternatives></inline-formula>.</p>
    </list-item>
    <list-item>
      <p>It exploits existing special-purpose methods for computing
      matrix functions (e.g., for functions involving exponentials or
      logarithms) when they exist.</p>
    </list-item>
  </list>
</sec>
<sec id="statement-of-need">
  <title>Statement of need</title>
  <p><monospace>MatrixFuns.jl</monospace> aims to provide high-accuracy
  computations for general matrix functions and arbitrary-order Fréchet
  derivatives (including divided differences) in Julia. Julia provides
  some native matrix functions, but the choice is limited to a few
  functions for which special-purpose algorithms exist (e.g.,
  exponentials, logarithms, matrix powers). There are no dedicated
  functions in Julia for computing Fréchet derivatives and divided
  differences; some Julia packages offer tools for their computation
  (e.g., <monospace>ChainRules.jl</monospace>
  (<xref alt="White, 2019" rid="ref-ChainRules.jl" ref-type="bibr">White,
  2019</xref>), <monospace>DFTK.jl</monospace>
  (<xref alt="Herbst et al., 2021" rid="ref-DFTKjcon" ref-type="bibr">Herbst
  et al., 2021</xref>)), but are typically limited to first order.</p>
</sec>
<sec id="methods">
  <title>Methods</title>
  <sec id="matrix-functions">
    <title>Matrix functions</title>
    <p>The basic principle of the Schur-Parlett algorithm is as follows.
    First, one performs a Schur decomposition to reduce to the case of
    an upper triangular matrix. Then, one uses the Parlett recursion,
    which for a block matrix <inline-formula><alternatives>
    <tex-math><![CDATA[A = \begin{pmatrix}A_{11}&A_{12}\\0&A_{22}\end{pmatrix}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>A</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mtable><mml:mtr><mml:mtd columnalign="center" style="text-align: center"><mml:msub><mml:mi>A</mml:mi><mml:mn>11</mml:mn></mml:msub></mml:mtd><mml:mtd columnalign="center" style="text-align: center"><mml:msub><mml:mi>A</mml:mi><mml:mn>12</mml:mn></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="center" style="text-align: center"><mml:mn>0</mml:mn></mml:mtd><mml:mtd columnalign="center" style="text-align: center"><mml:msub><mml:mi>A</mml:mi><mml:mn>22</mml:mn></mml:msub></mml:mtd></mml:mtr></mml:mtable><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
    expresses <inline-formula><alternatives>
    <tex-math><![CDATA[B = f(A)]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>B</mml:mi><mml:mo>=</mml:mo><mml:mi>f</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
    as <inline-formula><alternatives>
    <tex-math><![CDATA[B_{11}=f(A_{11})]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>B</mml:mi><mml:mn>11</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mi>f</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>A</mml:mi><mml:mn>11</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>,
    <inline-formula><alternatives>
    <tex-math><![CDATA[B_{22}=f(A_{22})]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>B</mml:mi><mml:mn>22</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mi>f</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>A</mml:mi><mml:mn>22</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
    and <inline-formula><alternatives>
    <tex-math><![CDATA[B_{12}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>B</mml:mi><mml:mn>12</mml:mn></mml:msub></mml:math></alternatives></inline-formula>
    given by the solution of the Sylvester equation
    <inline-formula><alternatives>
    <tex-math><![CDATA[A_{11} B_{12} - B_{12} A_{22} = B_{11}A_{12}-A_{12}B_{22}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>A</mml:mi><mml:mn>11</mml:mn></mml:msub><mml:msub><mml:mi>B</mml:mi><mml:mn>12</mml:mn></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>B</mml:mi><mml:mn>12</mml:mn></mml:msub><mml:msub><mml:mi>A</mml:mi><mml:mn>22</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>B</mml:mi><mml:mn>11</mml:mn></mml:msub><mml:msub><mml:mi>A</mml:mi><mml:mn>12</mml:mn></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>A</mml:mi><mml:mn>12</mml:mn></mml:msub><mml:msub><mml:mi>B</mml:mi><mml:mn>22</mml:mn></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>.
    In principle, this can be used to compute
    <inline-formula><alternatives>
    <tex-math><![CDATA[f(A)]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>f</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
    by a recursion, but the Sylvester equation becomes ill-conditioned
    when <inline-formula><alternatives>
    <tex-math><![CDATA[A_{11}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>A</mml:mi><mml:mn>11</mml:mn></mml:msub></mml:math></alternatives></inline-formula>
    and <inline-formula><alternatives>
    <tex-math><![CDATA[A_{22}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>A</mml:mi><mml:mn>22</mml:mn></mml:msub></mml:math></alternatives></inline-formula>
    do not have well-separated eigenvalues. In this case, one can use
    Taylor series, as proposed in Davies &amp; Higham
    (<xref alt="2003" rid="ref-DaviesHigham03" ref-type="bibr">2003</xref>)
    and Higham &amp; Al-Mohy
    (<xref alt="2010" rid="ref-HighamMohy10" ref-type="bibr">2010</xref>),
    but this has the disadvantage of requiring arbitrarily many
    derivatives of <inline-formula><alternatives>
    <tex-math><![CDATA[f]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>f</mml:mi></mml:math></alternatives></inline-formula>,
    which might be impractical in some applications (e.g., when the
    function is not analytic, or has sharp variations).</p>
    <p>Our algorithm attempts to find a partition of the eigenvalues of
    <inline-formula><alternatives>
    <tex-math><![CDATA[A]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>A</mml:mi></mml:math></alternatives></inline-formula>
    (computed using a Schur decomposition) into blocks that are
    well-separated. The diagonal blocks are then computed using Taylor
    series, and the Parlett recursion is used to fill out the
    off-diagonal blocks. The partitioning aims to find small blocks (so
    that low-order Taylor series can be used) that are well-separated
    (so that the Parlett recursion is well-conditioned).</p>
    <p>To find the partition, we start by partitioning the set of
    eigenvalues <inline-formula><alternatives>
    <tex-math><![CDATA[\Lambda]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>Λ</mml:mi></mml:math></alternatives></inline-formula>
    into disjoint clusters <inline-formula><alternatives>
    <tex-math><![CDATA[\Lambda_i]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>Λ</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
    such that the distance between two such clusters is at least
    <inline-formula><tex-math><![CDATA[{\rm sep}]]></tex-math></inline-formula>,
    where
    <inline-formula><tex-math><![CDATA[{\rm sep}]]></tex-math></inline-formula>
    is a user-definable parameter. We then check if the partition is
    acceptable by estimating the error in all the clusters; if the
    estimated error is acceptable, we accept the partition; if not, we
    split the unacceptable clusters further by applying the partitioning
    algorithm recursively to each unacceptable
    <inline-formula><alternatives>
    <tex-math><![CDATA[\Lambda_i]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>Λ</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></alternatives></inline-formula>.
    We estimate the error in a cluster <inline-formula><alternatives>
    <tex-math><![CDATA[\Lambda_i]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>Λ</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
    of diameter <inline-formula><alternatives>
    <tex-math><![CDATA[d_i]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>d</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
    as <inline-formula><alternatives>
    <tex-math><![CDATA[{\textrm{err}}_i=(\frac{d_i}{\textrm{scale}})^{\textrm{max}\_\textrm{deg}+1}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mtext mathvariant="normal">err</mml:mtext><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mfrac><mml:msub><mml:mi>d</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mtext mathvariant="normal">scale</mml:mtext></mml:mfrac><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mrow><mml:mtext mathvariant="normal">max</mml:mtext><mml:mi>_</mml:mi><mml:mtext mathvariant="normal">deg</mml:mtext><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></alternatives></inline-formula>.
    We accept a cluster if <inline-formula><alternatives>
    <tex-math><![CDATA[\textrm{err}_i < \varepsilon/\textrm{sep}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mtext mathvariant="normal">err</mml:mtext><mml:mi>i</mml:mi></mml:msub><mml:mo>&lt;</mml:mo><mml:mi>ε</mml:mi><mml:mi>/</mml:mi><mml:mtext mathvariant="normal">sep</mml:mtext></mml:mrow></mml:math></alternatives></inline-formula>.
    This choice is made to balance the error originating from the Taylor
    expansion within a cluster <inline-formula><alternatives>
    <tex-math><![CDATA[\textrm{err}_i]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mtext mathvariant="normal">err</mml:mtext><mml:mi>i</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
    with the error incurred by the use of the Parlett recursion
    <inline-formula><alternatives>
    <tex-math><![CDATA[\varepsilon/\textrm{sep}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>ε</mml:mi><mml:mi>/</mml:mi><mml:mtext mathvariant="normal">sep</mml:mtext></mml:mrow></mml:math></alternatives></inline-formula>.</p>
    <p>Therefore, our algorithm has the following parameters:</p>
    <list list-type="bullet">
      <list-item>
        <p><inline-formula><tex-math><![CDATA[{\rm scale}]]></tex-math></inline-formula>,
        the characteristic scale of variations of
        <inline-formula><alternatives>
        <tex-math><![CDATA[f]]></tex-math>
        <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>f</mml:mi></mml:math></alternatives></inline-formula>,
        set to <inline-formula><alternatives>
        <tex-math><![CDATA[1]]></tex-math>
        <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mn>1</mml:mn></mml:math></alternatives></inline-formula>
        by default.</p>
      </list-item>
      <list-item>
        <p><inline-formula><tex-math><![CDATA[{\rm max}\_{\rm deg}]]></tex-math></inline-formula>,
        the order of the Taylor series used, which should be set by the
        user according to the regularity of the function under
        consideration and the feasibility of computing high-order
        derivatives (computed automatically using
        <monospace>TaylorSeries.jl</monospace>
        (<xref alt="Benet &amp; Sanders, 2019" rid="ref-TaylorSeries.jl" ref-type="bibr">Benet
        &amp; Sanders, 2019</xref>) and <monospace>Arblib.jl</monospace>
        (<xref alt="Dahne, 2025" rid="ref-Arblib.jl" ref-type="bibr">Dahne,
        2025</xref>), where the latter is faster in calculating much
        larger orders and supports some special functions from
        <monospace>SpecialFunctions.jl</monospace>
        (<xref alt="Johnson, 2025" rid="ref-SpecialFunctions.jl" ref-type="bibr">Johnson,
        2025</xref>)). By default, set to a large value.</p>
      </list-item>
      <list-item>
        <p><inline-formula><tex-math><![CDATA[{\rm sep}]]></tex-math></inline-formula>,
        the initial separation distance, set to
        <inline-formula><tex-math><![CDATA[{\rm 0.1*scale}]]></tex-math></inline-formula>
        by default following
        (<xref alt="Davies &amp; Higham, 2003" rid="ref-DaviesHigham03" ref-type="bibr">Davies
        &amp; Higham, 2003</xref>;
        <xref alt="Higham &amp; Al-Mohy, 2010" rid="ref-HighamMohy10" ref-type="bibr">Higham
        &amp; Al-Mohy, 2010</xref>).</p>
      </list-item>
      <list-item>
        <p><inline-formula><alternatives>
        <tex-math><![CDATA[\varepsilon]]></tex-math>
        <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>ε</mml:mi></mml:math></alternatives></inline-formula>,
        the target accuracy, set to machine accuracy by default.</p>
      </list-item>
    </list>
    <p>In the case where Julia natively supports the computation of
    <inline-formula><alternatives>
    <tex-math><![CDATA[f(A)]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>f</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
    (as determined by trying to compute
    <monospace>f(ones(1,1))</monospace> and catching any resulting
    error), we use them instead of Taylor series to compute diagonal
    blocks. In the error estimate, we consider
    <inline-formula><tex-math><![CDATA[{\rm max\_deg}=\infty]]></tex-math></inline-formula>,
    and therefore use a partition with maximal diameter
    <inline-formula><tex-math><![CDATA[{\rm scale}]]></tex-math></inline-formula>.
    We partition the eigenvalues rather than simply call the native
    <inline-formula><alternatives>
    <tex-math><![CDATA[f(A)]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>f</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>,
    because <inline-formula><alternatives>
    <tex-math><![CDATA[f]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>f</mml:mi></mml:math></alternatives></inline-formula>
    can still have sharp variations, which would cause inaccuracies in
    <inline-formula><alternatives>
    <tex-math><![CDATA[f(A)]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>f</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>.
    For example:</p>
    <code language="julia">f(x) = I/(I+exp(50*x));

A = [-0.1 10.0 0.0; 0.0 1 5.0; 0.0 0.0 -0.11];

f(A) # native call
3×3 Matrix{Float64}:
 0.993307  -9.03006      -3.33299e7
 0.0        1.92875e-22  -4.48617
 0.0        0.0           0.99593

mat_fun(f, A; scale=1/50) # Schur-Parlett
3×3 Matrix{Float64}:
 0.993307  -9.03006      -28.8619
 0.0        1.92875e-22   -4.48617
 0.0        0.0            0.99593</code>
    <p>For discontinuous functions, or functions with sharp variations,
    our algorithm takes as input a color mapping
    <inline-formula><alternatives>
    <tex-math><![CDATA[{\textrm{color}}:\mathbb{C}\to\mathbb{Z}, \lambda\mapsto a]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mtext mathvariant="normal">color</mml:mtext><mml:mo>:</mml:mo><mml:mi>ℂ</mml:mi><mml:mo>→</mml:mo><mml:mi>ℤ</mml:mi><mml:mo>,</mml:mo><mml:mi>λ</mml:mi><mml:mo>↦</mml:mo><mml:mi>a</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>,
    and makes sure that all the eigenvalues inside a cluster have the
    same color. This ensures that Taylor expansions are not used across
    the discontinuity boundaries.</p>
  </sec>
  <sec id="fréchet-derivatives">
    <title>Fréchet derivatives</title>
    <p>For a Hermitian <inline-formula><alternatives>
    <tex-math><![CDATA[A\in\mathbb{C}^{n\times n}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>A</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mi>ℂ</mml:mi><mml:mrow><mml:mi>n</mml:mi><mml:mo>×</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></alternatives></inline-formula>,
    denote the eigenpairs by <inline-formula><alternatives>
    <tex-math><![CDATA[\{(\lambda_i,v_i)\}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo stretchy="false" form="prefix">{</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>λ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="false" form="postfix">}</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>.
    The <inline-formula><alternatives>
    <tex-math><![CDATA[N]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>N</mml:mi></mml:math></alternatives></inline-formula>-th
    order Fréchet derivative expresses the variation of
    <inline-formula><alternatives>
    <tex-math><![CDATA[f(A)]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>f</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
    with respect to a set of variations <inline-formula><alternatives>
    <tex-math><![CDATA[H_1, \dots, H_N]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>H</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mi>…</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>H</mml:mi><mml:mi>N</mml:mi></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>,
    and is given by (see the documentation of
    <monospace>MatrixFuns.jl</monospace> for details)
    <disp-formula><tex-math><![CDATA[
    {{\rm d}}^{N}f(A)H_1\cdots H_N =\sum_{i_0,\cdots,i_{N}=1}^nv_{i_0}\Bigg(\sum_{p\in\mathcal{P}_N}(H_{p(1)})_{i_0,i_1}\cdots (H_{p(N)})_{i_{N-1},i_{N}}\Bigg){f[\lambda_{i_0},\cdots,\lambda_{i_{N}}]}v_{i_{N}}^*,
    ]]></tex-math></disp-formula> where <inline-formula><alternatives>
    <tex-math><![CDATA[(H_{p(k)})_{i,j}=v_i^*H_{p(k)}v_j]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>H</mml:mi><mml:mrow><mml:mi>p</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msubsup><mml:mi>v</mml:mi><mml:mi>i</mml:mi><mml:mo>*</mml:mo></mml:msubsup><mml:msub><mml:mi>H</mml:mi><mml:mrow><mml:mi>p</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:msub><mml:msub><mml:mi>v</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>
    and <inline-formula><alternatives>
    <tex-math><![CDATA[p\in\mathcal{P}_N]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>p</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi>𝒫</mml:mi><mml:mi>N</mml:mi></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>
    is an arbitrary permutation of <inline-formula><alternatives>
    <tex-math><![CDATA[\{1,\cdots,N\}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo stretchy="false" form="prefix">{</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>⋯</mml:mi><mml:mo>,</mml:mo><mml:mi>N</mml:mi><mml:mo stretchy="false" form="postfix">}</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>.
    The higher-order divided differences <inline-formula><alternatives>
    <tex-math><![CDATA[f[x_0, \dots, x_N]]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>f</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mi>…</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>N</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
    defined recursively by <disp-formula><tex-math><![CDATA[
    f[x_0, \dots, x_N]
            = \begin{cases} 
                (f[x_0,\dots,x_{N-1}]-f[x_1,\dots,x_{N}])/(x_0-x_N), &{\rm if}\,\,x_0\neq x_N,\\ 
                \frac{\partial}{\partial z}f[z,x_1, \dots,x_{N-1}]{\big|}_{z=x_0}, & {\rm if}\,\,x_0= x_N.
            \end{cases}
    ]]></tex-math></disp-formula> The naive evaluation of this
    recurrence formula is prone to numerical stabilities. Instead, we
    compute the divided differences using Opitz’s formula
    <disp-formula><alternatives>
    <tex-math><![CDATA[
    f\left(\begin{bmatrix}
                x_0&1&&\\
                &x_1&\ddots&\\
                & &\ddots&1\\
                &&&x_N
            \end{bmatrix}\right) = 
            \begin{bmatrix}
                f[x_0] & f[x_0,x_1]& \cdots& f[x_0,\dots,x_N]\\
                &f[x_1]&\ddots&\vdots\\
                &&\ddots &f[x_{N-1},x_N]\\
                &&&f[x_N]
            \end{bmatrix}.
    ]]></tex-math>
    <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>f</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mtable><mml:mtr><mml:mtd columnalign="center" style="text-align: center"><mml:msub><mml:mi>x</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mtd><mml:mtd columnalign="center" style="text-align: center"><mml:mn>1</mml:mn></mml:mtd><mml:mtd columnalign="center" style="text-align: center"></mml:mtd><mml:mtd columnalign="center" style="text-align: center"></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="center" style="text-align: center"></mml:mtd><mml:mtd columnalign="center" style="text-align: center"><mml:msub><mml:mi>x</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mtd><mml:mtd columnalign="center" style="text-align: center"><mml:mo>⋱</mml:mo></mml:mtd><mml:mtd columnalign="center" style="text-align: center"></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="center" style="text-align: center"></mml:mtd><mml:mtd columnalign="center" style="text-align: center"></mml:mtd><mml:mtd columnalign="center" style="text-align: center"><mml:mo>⋱</mml:mo></mml:mtd><mml:mtd columnalign="center" style="text-align: center"><mml:mn>1</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="center" style="text-align: center"></mml:mtd><mml:mtd columnalign="center" style="text-align: center"></mml:mtd><mml:mtd columnalign="center" style="text-align: center"></mml:mtd><mml:mtd columnalign="center" style="text-align: center"><mml:msub><mml:mi>x</mml:mi><mml:mi>N</mml:mi></mml:msub></mml:mtd></mml:mtr></mml:mtable><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mtable><mml:mtr><mml:mtd columnalign="center" style="text-align: center"><mml:mi>f</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow></mml:mtd><mml:mtd columnalign="center" style="text-align: center"><mml:mi>f</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow></mml:mtd><mml:mtd columnalign="center" style="text-align: center"><mml:mi>⋯</mml:mi></mml:mtd><mml:mtd columnalign="center" style="text-align: center"><mml:mi>f</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mi>…</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>N</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="center" style="text-align: center"></mml:mtd><mml:mtd columnalign="center" style="text-align: center"><mml:mi>f</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow></mml:mtd><mml:mtd columnalign="center" style="text-align: center"><mml:mo>⋱</mml:mo></mml:mtd><mml:mtd columnalign="center" style="text-align: center"><mml:mi>⋮</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="center" style="text-align: center"></mml:mtd><mml:mtd columnalign="center" style="text-align: center"></mml:mtd><mml:mtd columnalign="center" style="text-align: center"><mml:mo>⋱</mml:mo></mml:mtd><mml:mtd columnalign="center" style="text-align: center"><mml:mi>f</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>N</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>N</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="center" style="text-align: center"></mml:mtd><mml:mtd columnalign="center" style="text-align: center"></mml:mtd><mml:mtd columnalign="center" style="text-align: center"></mml:mtd><mml:mtd columnalign="center" style="text-align: center"><mml:mi>f</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>N</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow><mml:mi>.</mml:mi></mml:mrow></mml:math></alternatives></disp-formula>
    Therefore, the key point in evaluating the Fréchet derivative
    reduces to computing matrix functions for upper triangular
    matrices.</p>
  </sec>
</sec>
<sec id="examples">
  <title>Examples</title>
  <p>We first show how to use MatrixFuns.jl to compute the matrix
  functions, divided differences, and Fréchet derivatives for smooth
  functions such as <monospace>exp</monospace>.</p>
  <code language="julia">using MatrixFuns

A = [-0.1 1.0 0.0; 0.0 -0.05 1.0; 0.0 0.0 0.01];

mat_fun(exp, A) # returns exp(A)
3×3 Matrix{Float64}:
 0.904837  0.92784   0.477323
 0.0       0.951229  0.980346
 0.0       0.0       1.01005

div_diff(exp, -0.1, -0.05, 0.01) # returns exp[-0.1,-0.05,0.01]
0.47732345844677654

H = 0.5 * (A + A'); # generates a Hermitian matrix

hs = map(i -&gt; i * H, [1, 2]);

mat_fun_frechet(exp, H, hs) # returns d^2exp(H)hs[1]hs[2]
3×3 Matrix{Float64}:
 0.519468  0.347941  0.55445
 0.347941  1.10871   0.46992
 0.55445   0.46992   0.610653</code>
  <p>In addition to the usual smooth functions, MatrixFuns.jl can also
  support special functions and discontinuous functions. Here, we use
  the error function <monospace>erf</monospace> and the sign function
  <monospace>sign</monospace> to show how it can be used to handle
  functions with different smoothness.</p>
  <code language="julia">using MatrixFuns, SpecialFunctions

A = [-0.1 1.0 0.0; 0.0 -0.05 1.0; 0.0 0.0 0.01];

mat_fun(erf, A) # smooth function
3×3 Matrix{Float64}:
 -0.112463   1.12182   0.0524648
  0.0       -0.056372  1.12759
  0.0        0.0       0.0112834

mat_fun(x -&gt; erf(500x), A; scale=1/500, color=x-&gt;x&lt;0 ? 1 : 2) # singular function
3×3 Matrix{Float64}:
 -1.0   0.0  303.03
  0.0  -1.0   33.3333
  0.0   0.0    1.0

mat_fun(sign, A; color=x-&gt;Int(sign(x))) # discontinuous function with smooth branches
3×3 Matrix{Float64}:
 -1.0   0.0  303.03
  0.0  -1.0   33.3333
  0.0   0.0    1.0</code>
</sec>
</body>
<back>
<ref-list>
  <title>Reference</title>
  <ref id="ref-julia">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Bezanson</surname><given-names>Jeff</given-names></name>
        <name><surname>Edelman</surname><given-names>Alan</given-names></name>
        <name><surname>Karpinski</surname><given-names>Stefan</given-names></name>
        <name><surname>Shah</surname><given-names>Viral B.</given-names></name>
      </person-group>
      <article-title>Julia: A fresh approach to numerical computing</article-title>
      <source>SIAM Review</source>
      <year iso-8601-date="2017">2017</year>
      <volume>59</volume>
      <issue>1</issue>
      <pub-id pub-id-type="doi">10.1137/141000671</pub-id>
      <fpage>65</fpage>
      <lpage>98</lpage>
    </element-citation>
  </ref>
  <ref id="ref-DaviesHigham03">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Davies</surname><given-names>Philip I.</given-names></name>
        <name><surname>Higham</surname><given-names>Nicholas J.</given-names></name>
      </person-group>
      <article-title>A Schur-Parlett algorithm for computing matrix functions</article-title>
      <source>SIAM Journal on Matrix Analysis and Applications</source>
      <year iso-8601-date="2003">2003</year>
      <date-in-citation content-type="access-date"><year iso-8601-date="0000">0000</year></date-in-citation>
      <volume>25</volume>
      <issue>2</issue>
      <pub-id pub-id-type="doi">10.1137/S0895479802410815</pub-id>
      <fpage>464</fpage>
      <lpage>485</lpage>
    </element-citation>
  </ref>
  <ref id="ref-HighamMohy10">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Higham</surname><given-names>Nicholas J.</given-names></name>
        <name><surname>Al-Mohy</surname><given-names>Awad H.</given-names></name>
      </person-group>
      <article-title>Computing matrix functions</article-title>
      <source>Acta Numerica</source>
      <year iso-8601-date="2010">2010</year>
      <volume>19</volume>
      <pub-id pub-id-type="doi">10.1017/S0962492910000036</pub-id>
      <fpage>159</fpage>
      <lpage>208</lpage>
    </element-citation>
  </ref>
  <ref id="ref-deBoor2005">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>de Boor</surname><given-names>Carl</given-names></name>
      </person-group>
      <article-title>Divided differences</article-title>
      <source>Surveys in Approximation Theory</source>
      <publisher-name>Technion</publisher-name>
      <year iso-8601-date="2005">2005</year>
      <volume>1</volume>
      <uri>http://eudml.org/doc/51657</uri>
      <fpage>46</fpage>
      <lpage>69</lpage>
    </element-citation>
  </ref>
  <ref id="ref-Higham2008">
    <element-citation publication-type="book">
      <person-group person-group-type="author">
        <name><surname>Higham</surname><given-names>Nicholas J.</given-names></name>
      </person-group>
      <source>Functions of Matrices: Theory and Computation</source>
      <publisher-name>SIAM</publisher-name>
      <publisher-loc>Philadelphia</publisher-loc>
      <year iso-8601-date="2008">2008</year>
      <pub-id pub-id-type="doi">10.1137/1.9780898717778</pub-id>
    </element-citation>
  </ref>
  <ref id="ref-DFTKjcon">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Herbst</surname><given-names>Michael F.</given-names></name>
        <name><surname>Levitt</surname><given-names>Antoine</given-names></name>
        <name><surname>Cancès</surname><given-names>Eric</given-names></name>
      </person-group>
      <article-title>DFTK: A Julian approach for simulating electrons in solids</article-title>
      <source>Proc. JuliaCon Conf.</source>
      <year iso-8601-date="2021">2021</year>
      <volume>3</volume>
      <pub-id pub-id-type="doi">10.21105/jcon.00069</pub-id>
      <fpage>69</fpage>
      <lpage></lpage>
    </element-citation>
  </ref>
  <ref id="ref-TaylorSeries.jl">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Benet</surname><given-names>Luis</given-names></name>
        <name><surname>Sanders</surname><given-names>David P.</given-names></name>
      </person-group>
      <article-title>TaylorSeries.jl: Taylor expansions in one and several variables in julia</article-title>
      <source>Journal of Open Source Software</source>
      <publisher-name>The Open Journal</publisher-name>
      <year iso-8601-date="2019">2019</year>
      <volume>4</volume>
      <issue>36</issue>
      <uri>https://doi.org/10.21105/joss.01043</uri>
      <pub-id pub-id-type="doi">10.21105/joss.01043</pub-id>
      <fpage>1043</fpage>
      <lpage></lpage>
    </element-citation>
  </ref>
  <ref id="ref-ChainRules.jl">
    <element-citation publication-type="software">
      <person-group person-group-type="author">
        <name><surname>White</surname><given-names>Frames</given-names></name>
      </person-group>
      <article-title>ChainRules.jl</article-title>
      <publisher-name>Zenodo</publisher-name>
      <year iso-8601-date="2019">2019</year>
      <uri>https://doi.org/10.5281/zenodo.14926720</uri>
      <pub-id pub-id-type="doi">10.5281/zenodo.14926720</pub-id>
    </element-citation>
  </ref>
  <ref id="ref-Arblib.jl">
    <element-citation publication-type="software">
      <person-group person-group-type="author">
        <name><surname>Dahne</surname><given-names>Joel</given-names></name>
      </person-group>
      <article-title>Arblib.jl</article-title>
      <publisher-name>Zenodo</publisher-name>
      <year iso-8601-date="2025">2025</year>
      <uri>https://doi.org/10.5281/zenodo.15058432</uri>
      <pub-id pub-id-type="doi">10.5281/zenodo.15058432</pub-id>
    </element-citation>
  </ref>
  <ref id="ref-SpecialFunctions.jl">
    <element-citation publication-type="software">
      <person-group person-group-type="author">
        <name><surname>Johnson</surname><given-names>Steven G.</given-names></name>
      </person-group>
      <article-title>SpecialFunctions.jl</article-title>
      <year iso-8601-date="2025">2025</year>
      <uri>https://github.com/JuliaMath/SpecialFunctions.jl</uri>
    </element-citation>
  </ref>
</ref-list>
</back>
</article>
