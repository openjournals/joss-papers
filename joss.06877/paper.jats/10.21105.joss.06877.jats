<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN"
                  "JATS-publishing1.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" dtd-version="1.2" article-type="other">
<front>
<journal-meta>
<journal-id></journal-id>
<journal-title-group>
<journal-title>Journal of Open Source Software</journal-title>
<abbrev-journal-title>JOSS</abbrev-journal-title>
</journal-title-group>
<issn publication-format="electronic">2475-9066</issn>
<publisher>
<publisher-name>Open Journals</publisher-name>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="publisher-id">6877</article-id>
<article-id pub-id-type="doi">10.21105/joss.06877</article-id>
<title-group>
<article-title>PyNeuroTrace - Python code for neural activity time
series</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author" equal-contrib="yes">
<contrib-id contrib-id-type="orcid">https://orcid.org/0009-0001-5216-7748</contrib-id>
<name>
<surname>Coleman</surname>
<given-names>Patrick</given-names>
</name>
<xref ref-type="aff" rid="aff-1"/>
</contrib>
<contrib contrib-type="author" equal-contrib="yes" corresp="yes">
<contrib-id contrib-id-type="orcid">https://orcid.org/0000-0003-2176-4977</contrib-id>
<name>
<surname>Hogg</surname>
<given-names>Peter William</given-names>
</name>
<xref ref-type="aff" rid="aff-1"/>
<xref ref-type="corresp" rid="cor-1"><sup>*</sup></xref>
</contrib>
<contrib contrib-type="author">
<contrib-id contrib-id-type="orcid">https://orcid.org/0009-0001-3239-6930</contrib-id>
<name>
<surname>Toth</surname>
<given-names>Tristan Dellazizzo</given-names>
</name>
<xref ref-type="aff" rid="aff-1"/>
</contrib>
<contrib contrib-type="author">
<contrib-id contrib-id-type="orcid">https://orcid.org/0000-0003-4754-1560</contrib-id>
<name>
<surname>Haas</surname>
<given-names>Kurt</given-names>
</name>
<xref ref-type="aff" rid="aff-1"/>
</contrib>
<aff id="aff-1">
<institution-wrap>
<institution>Department of Cellular and Physiological Sciences, Centre
for Brain Health, School of Biomedical Engineering, University of
British Columbia, Vancouver, Canada</institution>
</institution-wrap>
</aff>
</contrib-group>
<author-notes>
<corresp id="cor-1">* E-mail: <email></email></corresp>
</author-notes>
<pub-date date-type="pub" publication-format="electronic" iso-8601-date="2024-08-02">
<day>2</day>
<month>8</month>
<year>2024</year>
</pub-date>
<volume>9</volume>
<issue>100</issue>
<fpage>6877</fpage>
<permissions>
<copyright-statement>Authors of papers retain copyright and release the
work under a Creative Commons Attribution 4.0 International License (CC
BY 4.0)</copyright-statement>
<copyright-year>2022</copyright-year>
<copyright-holder>The article authors</copyright-holder>
<license license-type="open-access" xlink:href="https://creativecommons.org/licenses/by/4.0/">
<license-p>Authors of papers retain copyright and release the work under
a Creative Commons Attribution 4.0 International License (CC BY
4.0)</license-p>
</license>
</permissions>
<kwd-group kwd-group-type="author">
<kwd>Python</kwd>
<kwd>neuroscience</kwd>
<kwd>signal processing</kwd>
<kwd>calcium imaging</kwd>
<kwd>voltage imaging</kwd>
</kwd-group>
</article-meta>
</front>
<body>
<sec id="summary">
  <title>Summary</title>
  <p>Modern techniques for measuring neuronal activity using fluorescent
  biosensors and ultra-fast microscopy have allowed neuroscientists
  unprecedented access to neural information processing <italic>in
  vivo</italic>. The time series datasets generated from experiments
  sampling somatic action potentials from populations of neurons, or
  full-dendritic arbor sampling of populations of synapses, are becoming
  increasingly larger as new technologies allow for faster acquisition
  rates and higher temporal resolution of neural signals. Neuronal
  activities are sourced from an ever-expanding library of fluorescent
  indicators of distinct measures, including detectors of calcium,
  membrane voltage, and a range of neurotransmitters and
  neuromodulators. These biosensors are impacted by their unique
  molecular kinetics and inherent signal-to-noise properties. The
  quality of neural signal data sets are also impacted by acquisition
  instruments, which differ in sensitivity and sampling rate. All of
  these features, including underlying neural signals, biosensor
  properties, and microscope capabilities, must be considered during
  post-imaging signal processing with techniques that can scale to the
  size of modern neural datasets. To address this problem, here, we
  describe <monospace>pyNeuroTrace</monospace>, an open-source Python
  library developed to aid in processing neuronal signals from large
  fluorescent biosensor data sets, which allows dynamic control of
  filtering and signal processing with these unique aspects in mind
  before analyses of the underlying neuronal activity can be
  conducted.</p>
</sec>
<sec id="statement-of-need">
  <title>Statement of need</title>
  <p>Many neuroscience labs using optophysiological methods, such as
  sampling neural activity using two-photon microscopy or fiber
  photometry, typically must create and constantly adjust functions and
  filters to analyze raw recordings. Currently, there is limited
  standardization for approaches for signal processing, with techniques
  and algorithms scattered throughout the literature such as
  (<xref alt="Friedrich et al., 2017" rid="ref-Friedrich2017" ref-type="bibr">Friedrich
  et al., 2017</xref>), requiring substantial framework overhead
  (<xref alt="Giovannucci et al., 2019" rid="ref-Giovannucci2019" ref-type="bibr">Giovannucci
  et al., 2019</xref>) or implemented in various programming languages
  other than Python
  (<xref alt="Pérez-Ortega et al., 2024" rid="ref-Ortega2024" ref-type="bibr">Pérez-Ortega
  et al., 2024</xref>). Additionally, other popular tools used to
  extract calcium signals from imaging experiments often have limited
  signal processing utilities, lacking functions for calculating
  <inline-formula><alternatives>
  <tex-math><![CDATA[\Delta F/F]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>Δ</mml:mi><mml:mi>F</mml:mi><mml:mi>/</mml:mi><mml:mi>F</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>,
  forcing users to rely on independent methods
  (<xref alt="Pachitariu et al., 2017" rid="ref-Pachitariu2017" ref-type="bibr">Pachitariu
  et al., 2017</xref>). Our library,
  <monospace>pyNeuroTrace</monospace>, seeks to address these problems
  by providing an analytic package written purely in Python specifically
  for neuronal activity data sets. Our package includes a collection of
  filters and algorithms relevant to optophysiological analysis that are
  implemented in a generalizable manner for time series data sets in
  either 1D arrays or a collection of recordings in 2D arrays.
  Additionally, with the increase in acquisition rates of new imaging
  techniques, we have implemented a subset of these algorithms using
  GPU-compatible code to significantly increase processing speeds to
  accommodate large datasets collected, such as those from large
  population sampling or ultra-fast kilohertz sampling rates.</p>
</sec>
<sec id="signal-processing">
  <title>Signal Processing</title>
  <sec id="deltaff">
    <title>DeltaF/F</title>
    <p>There are several methods for calculating the change of intensity
    of a fluorescent indicator over time
    (<xref alt="Grienberger et al., 2022" rid="ref-Grienberger2022" ref-type="bibr">Grienberger
    et al., 2022</xref>). We implemented the method described by Jia
    <italic>et al.</italic> for the calculation of
    <inline-formula><alternatives>
    <tex-math><![CDATA[\Delta F/F]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>Δ</mml:mi><mml:mi>F</mml:mi><mml:mi>/</mml:mi><mml:mi>F</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>,
    which normalizes the signal to a baseline, helping with bleaching or
    other changes that occur over time, influencing the detection or
    magnitude of events in the raw signal
    (<xref alt="Jia et al., 2010" rid="ref-Jia2010" ref-type="bibr">Jia
    et al., 2010</xref>). This implementation includes several smoothing
    steps to mitigate shot noise
    (<xref alt="Jia et al., 2010" rid="ref-Jia2010" ref-type="bibr">Jia
    et al., 2010</xref>). In short, <inline-formula><alternatives>
    <tex-math><![CDATA[F_0]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>F</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:math></alternatives></inline-formula>
    is calculated by finding the minimum signal in a window of the
    rolling average of the raw signal. Next,
    <inline-formula><alternatives>
    <tex-math><![CDATA[\Delta F]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>Δ</mml:mi><mml:mi>F</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
    is calculated as the difference in the raw signal and
    <inline-formula><alternatives>
    <tex-math><![CDATA[F_0]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>F</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:math></alternatives></inline-formula>,
    which is then divided by <inline-formula><alternatives>
    <tex-math><![CDATA[F_0]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>F</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:math></alternatives></inline-formula>
    to attain the trace for <inline-formula><alternatives>
    <tex-math><![CDATA[\Delta F/F_0]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>Δ</mml:mi><mml:mi>F</mml:mi><mml:mi>/</mml:mi><mml:msub><mml:mi>F</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>.
    This <inline-formula><alternatives>
    <tex-math><![CDATA[\Delta F/F_0]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>Δ</mml:mi><mml:mi>F</mml:mi><mml:mi>/</mml:mi><mml:msub><mml:mi>F</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>
    signal can be optionally smoothed using an exponentially weighted
    moving average (EWMA) to remove shot noise. Jia <italic>et
    al.</italic> defined their rolling average with the following
    equation:</p>
    <p><disp-formula><alternatives>
    <tex-math><![CDATA[\bar{F} = \left(\frac{1}{\tau_1}\right) \int_{x-\tau_1/2}^{x+\tau_1/2} F(\tau) \, d\tau]]></tex-math>
    <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mover><mml:mi>F</mml:mi><mml:mo accent="true">‾</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:msub><mml:mi>τ</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mfrac><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:msubsup><mml:mo>∫</mml:mo><mml:mrow><mml:mi>x</mml:mi><mml:mo>−</mml:mo><mml:msub><mml:mi>τ</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mi>/</mml:mi><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>x</mml:mi><mml:mo>+</mml:mo><mml:msub><mml:mi>τ</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mi>/</mml:mi><mml:mn>2</mml:mn></mml:mrow></mml:msubsup><mml:mi>F</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>τ</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mspace width="0.167em"></mml:mspace><mml:mi>d</mml:mi><mml:mi>τ</mml:mi></mml:mrow></mml:math></alternatives></disp-formula></p>
    <p>The variable <inline-formula><alternatives>
    <tex-math><![CDATA[F_0]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>F</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:math></alternatives></inline-formula>
    is defined using a second time constant,
    <inline-formula><alternatives>
    <tex-math><![CDATA[\tau_2]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>τ</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:math></alternatives></inline-formula>,
    this parameter is the length of the rolling window to search for the
    minimum smoothed signal value to be used as a baseline:</p>
    <p><disp-formula><alternatives>
    <tex-math><![CDATA[ F_0(t) = min (\bar F(x) ) | t- \tau_2 < x < t ]]></tex-math>
    <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>m</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mover><mml:mi>F</mml:mi><mml:mo accent="true">‾</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="false" form="prefix">|</mml:mo><mml:mi>t</mml:mi><mml:mo>−</mml:mo><mml:msub><mml:mi>τ</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>&lt;</mml:mo><mml:mi>x</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>t</mml:mi></mml:mrow></mml:math></alternatives></disp-formula></p>
    <p>Thus <inline-formula><alternatives>
    <tex-math><![CDATA[\Delta F/F]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>Δ</mml:mi><mml:mi>F</mml:mi><mml:mi>/</mml:mi><mml:mi>F</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
    is calculated using <inline-formula><alternatives>
    <tex-math><![CDATA[F_0]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>F</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:math></alternatives></inline-formula>
    and <inline-formula><alternatives>
    <tex-math><![CDATA[F]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>F</mml:mi></mml:math></alternatives></inline-formula>
    where <inline-formula><alternatives>
    <tex-math><![CDATA[F]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>F</mml:mi></mml:math></alternatives></inline-formula>
    is the original raw signal:</p>
    <p><disp-formula><alternatives>
    <tex-math><![CDATA[
    \Delta F/F = \frac{ F(t)- F_0 }{ F_0 }
    ]]></tex-math>
    <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>Δ</mml:mi><mml:mi>F</mml:mi><mml:mi>/</mml:mi><mml:mi>F</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>F</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:msub><mml:mi>F</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mfrac></mml:mrow></mml:math></alternatives></disp-formula></p>
    <p>The two time constants, <inline-formula><alternatives>
    <tex-math><![CDATA[\tau_{1}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>τ</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math></alternatives></inline-formula>
    and <inline-formula><alternatives>
    <tex-math><![CDATA[\tau_{2}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>τ</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:math></alternatives></inline-formula>,
    can be selected by users. An additional third parameter
    <inline-formula><alternatives>
    <tex-math><![CDATA[\tau_{0}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>τ</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:math></alternatives></inline-formula>
    is used to optimize the EWMA functions that smooths the final
    <inline-formula><alternatives>
    <tex-math><![CDATA[\Delta F/F]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>Δ</mml:mi><mml:mi>F</mml:mi><mml:mi>/</mml:mi><mml:mi>F</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
    trace. Modifying these parameters will have a dramatic influence on
    the output signal. <monospace>pyNeuroTrace</monospace> uses defaults
    proposed by Jia <italic>et al.</italic>
    (<inline-formula><alternatives>
    <tex-math><![CDATA[\tau_{0}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>τ</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:math></alternatives></inline-formula>
    = 0.2 s, <inline-formula><alternatives>
    <tex-math><![CDATA[\tau_{1}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>τ</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math></alternatives></inline-formula>
    = 0.75 s, and <inline-formula><alternatives>
    <tex-math><![CDATA[\tau_{2}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>τ</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:math></alternatives></inline-formula>
    = 3 s), which work well for imaging at 30 Hz, these values should be
    adjusted for different imaging parameters.</p>
  </sec>
  <sec id="okada-filter">
    <title>Okada Filter</title>
    <p>We also provide a Python implementation of the Okada Filter
    (<xref alt="Okada et al., 2016" rid="ref-Okada2016" ref-type="bibr">Okada
    et al., 2016</xref>). This filter is designed to filter shot noise
    from traces in low-signal to noise paradigms, which is common for
    calcium imaging with two-photon microscopy where the collected
    photon count is low, and noise from PMT detectors can be nontrivial.
    This filter is defined by Okada <italic>et al.</italic> as:
    <disp-formula><alternatives>
    <tex-math><![CDATA[
     x_{t} \leftarrow x_{t} + \frac{x_{t-1} + x_{t+1} - 2x_{t}}{2(1 + e^{-\alpha (x_{t} - x_{t-1})(x_{t} - x_{t+1})})}
    ]]></tex-math>
    <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>t</mml:mi></mml:msub><mml:mo>←</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>t</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:msub><mml:mi>x</mml:mi><mml:mi>t</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mi>−</mml:mi><mml:mi>α</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>t</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>t</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:msup><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:mfrac></mml:mrow></mml:math></alternatives></disp-formula></p>
    <p>In this equation, <inline-formula><alternatives>
    <tex-math><![CDATA[x_{t}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>x</mml:mi><mml:mi>t</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
    is the value in the neural activity trace at time
    <inline-formula><alternatives>
    <tex-math><![CDATA[t]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>t</mml:mi></mml:math></alternatives></inline-formula>.
    The value for <inline-formula><alternatives>
    <tex-math><![CDATA[\alpha]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>α</mml:mi></mml:math></alternatives></inline-formula>,
    which is a coefficient, should be selected so that the product of
    <inline-formula><alternatives>
    <tex-math><![CDATA[x_{t} - x_{t-1}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>t</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>
    and <inline-formula><alternatives>
    <tex-math><![CDATA[x_{t} - x_{t+1}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>t</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>
    causes a sufficiently steep sigmoid curve which functions a binary
    filter in the equation. This function is equivalent to the following
    conditional states from Okada <italic>et al.</italic>:</p>
    <p><disp-formula><alternatives>
    <tex-math><![CDATA[
     \text{If } (x_{t} - x_{t-1})(x_{t} - x_{t+1}) \leq 0 \
    ]]></tex-math>
    <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mrow><mml:mtext mathvariant="normal">If </mml:mtext><mml:mspace width="0.333em"></mml:mspace></mml:mrow><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>t</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>t</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>≤</mml:mo><mml:mn>0</mml:mn><mml:mspace width="0.222em"></mml:mspace></mml:mrow></mml:math></alternatives></disp-formula>
    <disp-formula><alternatives>
    <tex-math><![CDATA[
    x_{t} \leftarrow x_{t} \
    ]]></tex-math>
    <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>t</mml:mi></mml:msub><mml:mo>←</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>t</mml:mi></mml:msub><mml:mspace width="0.222em"></mml:mspace></mml:mrow></mml:math></alternatives></disp-formula>
    <disp-formula><alternatives>
    <tex-math><![CDATA[
     \text{If } (x_{t} - x_{t-1})(x_{t} - x_{t+1}) > 0 
    ]]></tex-math>
    <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mrow><mml:mtext mathvariant="normal">If </mml:mtext><mml:mspace width="0.333em"></mml:mspace></mml:mrow><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>t</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>t</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></alternatives></disp-formula>
    <disp-formula><alternatives>
    <tex-math><![CDATA[
     x_{t} \leftarrow \frac{x_{t-1} + x_{t+1}}{2}
    ]]></tex-math>
    <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>t</mml:mi></mml:msub><mml:mo>←</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mn>2</mml:mn></mml:mfrac></mml:mrow></mml:math></alternatives></disp-formula></p>
    <p>Essentially, in each trace the Okada filter replaces the point
    <inline-formula><alternatives>
    <tex-math><![CDATA[x_{t}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>x</mml:mi><mml:mi>t</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
    with the average of adjacent values when the product of the
    differences in adjacent values is greater than zero. One useful
    characteristic of this smoothing algorithm is that it does not move
    the start position of events like other algorithms do
    (<xref alt="Okada et al., 2016" rid="ref-Okada2016" ref-type="bibr">Okada
    et al., 2016</xref>)</p>
  </sec>
  <sec id="nonnegative-deconvolution">
    <title>Nonnegative Deconvolution</title>
    <p>When the kinetics of biosensors are known, nonnegative
    deconvolution (NND) can be useful to deconvolve raw or
    <inline-formula><alternatives>
    <tex-math><![CDATA[\Delta F/F]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>Δ</mml:mi><mml:mi>F</mml:mi><mml:mi>/</mml:mi><mml:mi>F</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
    traces back into the most likely discrete triggers of increases in
    the sensors. <monospace>pyNeuroTrace</monospace> includes an
    implementation of an algorithm that can efficiently compute NND in
    linear time
    (<xref alt="Podgorski &amp; Haas, 2012" rid="ref-Podgorski2012" ref-type="bibr">Podgorski
    &amp; Haas, 2012</xref>). This can also be useful for denoising, as
    well particularly good at finding smaller magnitude events in
    fluorescent imaging that are often obfuscated by machine noise
    (<xref alt="Podgorski &amp; Haas, 2012" rid="ref-Podgorski2012" ref-type="bibr">Podgorski
    &amp; Haas, 2012</xref>).</p>
  </sec>
</sec>
<sec id="event-detection">
  <title>Event Detection</title>
  <p>The event detection module uses several strategies to identify
  neuronal activity events in time series datasets. These methodologies
  have been previously discussed and compared by Sakaki <italic>et
  al.</italic>
  (<xref alt="Sakaki et al., 2018" rid="ref-Sakaki2018" ref-type="bibr">Sakaki
  et al., 2018</xref>). These include two generalizable methods and one
  that requires prior knowledge of recorded event shape. The
  generalizable methods include filtering the signal through an
  exponentially weighted moving average (ewma) or cumulative sum of
  movement above the mean (cusum). The final filter is a matched filter
  that finds the probability of the trace matching a previously defined
  shape, such as one described by an exponential rise and decay of
  calcium signal generated by a genetically encoded calcium indicator
  (GECI). Computationally efficient algorithms were selected, allowing
  for the possibility of applying them in real-time during
  experiments.</p>
</sec>
<sec id="visualization">
  <title>Visualization</title>
  <p><monospace>pyNeuroTrace</monospace> has several built-in
  visualization tools depending on the format of the data. 2D arrays of
  neuronal timeseries can be displayed as heat maps
  <xref alt="[fig:heatmap]" rid="figU003Aheatmap">[fig:heatmap]</xref>
  or as individual traces
  <xref alt="[fig:traces]" rid="figU003Atraces">[fig:traces]</xref>. The
  heatmap is a useful visualization tool for inspecting many traces at
  once; additionally, at the bottom of the plot, the stimuli timing is
  displayed if provided
  <xref alt="[fig:heatmap]" rid="figU003Aheatmap">[fig:heatmap]</xref>.
  This functionality allows for quick visual inspection of from a
  population of neurons or signals sampled across a neuronal structure,
  such as a dendritic arbor.</p>
  <p>One of the in-built visualizations is specific to the data
  structure generated by a custom acousto-optic random access
  multi-photon (RAMP) microscope
  (<xref alt="Sakaki et al., 2020" rid="ref-Sakaki2020" ref-type="bibr">Sakaki
  et al., 2020</xref>)
  <xref alt="[fig:heatmap]" rid="figU003Aheatmap">[fig:heatmap]</xref>.
  This microscope uses acousto-optic deflectors (AODs) to perform
  inertia-free scanning between preselected points of interest, allowing
  for extremely fast acquisition rates for sampling neuronal activity
  throughout complex 3D neural structures. The scan engine of the
  microscope allows for random-access sampling for imaging activity
  across the entire dendritic arbor morphology of a single neuron
  (<xref alt="Sakaki et al., 2020" rid="ref-Sakaki2020" ref-type="bibr">Sakaki
  et al., 2020</xref>). This type of imaging does not generate a
  traditional image. The microscope instead links acquired neuronal
  traces to points of interest organized into a hierarchical tree
  structure representing the neuronal morphology in a complex data file.
  <monospace>pyNeuroTrace</monospace> will use additional information
  from this microscope to link structure and function by color-coding
  where neuronal activity comes from in a sampled neuron.</p>
  <fig>
    <caption><p>An example of a heatmap generated by pyNeuroTrace. A) An
    example of a lab-specific visualization of points of interest across
    a dendritic arbor imaged <italic>in vivo</italic> with an AOD
    random-access two-photon microscope. Plotted data was recorded from
    a single dendritic branch <italic>in vivo</italic> using a random
    access two-photon microscope. The indicator is a GCaMP6m, a plasmid
    encoding the GECI was single-cell electroporated
    (<xref alt="Haas et al., 2001" rid="ref-Haas2001" ref-type="bibr">Haas
    et al., 2001</xref>) B) Heatmap of visually evoked responses imaged
    at 148 Hz, showing intensity (yellow being highest), in addition to
    stim indicators along the X axis, and branch indicator along the Y.
    <styled-content id="figU003Aheatmap"></styled-content></p></caption>
    <graphic mimetype="image" mime-subtype="png" xlink:href="pynt_Branch_Heatmap.png" />
  </fig>
  <p>For individual or small numbers of activity traces,
  <monospace>pyNeuroTrace</monospace> has a line plot feature
  <xref alt="[fig:traces]" rid="figU003Atraces">[fig:traces]</xref>.
  This is an ideal option for inspecting the shape of events, which may
  be difficult to appreciate from the colormaps in the heatmap
  visualization. Dotted lines are plotted vertically across the traces
  of neural activity to indicate when stimulus presentation occurred
  during an experiment.</p>
  <fig>
    <caption><p>Six traces from neuron cell bodies imaged <italic>in
    vivo</italic> with a SLAP2 microscope. Tectal cells were bulk loaded
    with CAL-590-AM, a calcium senstive dye. Plotting individual traces
    better highlights the event shape
    <styled-content id="figU003Atraces"></styled-content></p></caption>
    <graphic mimetype="image" mime-subtype="png" xlink:href="pynt_lineplot_cal590.png" />
  </fig>
  <p>Additionally, if a record of stimulus or trigger times is provided
  <monospace>pyNeuroTrace</monospace> can plot the average evoked
  response in a recording.
  <xref alt="[fig:AvgResponse]" rid="figU003AAvgResponse">[fig:AvgResponse]</xref>
  shows the average evoked response to a full-field OFF and ON stimuli
  from the data in
  <xref alt="[fig:heatmap]" rid="figU003Aheatmap">[fig:heatmap]</xref>.
  This graph shows the evoked synaptic weights differ for the different
  visual stimuli presented to the animal.</p>
  <fig>
    <caption><p>Average stimulus-locked responses from the same
    <italic>in vivo</italic> imaging experiment of the dendritic branch
    in
    <xref alt="[fig:heatmap]" rid="figU003Aheatmap">[fig:heatmap]</xref>
    <styled-content id="figU003AAvgResponse"></styled-content>. The
    response for each branch node is plotted for two visual stimuli,
    full field OFF and ON</p></caption>
    <graphic mimetype="image" mime-subtype="png" xlink:href="pyn_avg_response_on_off_9.png" />
  </fig>
</sec>
<sec id="gpu-acceleration">
  <title>GPU Acceleration</title>
  <p>Several of the filters in <monospace>pyNeuroTrace</monospace> have
  been rewritten to be almost entirely vectorized in their calculations.
  The benefit is more noticeable when comparing the difference in
  performance while using large data sets, such as those generated using
  a longer time series or faster acquisition rates. These vectorized
  implementations gain further speed by being executed on a GPU using
  the Cupy Python library
  (<xref alt="Okuta et al., 2017" rid="ref-cupy_learningsys2017" ref-type="bibr">Okuta
  et al., 2017</xref>). The GPU-accelerated filters can be imported from
  the <monospace>pyneurotrace.gpu.filters</monospace> module, and a
  CUDA-compatible graphics card is required for their execution. This
  functionality is becoming increasingly crucial as acquisition rates
  increase for kilohertz imaging of activity
  (<xref alt="Zhang et al., 2019" rid="ref-Zhang2019" ref-type="bibr">Zhang
  et al., 2019</xref>), which can generate arrays of hundreds of
  thousands of data points in just a few minutes of recording.
  <xref alt="[fig:CPUvsGPU]" rid="figU003ACPUvsGPU">[fig:CPUvsGPU]</xref>
  shows the difference in calculating arrays of various sizes using
  either the CPU or vectorized GPU-based approach of the
  <inline-formula><alternatives>
  <tex-math><![CDATA[\Delta F/F]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>Δ</mml:mi><mml:mi>F</mml:mi><mml:mi>/</mml:mi><mml:mi>F</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
  function. The CPU used in these calculations was an Intel i5-9600K
  with six 4.600GHz cores; the GPU was an NVIDIA GeForce RTX 4070 with
  CUDA Version 12.3. When compared, the GPU calculation was on average
  in the order of 100 times faster on time series up to 100,000 points
  in size.</p>
  <fig>
    <caption><p>Comparison between <inline-formula><alternatives>
    <tex-math><![CDATA[\Delta F/F]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>Δ</mml:mi><mml:mi>F</mml:mi><mml:mi>/</mml:mi><mml:mi>F</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
    with EWMA calculations for different array sizes using either the
    CPU (blue) or GPU (orange).
    <styled-content id="figU003ACPUvsGPU"></styled-content></p></caption>
    <graphic mimetype="image" mime-subtype="png" xlink:href="dffCalculationCPUvsGPU_log.png" />
  </fig>
  <p>To vectorize the functions several were modified. For example the
  EMWA used to smooth the <inline-formula><alternatives>
  <tex-math><![CDATA[\Delta F/F]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>Δ</mml:mi><mml:mi>F</mml:mi><mml:mi>/</mml:mi><mml:mi>F</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
  signal as described by Jia <italic>et al.</italic> was changed to an
  approximation using convolution with an exponential function. The
  kernel used to perform this is defined as:</p>
  <p><disp-formula><alternatives>
  <tex-math><![CDATA[w[i] = \begin{cases} 
  \alpha \cdot (1 - \alpha)^i & \text{for } i = 0, 1, 2, \dots, N-1 \\
  0 & \text{otherwise}
  \end{cases}]]></tex-math>
  <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>w</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">{</mml:mo><mml:mtable><mml:mtr><mml:mtd columnalign="left" style="text-align: left"><mml:mi>α</mml:mi><mml:mo>⋅</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>α</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msup></mml:mtd><mml:mtd columnalign="left" style="text-align: left"><mml:mrow><mml:mtext mathvariant="normal">for </mml:mtext><mml:mspace width="0.333em"></mml:mspace></mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mi>…</mml:mi><mml:mo>,</mml:mo><mml:mi>N</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left" style="text-align: left"><mml:mn>0</mml:mn></mml:mtd><mml:mtd columnalign="left" style="text-align: left"><mml:mtext mathvariant="normal">otherwise</mml:mtext></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:math></alternatives></disp-formula></p>
  <p>Where <inline-formula><alternatives>
  <tex-math><![CDATA[\alpha]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>α</mml:mi></mml:math></alternatives></inline-formula>
  is defined as:</p>
  <p><disp-formula><alternatives>
  <tex-math><![CDATA[ \alpha = 1 - e^{-\frac{1}{\tau}}]]></tex-math>
  <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>α</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mi>−</mml:mi><mml:mfrac><mml:mn>1</mml:mn><mml:mi>τ</mml:mi></mml:mfrac></mml:mrow></mml:msup></mml:mrow></mml:math></alternatives></disp-formula>
  <inline-formula><alternatives>
  <tex-math><![CDATA[\tau]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>τ</mml:mi></mml:math></alternatives></inline-formula>
  is a user-selected time constant in seconds, which is translated into
  the number of samples using the acquisition rate used to acquire the
  data. <inline-formula><alternatives>
  <tex-math><![CDATA[N]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>N</mml:mi></mml:math></alternatives></inline-formula>
  is a window parameter for the kernel calculated using
  <inline-formula><alternatives>
  <tex-math><![CDATA[\alpha]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>α</mml:mi></mml:math></alternatives></inline-formula>:
  <disp-formula><alternatives>
  <tex-math><![CDATA[N = \left\lfloor -\frac{\log(10^{-10})}{\alpha} \right\rfloor]]></tex-math>
  <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>N</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">⌊</mml:mo><mml:mi>−</mml:mi><mml:mfrac><mml:mrow><mml:mo>log</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msup><mml:mn>10</mml:mn><mml:mrow><mml:mi>−</mml:mi><mml:mn>10</mml:mn></mml:mrow></mml:msup><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow><mml:mi>α</mml:mi></mml:mfrac><mml:mo stretchy="true" form="postfix">⌋</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></disp-formula></p>
  <p>This filters for smaller values that have a minuscule influence on
  the weighted average. The kernel needs to be normalized such that the
  sum of its elements is 1, to produce smoothing with the same
  approximate value as the non-vectorized implementation:</p>
  <p><disp-formula><alternatives>
  <tex-math><![CDATA[w[i] \leftarrow \frac{w[i]}{\sum_{j=0}^{N-1} w[j]}]]></tex-math>
  <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>w</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow><mml:mo>←</mml:mo><mml:mfrac><mml:mrow><mml:mi>w</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>N</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:mi>w</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow></mml:mrow></mml:mfrac></mml:mrow></mml:math></alternatives></disp-formula>
  The normalized kernel is then convolved with the
  <inline-formula><alternatives>
  <tex-math><![CDATA[\Delta F/F]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>Δ</mml:mi><mml:mi>F</mml:mi><mml:mi>/</mml:mi><mml:mi>F</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
  signal, d: <disp-formula><alternatives>
  <tex-math><![CDATA[c[k] = \sum_{i=0}^{N-1} w[i]\cdot d[k-i]]]></tex-math>
  <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>c</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>N</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:mi>w</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow><mml:mo>⋅</mml:mo><mml:mi>d</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></disp-formula></p>
  <p>This convolved signal, <inline-formula><alternatives>
  <tex-math><![CDATA[c]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>c</mml:mi></mml:math></alternatives></inline-formula>
  is then normalized to the cumulative sum of the exponential
  kernel:</p>
  <p><disp-formula><alternatives>
  <tex-math><![CDATA[n[j] = \sum_{i=0}^{j} w[i]]]></tex-math>
  <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>n</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mi>j</mml:mi></mml:munderover><mml:mi>w</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></disp-formula></p>
  <p><disp-formula><alternatives>
  <tex-math><![CDATA[emwa = \frac{c[i]}{n[i]}]]></tex-math>
  <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>e</mml:mi><mml:mi>m</mml:mi><mml:mi>w</mml:mi><mml:mi>a</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>c</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow></mml:mrow></mml:mfrac></mml:mrow></mml:math></alternatives></disp-formula></p>
  <fig>
    <caption><p>Overlay of the EWMA calculations using the CPU
    implementation and GPU approximation in red and blue. The difference
    in values from the output is also plotted. The EWMA traces diverge
    after the initial window length of the GPU version’s kernel, but
    never by more than a factor of 1e-11.
    <styled-content id="figU003AewmaCPUvsGPU"></styled-content></p></caption>
    <graphic mimetype="image" mime-subtype="png" xlink:href="ewma_CPUvsGPU.png" />
  </fig>
  <p>To demonstrate the differences between the CPU and GPU
  implementations of the EWMA calculations were performed on an array of
  random values
  <xref alt="[fig:ewmaCPUvsGPU]" rid="figU003AewmaCPUvsGPU">[fig:ewmaCPUvsGPU]</xref>.
  These were generated from the same array using the respective decays
  for either implementation using the time constant of 50 milliseconds
  and a sampling rate of 2kHz. Depending on user parameters, the
  difference between the two outputs typically ranges in magnitude from
  1e-16 to 1e-12. These discrepancies can also be attributed to
  differences in floating-point number accuracy between CPU and GPU
  calculations.</p>
</sec>
<sec id="methods">
  <title>Methods</title>
  <sec id="animals">
    <title>Animals</title>
    <p>Free-swimming albino <italic>Xenopus laevis</italic> tadpoles
    were reared in 10% Steinberg’s solution and kept in a 12-hour
    light/dark cycle at 22°C. All experiments were performed on Stage 48
    tadpoles.</p>
  </sec>
  <sec id="in-vivo-single-cell-electroporation-of-dna-and-dye">
    <title><italic>In vivo</italic> Single-Cell Electroporation of DNA
    and Dye</title>
    <p>Single-cell electroporation (SCE) was used to label individual
    cells with fluorescent calcium indicators
    (<xref alt="Haas et al., 2001" rid="ref-Haas2001" ref-type="bibr">Haas
    et al., 2001</xref>). A single tectal cell was transfected
    <italic>in vivo</italic> using SCE with a GCaMP6m plasmid
    <xref alt="[fig:heatmap]" rid="figU003Aheatmap">[fig:heatmap]</xref>.
    In brief, the tadpole was anesthetized using 0.02% MS-222 in
    Steinberg’s solution. A pulled glass pipette filled with 1
    <inline-formula><alternatives>
    <tex-math><![CDATA[\mu g/\mu l]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>μ</mml:mi><mml:mi>g</mml:mi><mml:mi>/</mml:mi><mml:mi>μ</mml:mi><mml:mi>l</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
    of plasmid DNA was stimulated using an Axoporator 800A
    electroporator (Molecular Devices). The electroporator parameters
    were set to 1 ms, -40 V pulses at 300 Hz for 300 ms. In another
    tadpole, an individual tectal cell was loaded with 2 mM of CAL-590
    3000 Dextran (AAT Bioquest)
    <xref alt="[fig:CPUvsGPU]" rid="figU003ACPUvsGPU">[fig:CPUvsGPU]</xref>.
    The parameters for the dye electroporation were set to 1 ms, -40 V
    pulses at 900 Hz for 50 ms.</p>
  </sec>
  <sec id="bulk-loading-calcium-indicators">
    <title>Bulk Loading Calcium Indicators</title>
    <p>CAL-590-AM (AAT Bioquest) was pressure-injected using a modified
    protocol previously described
    (<xref alt="Hogg &amp; Haas, 2021" rid="ref-Hogg2021" ref-type="bibr">Hogg
    &amp; Haas, 2021</xref>). A 10 mM CAL-590-AM stock solution was
    prepared in DMSO with 20% Pluronic Acid (ThermoFisher). This
    solution was diluted 1:10 in Calcium Free-Ringers as previously
    described for Oregon Green™ 488 BAPTA-1 imaging protocol
    (<xref alt="Hogg &amp; Haas, 2021" rid="ref-Hogg2021" ref-type="bibr">Hogg
    &amp; Haas, 2021</xref>). The tadpole was anesthetized using 0.02%
    MS-222 in Steinberg’s solution before injection. A glass pipette
    filled with the dye was inserted into the optic tectum. The dye was
    pressure-injected using 0.02 MPa <inline-formula><alternatives>
    <tex-math><![CDATA[N_2]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>N</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:math></alternatives></inline-formula>
    gas and an OpenSpritzer MicroInjector (NeuroGig)
    (<xref alt="Forman et al., 2017" rid="ref-Forman2017" ref-type="bibr">Forman
    et al., 2017</xref>).</p>
  </sec>
  <sec id="in-vivo-imaging-of-neuronal-activity">
    <title><italic>In vivo</italic> Imaging of Neuronal Activity</title>
    <p>Neuronal activity recordings were performed using two-photon
    microscopy. All animals were reversibly paralyzed by bath
    application of 2 mM pancuronium dibromide for 5 minutes (Tocris)
    before being transferred to a custom imaging chamber
    (<xref alt="Sakaki et al., 2020" rid="ref-Sakaki2020" ref-type="bibr">Sakaki
    et al., 2020</xref>). The GCaMP6m expressing neuron was imaged using
    a custom AOD-based RAMP microscope previously described
    (<xref alt="Sakaki et al., 2020" rid="ref-Sakaki2020" ref-type="bibr">Sakaki
    et al., 2020</xref>). A Ti:Sapphire laser (Chameleon Vision II,
    Coherent) tuned to 910 nm was used for two-photon excitation, and
    emitted light was captured using a 60x, 1.1 NA water-immersion
    objective (LUMPL, Olympus). Tectal cells filled with CAL-590 AM were
    imaged using a custom microscope built from a commercial kit
    (<xref alt="Podgorski, 2021" rid="ref-mbfSLAP2" ref-type="bibr">Podgorski,
    2021</xref>). The excitation source was a 1030 nm custom
    Ytterbium-doped fiber laser with an average power of 68 W, 150 fs
    pulse width, and 40 MHz repetition rate (Tangerine-SP, Amplitude).
    Full-field raster imaging was collected at 13.5 Hz through a 25x 1.0
    NA water-immersion objective (HC IRAPO, Leica)
    <xref alt="[fig:traces]" rid="figU003Atraces">[fig:traces]</xref>.
    The microscope’s integrated scan mode was used to capture calcium
    signals at 2 kHz from a branch of a neuron labeled with CAL-590 3k
    Dextran
    <xref alt="[fig:CPUvsGPU]" rid="figU003ACPUvsGPU">[fig:CPUvsGPU]</xref>.
    All signal processing was performed using pyNeuroTrace.</p>
  </sec>
</sec>
<sec id="ethics-statement">
  <title>Ethics Statement</title>
  <p>All animal data were collected from experiments reviewed and
  approved by the University of British Columbia Animal Care Committee
  under protocols A19-0297 and A24-0049. These experiments were
  conducted in accordance with the guidelines established by the
  Canadian Council on Animal Care.</p>
</sec>
<sec id="acknowledgements">
  <title>Acknowledgements</title>
  <p>The development of this software was supported by funds from the
  Canadian Institutes of Health Research (CIHR) Foundation Award
  (FDN-148468).</p>
</sec>
</body>
<back>
<ref-list>
  <title></title>
  <ref id="ref-Giovannucci2019">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Giovannucci</surname><given-names>Andrea</given-names></name>
        <name><surname>Friedrich</surname><given-names>Johannes</given-names></name>
        <name><surname>Gunn</surname><given-names>Pat</given-names></name>
        <name><surname>Kalfon</surname><given-names>Jérémie</given-names></name>
        <name><surname>Brown</surname><given-names>Brandon L</given-names></name>
        <name><surname>Koay</surname><given-names>Sue Ann</given-names></name>
        <name><surname>Taxidis</surname><given-names>Jiannis</given-names></name>
        <name><surname>Najafi</surname><given-names>Farzaneh</given-names></name>
        <name><surname>Gauthier</surname><given-names>Jeffrey L</given-names></name>
        <name><surname>Zhou</surname><given-names>Pengcheng</given-names></name>
        <name><surname>Khakh</surname><given-names>Baljit S</given-names></name>
        <name><surname>Tank</surname><given-names>David W</given-names></name>
        <name><surname>Chklovskii</surname><given-names>Dmitri B</given-names></name>
        <name><surname>Pnevmatikakis</surname><given-names>Eftychios A</given-names></name>
      </person-group>
      <article-title>CaImAn an open source tool for scalable calcium imaging data analysis</article-title>
      <source>eLife</source>
      <person-group person-group-type="editor">
        <name><surname>Kleinfeld</surname><given-names>David</given-names></name>
        <name><surname>King</surname><given-names>Andrew J</given-names></name>
      </person-group>
      <publisher-name>eLife Sciences Publications, Ltd</publisher-name>
      <year iso-8601-date="2019-01">2019</year><month>01</month>
      <volume>8</volume>
      <issn>2050-084X</issn>
      <uri>https://doi.org/10.7554/eLife.38173</uri>
      <pub-id pub-id-type="doi">10.7554/eLife.38173</pub-id>
      <fpage>e38173</fpage>
      <lpage></lpage>
    </element-citation>
  </ref>
  <ref id="ref-Friedrich2017">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Friedrich</surname><given-names>Johannes</given-names></name>
        <name><surname>Zhou</surname><given-names>Pengcheng</given-names></name>
        <name><surname>Paninski</surname><given-names>Liam</given-names></name>
      </person-group>
      <article-title>Fast online deconvolution of calcium imaging data</article-title>
      <source>PLoS Comput. Biol.</source>
      <year iso-8601-date="2017-03">2017</year><month>03</month>
      <volume>13</volume>
      <issue>3</issue>
      <uri>http://dx.doi.org/10.1371/journal.pcbi.1005423</uri>
      <pub-id pub-id-type="doi">10.1371/journal.pcbi.1005423</pub-id>
      <fpage>e1005423</fpage>
      <lpage></lpage>
    </element-citation>
  </ref>
  <ref id="ref-Ortega2024">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Pérez-Ortega</surname><given-names>Jesús</given-names></name>
        <name><surname>Akrouh</surname><given-names>Alejandro</given-names></name>
        <name><surname>Yuste</surname><given-names>Rafael</given-names></name>
      </person-group>
      <article-title>Stimulus encoding by specific inactivation of cortical neurons</article-title>
      <source>Nature Communications</source>
      <year iso-8601-date="2024-04">2024</year><month>04</month>
      <volume>15</volume>
      <uri>http://dx.doi.org/10.1038/s41467-024-47515-x</uri>
      <pub-id pub-id-type="doi">10.1038/s41467-024-47515-x</pub-id>
      <fpage></fpage>
      <lpage></lpage>
    </element-citation>
  </ref>
  <ref id="ref-Grienberger2022">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Grienberger</surname><given-names>Christine</given-names></name>
        <name><surname>Giovannucci</surname><given-names>Andrea</given-names></name>
        <name><surname>Zeiger</surname><given-names>William</given-names></name>
        <name><surname>Portera-Cailliau</surname><given-names>Carlos</given-names></name>
      </person-group>
      <article-title>Two-photon calcium imaging of neuronal activity</article-title>
      <source>Nature Reviews Methods Primers</source>
      <publisher-name>Springer Science; Business Media LLC</publisher-name>
      <year iso-8601-date="2022-09">2022</year><month>09</month>
      <volume>2</volume>
      <issue>1</issue>
      <issn>2662-8449</issn>
      <uri>http://dx.doi.org/10.1038/s43586-022-00147-1</uri>
      <pub-id pub-id-type="doi">10.1038/s43586-022-00147-1</pub-id>
    </element-citation>
  </ref>
  <ref id="ref-Okada2016">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Okada</surname><given-names>Mami</given-names></name>
        <name><surname>Ishikawa</surname><given-names>Tomoe</given-names></name>
        <name><surname>Ikegaya</surname><given-names>Yuji</given-names></name>
      </person-group>
      <article-title>A computationally efficient filter for reducing shot noise in low s/n data</article-title>
      <source>PLOS ONE</source>
      <year iso-8601-date="2016-06">2016</year><month>06</month>
      <volume>11</volume>
      <pub-id pub-id-type="doi">10.1371/journal.pone.0157595</pub-id>
      <fpage>e0157595</fpage>
      <lpage></lpage>
    </element-citation>
  </ref>
  <ref id="ref-Podgorski2012">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Podgorski</surname><given-names>Kaspar</given-names></name>
        <name><surname>Haas</surname><given-names>Kurt</given-names></name>
      </person-group>
      <article-title>Fast non‐negative temporal deconvolution for laser scanning microscopy</article-title>
      <source>Journal of Biophotonics</source>
      <publisher-name>Wiley</publisher-name>
      <year iso-8601-date="2012-03">2012</year><month>03</month>
      <volume>6</volume>
      <issue>2</issue>
      <issn>1864-0648</issn>
      <uri>http://dx.doi.org/10.1002/jbio.201100133</uri>
      <pub-id pub-id-type="doi">10.1002/jbio.201100133</pub-id>
      <fpage>153</fpage>
      <lpage>162</lpage>
    </element-citation>
  </ref>
  <ref id="ref-Jia2010">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Jia</surname><given-names>Hongbo</given-names></name>
        <name><surname>Rochefort</surname><given-names>Nathalie L</given-names></name>
        <name><surname>Chen</surname><given-names>Xiaowei</given-names></name>
        <name><surname>Konnerth</surname><given-names>Arthur</given-names></name>
      </person-group>
      <article-title>In vivo two-photon imaging of sensory-evoked dendritic calcium signals in cortical neurons</article-title>
      <source>Nature Protocols</source>
      <publisher-name>Springer Science; Business Media LLC</publisher-name>
      <year iso-8601-date="2010-12">2010</year><month>12</month>
      <volume>6</volume>
      <issue>1</issue>
      <issn>1750-2799</issn>
      <uri>http://dx.doi.org/10.1038/nprot.2010.169</uri>
      <pub-id pub-id-type="doi">10.1038/nprot.2010.169</pub-id>
      <fpage>28</fpage>
      <lpage>35</lpage>
    </element-citation>
  </ref>
  <ref id="ref-cupy_learningsys2017">
    <element-citation publication-type="paper-conference">
      <person-group person-group-type="author">
        <name><surname>Okuta</surname><given-names>Ryosuke</given-names></name>
        <name><surname>Unno</surname><given-names>Yuya</given-names></name>
        <name><surname>Nishino</surname><given-names>Daisuke</given-names></name>
        <name><surname>Hido</surname><given-names>Shohei</given-names></name>
        <name><surname>Loomis</surname><given-names>Crissman</given-names></name>
      </person-group>
      <article-title>CuPy: A NumPy-compatible library for NVIDIA GPU calculations</article-title>
      <source>Proceedings of workshop on machine learning systems (LearningSys) in the thirty-first annual conference on neural information processing systems (NIPS)</source>
      <year iso-8601-date="2017">2017</year>
      <uri>http://learningsys.org/nips17/assets/papers/paper_16.pdf</uri>
    </element-citation>
  </ref>
  <ref id="ref-Zhang2019">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Zhang</surname><given-names>Tong</given-names></name>
        <name><surname>Hernandez</surname><given-names>Oscar</given-names></name>
        <name><surname>Chrapkiewicz</surname><given-names>Radosław</given-names></name>
        <name><surname>Shai</surname><given-names>Adam</given-names></name>
        <name><surname>Wagner</surname><given-names>Mark</given-names></name>
        <name><surname>Zhang</surname><given-names>Yanping</given-names></name>
        <name><surname>Wu</surname><given-names>Cheng-Hsun</given-names></name>
        <name><surname>Li</surname><given-names>Jinzhong</given-names></name>
        <name><surname>Inoue</surname><given-names>Masatoshi</given-names></name>
        <name><surname>Gong</surname><given-names>Yiyang</given-names></name>
        <name><surname>Ahanonu</surname><given-names>Biafra</given-names></name>
        <name><surname>Zeng</surname><given-names>Hongkui</given-names></name>
        <name><surname>Bito</surname><given-names>Haruhiko</given-names></name>
        <name><surname>Schnitzer</surname><given-names>Mark</given-names></name>
      </person-group>
      <article-title>Kilohertz two-photon brain imaging in awake mice</article-title>
      <source>Nature Methods</source>
      <year iso-8601-date="2019-11">2019</year><month>11</month>
      <volume>16</volume>
      <uri>http://dx.doi.org/10.1038/s41592-019-0597-2</uri>
      <pub-id pub-id-type="doi">10.1038/s41592-019-0597-2</pub-id>
      <fpage></fpage>
      <lpage></lpage>
    </element-citation>
  </ref>
  <ref id="ref-Sakaki2018">
    <element-citation publication-type="paper-conference">
      <person-group person-group-type="author">
        <name><surname>Sakaki</surname><given-names>Kelly D. R.</given-names></name>
        <name><surname>Coleman</surname><given-names>Patrick</given-names></name>
        <name><surname>Toth</surname><given-names>Tristan Dellazizzo</given-names></name>
        <name><surname>Guerrier</surname><given-names>Claire</given-names></name>
        <name><surname>Haas</surname><given-names>Kurt</given-names></name>
      </person-group>
      <article-title>Automating event-detection of brain neuron synaptic activity and action potential firing in vivo using a random-access multiphoton laser scanning microscope for real-time analysis</article-title>
      <source>2018 40th annual international conference of the IEEE engineering in medicine and biology society (EMBC)</source>
      <publisher-name>IEEE</publisher-name>
      <year iso-8601-date="2018-07">2018</year><month>07</month>
      <uri>http://dx.doi.org/10.1109/EMBC.2018.8512983</uri>
      <pub-id pub-id-type="doi">10.1109/embc.2018.8512983</pub-id>
    </element-citation>
  </ref>
  <ref id="ref-Sakaki2020">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Sakaki</surname><given-names>Kelly D. R.</given-names></name>
        <name><surname>Podgorski</surname><given-names>Kaspar</given-names></name>
        <name><surname>Dellazizzo Toth</surname><given-names>Tristan A.</given-names></name>
        <name><surname>Coleman</surname><given-names>Patrick</given-names></name>
        <name><surname>Haas</surname><given-names>Kurt</given-names></name>
      </person-group>
      <article-title>Comprehensive imaging of sensory-evoked activity of entire neurons within the awake developing brain using ultrafast AOD-based random-access two-photon microscopy</article-title>
      <source>Frontiers in Neural Circuits</source>
      <publisher-name>Frontiers Media SA</publisher-name>
      <year iso-8601-date="2020-06">2020</year><month>06</month>
      <volume>14</volume>
      <issn>1662-5110</issn>
      <uri>http://dx.doi.org/10.3389/fncir.2020.00033</uri>
      <pub-id pub-id-type="doi">10.3389/fncir.2020.00033</pub-id>
    </element-citation>
  </ref>
  <ref id="ref-Haas2001">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Haas</surname><given-names>Kurt</given-names></name>
        <name><surname>Sin</surname><given-names>Wun-Chey</given-names></name>
        <name><surname>Javaherian</surname><given-names>Ashkan</given-names></name>
        <name><surname>Li</surname><given-names>Zheng</given-names></name>
        <name><surname>Cline</surname><given-names>Hollis T</given-names></name>
      </person-group>
      <article-title>Single-cell electroporationfor gene transfer in vivo</article-title>
      <source>Neuron</source>
      <publisher-name>Elsevier BV</publisher-name>
      <year iso-8601-date="2001-03">2001</year><month>03</month>
      <volume>29</volume>
      <issue>3</issue>
      <issn>0896-6273</issn>
      <uri>http://dx.doi.org/10.1016/s0896-6273(01)00235-5</uri>
      <pub-id pub-id-type="doi">10.1016/s0896-6273(01)00235-5</pub-id>
      <fpage>583</fpage>
      <lpage>591</lpage>
    </element-citation>
  </ref>
  <ref id="ref-Pachitariu2017">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Pachitariu</surname><given-names>Marius</given-names></name>
        <name><surname>Stringer</surname><given-names>Carsen</given-names></name>
        <name><surname>Dipoppa</surname><given-names>Mario</given-names></name>
        <name><surname>Schröder</surname><given-names>Sylvia</given-names></name>
        <name><surname>Rossi</surname><given-names>L. Federico</given-names></name>
        <name><surname>Dalgleish</surname><given-names>Henry</given-names></name>
        <name><surname>Carandini</surname><given-names>Matteo</given-names></name>
        <name><surname>Harris</surname><given-names>Kenneth D.</given-names></name>
      </person-group>
      <article-title>Suite2p: Beyond 10,000 neurons with standard two-photon microscopy</article-title>
      <source>bioRxiv</source>
      <publisher-name>Cold Spring Harbor Laboratory</publisher-name>
      <year iso-8601-date="2017">2017</year>
      <uri>https://www.biorxiv.org/content/early/2017/07/20/061507</uri>
      <pub-id pub-id-type="doi">10.1101/061507</pub-id>
    </element-citation>
  </ref>
  <ref id="ref-Hogg2021">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Hogg</surname><given-names>Peter W.</given-names></name>
        <name><surname>Haas</surname><given-names>Kurt</given-names></name>
      </person-group>
      <article-title>Bulk dye loading for in vivo calcium imaging of visual responses in populations of xenopus tectal neurons</article-title>
      <source>Cold Spring Harbor Protocols</source>
      <publisher-name>Cold Spring Harbor Laboratory</publisher-name>
      <year iso-8601-date="2021-03">2021</year><month>03</month>
      <volume>2022</volume>
      <issue>1</issue>
      <issn>1559-6095</issn>
      <uri>http://dx.doi.org/10.1101/pdb.prot106831</uri>
      <pub-id pub-id-type="doi">10.1101/pdb.prot106831</pub-id>
      <fpage>pdb.prot106831</fpage>
      <lpage></lpage>
    </element-citation>
  </ref>
  <ref id="ref-Forman2017">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Forman</surname><given-names>C. J.</given-names></name>
        <name><surname>Tomes</surname><given-names>H.</given-names></name>
        <name><surname>Mbobo</surname><given-names>B.</given-names></name>
        <name><surname>Burman</surname><given-names>R. J.</given-names></name>
        <name><surname>Jacobs</surname><given-names>M.</given-names></name>
        <name><surname>Baden</surname><given-names>T</given-names></name>
        <name><surname>Raimondo</surname><given-names>J. V.</given-names></name>
      </person-group>
      <article-title>Openspritzer: An open hardware pressure ejection system for reliably delivering picolitre volumes</article-title>
      <source>Scientific Reports</source>
      <publisher-name>Springer Science; Business Media LLC</publisher-name>
      <year iso-8601-date="2017-05">2017</year><month>05</month>
      <volume>7</volume>
      <issue>1</issue>
      <issn>2045-2322</issn>
      <uri>http://dx.doi.org/10.1038/s41598-017-02301-2</uri>
      <pub-id pub-id-type="doi">10.1038/s41598-017-02301-2</pub-id>
    </element-citation>
  </ref>
  <ref id="ref-mbfSLAP2">
    <element-citation>
      <person-group person-group-type="author">
        <name><surname>Podgorski</surname><given-names>Kaspar</given-names></name>
      </person-group>
      <article-title>SLAP2 – two photon microscope kit</article-title>
      <source>Product Page</source>
      <publisher-name>MBF Bioscience</publisher-name>
      <year iso-8601-date="2021">2021</year>
      <uri>https://www.mbfbioscience.com/products/slap2</uri>
    </element-citation>
  </ref>
</ref-list>
</back>
</article>
