<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN"
                  "JATS-publishing1.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" dtd-version="1.2" article-type="other">
<front>
<journal-meta>
<journal-id></journal-id>
<journal-title-group>
<journal-title>Journal of Open Source Software</journal-title>
<abbrev-journal-title>JOSS</abbrev-journal-title>
</journal-title-group>
<issn publication-format="electronic">2475-9066</issn>
<publisher>
<publisher-name>Open Journals</publisher-name>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="publisher-id">5585</article-id>
<article-id pub-id-type="doi">10.21105/joss.05585</article-id>
<title-group>
<article-title>QuantEcon.py: A community based Python library for
quantitative economics</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author">
<name>
<surname>Batista</surname>
<given-names>Quentin</given-names>
</name>
<xref ref-type="aff" rid="aff-5"/>
</contrib>
<contrib contrib-type="author">
<name>
<surname>Coleman</surname>
<given-names>Chase</given-names>
</name>
<xref ref-type="aff" rid="aff-4"/>
</contrib>
<contrib contrib-type="author">
<name>
<surname>Furusawa</surname>
<given-names>Yuya</given-names>
</name>
<xref ref-type="aff" rid="aff-6"/>
</contrib>
<contrib contrib-type="author">
<name>
<surname>Hu</surname>
<given-names>Shu</given-names>
</name>
<xref ref-type="aff" rid="aff-1"/>
</contrib>
<contrib contrib-type="author">
<name>
<surname>Lunagariya</surname>
<given-names>Smit</given-names>
</name>
<xref ref-type="aff" rid="aff-3"/>
</contrib>
<contrib contrib-type="author">
<name>
<surname>Lyon</surname>
<given-names>Spencer</given-names>
</name>
<xref ref-type="aff" rid="aff-4"/>
</contrib>
<contrib contrib-type="author">
<name>
<surname>McKay</surname>
<given-names>Matthew</given-names>
</name>
<xref ref-type="aff" rid="aff-1"/>
</contrib>
<contrib contrib-type="author">
<name>
<surname>Oyama</surname>
<given-names>Daisuke</given-names>
</name>
<xref ref-type="aff" rid="aff-2"/>
</contrib>
<contrib contrib-type="author">
<name>
<surname>Sargent</surname>
<given-names>Thomas J.</given-names>
</name>
<xref ref-type="aff" rid="aff-4"/>
</contrib>
<contrib contrib-type="author">
<name>
<surname>Shi</surname>
<given-names>Zejin</given-names>
</name>
<xref ref-type="aff" rid="aff-7"/>
</contrib>
<contrib contrib-type="author">
<name>
<surname>Stachurski</surname>
<given-names>John</given-names>
</name>
<xref ref-type="aff" rid="aff-1"/>
</contrib>
<contrib contrib-type="author">
<name>
<surname>Winant</surname>
<given-names>Pablo</given-names>
</name>
<xref ref-type="aff" rid="aff-8"/>
</contrib>
<contrib contrib-type="author">
<name>
<surname>Watkins</surname>
<given-names>Natasha</given-names>
</name>
<xref ref-type="aff" rid="aff-1"/>
</contrib>
<contrib contrib-type="author">
<name>
<surname>Yang</surname>
<given-names>Ziyue</given-names>
</name>
<xref ref-type="aff" rid="aff-1"/>
</contrib>
<contrib contrib-type="author">
<name>
<surname>Zhang</surname>
<given-names>Hengcheng</given-names>
</name>
<xref ref-type="aff" rid="aff-1"/>
</contrib>
<aff id="aff-1">
<institution-wrap>
<institution>The Australian National University</institution>
</institution-wrap>
</aff>
<aff id="aff-2">
<institution-wrap>
<institution>University of Tokyo</institution>
</institution-wrap>
</aff>
<aff id="aff-3">
<institution-wrap>
<institution>Indian Institute of Technology (BHU),
Varanasi</institution>
</institution-wrap>
</aff>
<aff id="aff-4">
<institution-wrap>
<institution>New York University</institution>
</institution-wrap>
</aff>
<aff id="aff-5">
<institution-wrap>
<institution>Massachusetts Institute of Technology</institution>
</institution-wrap>
</aff>
<aff id="aff-6">
<institution-wrap>
<institution>Crop.inc</institution>
</institution-wrap>
</aff>
<aff id="aff-7">
<institution-wrap>
<institution>The University of Arizona</institution>
</institution-wrap>
</aff>
<aff id="aff-8">
<institution-wrap>
<institution>ESCP Business School and Ecole Polytechnique</institution>
</institution-wrap>
</aff>
</contrib-group>
<pub-date date-type="pub" publication-format="electronic" iso-8601-date="2023-12-13">
<day>13</day>
<month>12</month>
<year>2023</year>
</pub-date>
<volume>9</volume>
<issue>93</issue>
<fpage>5585</fpage>
<permissions>
<copyright-statement>Authors of papers retain copyright and release the
work under a Creative Commons Attribution 4.0 International License (CC
BY 4.0)</copyright-statement>
<copyright-year>2022</copyright-year>
<copyright-holder>The article authors</copyright-holder>
<license license-type="open-access" xlink:href="https://creativecommons.org/licenses/by/4.0/">
<license-p>Authors of papers retain copyright and release the work under
a Creative Commons Attribution 4.0 International License (CC BY
4.0)</license-p>
</license>
</permissions>
<kwd-group kwd-group-type="author">
<kwd>Python</kwd>
<kwd>Economics</kwd>
</kwd-group>
</article-meta>
</front>
<body>
<sec id="summary">
  <title>Summary</title>
  <p>Economics traditionally relied on tractable mathematical models,
  diagrams, and simple regression methods to analyze and understand
  economic phenomena. However, in recent decades, economists have
  increasingly shifted towards more computationally challenging
  problems, involving large numbers of heterogeneous agents and complex
  nonlinear interactions.</p>
  <p><ext-link ext-link-type="uri" xlink:href="https://github.com/quantecon/QuantEcon.py">QuantEcon.py</ext-link>
  is an open-source Python library that helps to support this shift
  towards more computational intensive research in the field of
  economics. First released in 2014,
  <ext-link ext-link-type="uri" xlink:href="https://github.com/quantecon/QuantEcon.py">QuantEcon.py</ext-link>
  has been under continuous development for around 9 years. The library
  includes a wide range of functions for economic analysis, including
  numerical methods, data visualization, estimation, and dynamic
  programming, implementing a number of fundamental algorithms used in
  high performance computational economics. In this article we review
  the key features of the library.</p>
</sec>
<sec id="statement-of-need">
  <title>Statement of Need</title>
  <p>Economists use a variety of economic, statistical and mathematical
  models as building blocks for constructing larger and more
  fully-featured models. Some of these are relatively unique to
  economics and finance. For example, many macroeconomic and financial
  models include a stochastic volatility component, since asset markets
  often exhibit bursts of volatility. Other building blocks involve
  optimization routines, such as firms that maximize present value given
  estimated time paths for profits and interest rates. Firms modeled in
  this way are then plugged into larger models that contain households,
  banks and other economic agents.</p>
  <p><ext-link ext-link-type="uri" xlink:href="https://github.com/quantecon/QuantEcon.py">QuantEcon.py</ext-link>
  focuses on supplying building blocks for constructing economic models
  that are fast, efficient and simple to modify. This encourages code
  re-use across the economics community, without enforcing particular
  model structure through a top-down development process.</p>
</sec>
<sec id="implementation-choices">
  <title>Implementation Choices</title>
  <p>In terms of software systems and architecture,
  <ext-link ext-link-type="uri" xlink:href="https://github.com/quantecon/QuantEcon.py">QuantEcon.py</ext-link>
  is built on top of standard libraries such as
  <ext-link ext-link-type="uri" xlink:href="https://numpy.org">NumPy</ext-link>
  (<xref alt="Harris et al., 2020" rid="ref-2020NumPy-Array" ref-type="bibr">Harris
  et al., 2020</xref>) and
  <ext-link ext-link-type="uri" xlink:href="https://scipy.org">SciPy</ext-link>
  (<xref alt="Virtanen et al., 2020" rid="ref-virtanen2020scipy" ref-type="bibr">Virtanen
  et al., 2020</xref>), while also heavily leveraging
  <ext-link ext-link-type="uri" xlink:href="https://numba.pydata.org">Numba</ext-link>
  (<xref alt="Lam et al., 2015" rid="ref-lam2015numba" ref-type="bibr">Lam
  et al., 2015</xref>) for just-in-time (JIT) code acceleration,
  combined with automatic parallelization and caching when possible.
  (<ext-link ext-link-type="uri" xlink:href="https://numba.pydata.org">Numba</ext-link>
  is a just-in-time (JIT) compiler for Python first developed by
  Continuum Analytics that can generate optimized LLVM machine code at
  run-time.) JIT-based acceleration is essential to QuantEcon’s strategy
  of providing code for computational economics that is performant,
  portable and easy to modify.</p>
  <p>For installation and maintenance ease, QuantEcon maintainers
  restrict contributions to depend on libraries available in
  <ext-link ext-link-type="uri" xlink:href="https://www.anaconda.com/">Anaconda</ext-link>.</p>
  <p>The documentation is available on
  <ext-link ext-link-type="uri" xlink:href="https://quanteconpy.readthedocs.io/en/latest/">readthedocs</ext-link>.</p>
</sec>
<sec id="status">
  <title>Status</title>
  <p><ext-link ext-link-type="uri" xlink:href="https://github.com/quantecon/QuantEcon.py">QuantEcon.py</ext-link>
  is released under the open-source MIT License and is partly maintained
  and supported by QuantEcon, a NumFOCUS fiscally sponsored project
  dedicated to development and documentation of modern open source
  computational tools for economics, econometrics, and decision
  making.</p>
  <p><ext-link ext-link-type="uri" xlink:href="https://github.com/quantecon/QuantEcon.py">QuantEcon.py</ext-link>
  is available through the
  <ext-link ext-link-type="uri" xlink:href="https://pypi.org/project/quantecon/">Python
  Package Index</ext-link>:</p>
  <code language="bash">pip install quantecon</code>
  <p>or through <monospace>conda</monospace>:</p>
  <code language="bash">conda install -c conda-forge quantecon</code>
</sec>
<sec id="capabilities">
  <title>Capabilities</title>
  <p>This section gives a basic introduction of
  <monospace>quantecon</monospace> and its usage. The
  <monospace>quantecon</monospace> python library consists of the
  following top level modules:</p>
  <list list-type="bullet">
    <list-item>
      <p>Game Theory (<monospace>game_theory</monospace>)</p>
    </list-item>
    <list-item>
      <p>Markov Chains (<monospace>markov</monospace>)</p>
    </list-item>
    <list-item>
      <p>Optimization algorithms (<monospace>optimize</monospace>)</p>
    </list-item>
    <list-item>
      <p>Random generation utilities (<monospace>random</monospace>)</p>
    </list-item>
  </list>
  <p>The library also has some other submodules containing utility
  functions and miscellaneous tools such as implementations of Kalman
  filters, tools for directed graphs, algorithm for solving linear
  quadratic control, etc.</p>
  <sec id="game-theory">
    <title>Game Theory</title>
    <p>The <monospace>game_theory</monospace> submodule provides
    efficient implementation of state-of-the-art algorithms for
    computing Nash equilibria of normal form games.</p>
    <p>The following snippet computes all mixed Nash equilibria of a
    2-player (non-degenerate) normal form game by support enumeration
    and vertex enumeration:</p>
    <code language="python">&gt;&gt;&gt; import quantecon as qe
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pprint</code>
    <code language="python">&gt;&gt;&gt; bimatrix = [[(3, 3), (3, 2)],
...             [(2, 2), (5, 6)],
...             [(0, 3), (6, 1)]]
&gt;&gt;&gt; g = qe.game_theory.NormalFormGame(bimatrix)
&gt;&gt;&gt; print(g)
2-player NormalFormGame with payoff profile array:
[[[3, 3],  [3, 2]],
 [[2, 2],  [5, 6]],
 [[0, 3],  [6, 1]]]
&gt;&gt;&gt; NEs = qe.game_theory.support_enumeration(g)
&gt;&gt;&gt; pprint.pprint(NEs)
[(array([1., 0., 0.]), array([1., 0.])),
 (array([0.8, 0.2, 0. ]), array([0.66666667, 0.33333333])),
 (array([0.        , 0.33333333, 0.66666667]), array([0.33333333, 0.66666667]))]
&gt;&gt;&gt; NEs = qe.game_theory.vertex_enumeration(g)
&gt;&gt;&gt; pprint.pprint(NEs)
[(array([1., 0., 0.]), array([1., 0.])),
 (array([0.        , 0.33333333, 0.66666667]), array([0.33333333, 0.66666667])),
 (array([0.8, 0.2, 0. ]), array([0.66666667, 0.33333333]))]</code>
    <p>The Lemke-Howson algorithm
    (<xref alt="Codenotti et al., 2008" rid="ref-codenotti2008" ref-type="bibr">Codenotti
    et al., 2008</xref>;
    <xref alt="Lemke &amp; Howson, 1964" rid="ref-lemke1964equilibrium" ref-type="bibr">Lemke
    &amp; Howson, 1964</xref>) is also implemented, which computes one
    Nash equilibrium of a 2-player normal form game:</p>
    <code language="python">&gt;&gt;&gt; qe.game_theory.lemke_howson(g)
(array([1., 0., 0.]), array([1., 0.]))
&gt;&gt;&gt; qe.game_theory.lemke_howson(g, init_pivot=1)
(array([0.        , 0.33333333, 0.66666667]), array([0.33333333, 0.66666667]))</code>
    <p>This routine <monospace>lemke_howson</monospace> scales up to
    games with several hundreds actions.</p>
    <p>For N-player games, the McLennan-Tourky algorithm
    (<xref alt="McLennan &amp; Tourky, 2005" rid="ref-mclennan2005imitation" ref-type="bibr">McLennan
    &amp; Tourky, 2005</xref>) computes one (approximate) Nash
    equilibrium:</p>
    <code language="python">&gt;&gt;&gt; payoff_profiles = [(3, 0, 2),
...                    (1, 0, 0),
...                    (0, 2, 0),
...                    (0, 1, 0),
...                    (0, 1, 0),
...                    (0, 3, 0),
...                    (1, 0, 0),
...                    (2, 0, 3)]
&gt;&gt;&gt; g = qe.game_theory.NormalFormGame(np.reshape(payoff_profiles, (2, 2, 2, 3)))
&gt;&gt;&gt; print(g)
3-player NormalFormGame with payoff profile array:
[[[[3, 0, 2],   [1, 0, 0]],
  [[0, 2, 0],   [0, 1, 0]]],

 [[[0, 1, 0],   [0, 3, 0]],
  [[1, 0, 0],   [2, 0, 3]]]]
&gt;&gt;&gt; mct = qe.game_theory.mclennan_tourky(g)
&gt;&gt;&gt; pprint.pprint(mct)
(array([0.61866018, 0.38133982]),
 array([0.4797706, 0.5202294]),
 array([0.37987835, 0.62012165]))</code>
    <p>The <monospace>game_theory</monospace> submodule also contains
    implementation of several learning/evolutionary dynamics algorithms,
    such as fictitious play (and its stochastic version), best response
    dynamics (and its stochastic version), local interaction dynamics,
    and logit response dynamics.</p>
  </sec>
  <sec id="markov-chains">
    <title>Markov Chains</title>
    <p>The <monospace>markov</monospace> module deals with computation
    related to Markov chains.</p>
    <p>This module contains a class <monospace>MarkovChain</monospace>
    which represents finite-state discrete-time Markov chains.</p>
    <code language="python">&gt;&gt;&gt; P = [[0, 1, 0, 0, 0],
...      [0, 0, 1, 0, 0],
...      [0, 0, 0, 1, 0],
...      [2/3, 0, 0, 0, 1/3],
...      [0, 0, 0, 1, 0]]
&gt;&gt;&gt; mc = qe.markov.MarkovChain(P)</code>
    <p>The <monospace>MarkovChain</monospace> object provides access to
    useful information such as:</p>
    <list list-type="bullet">
      <list-item>
        <p>Whether it is irreducible:</p>
        <p specific-use="wrapper">
          <code language="python">&gt;&gt;&gt; mc.is_irreducible
True</code>
        </p>
      </list-item>
      <list-item>
        <p>Its stationary distribution(s):</p>
        <p specific-use="wrapper">
          <code language="python">&gt;&gt;&gt; mc.stationary_distributions
array([[0.2, 0.2, 0.2, 0.3, 0.1]])</code>
        </p>
      </list-item>
      <list-item>
        <p>Whether it is (a)periodic:</p>
        <p specific-use="wrapper">
          <code language="python">&gt;&gt;&gt; mc.is_aperiodic
False</code>
        </p>
      </list-item>
      <list-item>
        <p>Its period and cyclic classes:</p>
        <p specific-use="wrapper">
          <code language="python">&gt;&gt;&gt; mc.period
2
&gt;&gt;&gt; mc.cyclic_classes
[array([0, 2, 4]), array([1, 3])]</code>
        </p>
      </list-item>
      <list-item>
        <p>Simulation of time series of station transitions:</p>
        <p specific-use="wrapper">
          <code language="python">&gt;&gt;&gt; mc.simulate(10)
array([0, 1, 2, 3, 0, 1, 2, 3, 4, 3])</code>
        </p>
      </list-item>
    </list>
    <p>The <monospace>MarkovChain</monospace> object is also capable of
    determining communication classes and recurrent classes (relavant
    for reducible Markov chains).</p>
    <p>It is also possible to construct a
    <monospace>MarkovChain</monospace> object as an approximation of a
    linear Gaussian AR(1) process,</p>
    <p><disp-formula><alternatives>
    <tex-math><![CDATA[
      y_t = \mu + \rho y_{t-1} + \epsilon_t,
    ]]></tex-math>
    <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>y</mml:mi><mml:mi>t</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>μ</mml:mi><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub><mml:mi>y</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>ϵ</mml:mi><mml:mi>t</mml:mi></mml:msub><mml:mo>,</mml:mo></mml:mrow></mml:math></alternatives></disp-formula></p>
    <p>by Tauchen’s method (<monospace>tauchen</monospace>)
    (<xref alt="Tauchen, 1986" rid="ref-tauchen_finite_1986" ref-type="bibr">Tauchen,
    1986</xref>) or Rouwenhorst’s method
    (<monospace>rouwenhorst</monospace>)
    (<xref alt="Rouwenhorst, 1995" rid="ref-rouwenhorst_method_1995" ref-type="bibr">Rouwenhorst,
    1995</xref>):</p>
    <code language="python">&gt;&gt;&gt; tauchen_mc = qe.markov.tauchen(n=4, rho=0.5, sigma=0.5, mu=0., n_std=3)
&gt;&gt;&gt; tauchen_mc.state_values
array([-1.73205081, -0.57735027,  0.57735027,  1.73205081])</code>
    <code language="python">&gt;&gt;&gt; rhorst_mc = qe.markov.rouwenhorst(n=4, rho=0.5, sigma=0.5, mu=0.)
&gt;&gt;&gt; rhorst_mc.state_values
array([-1.        , -0.33333333,  0.33333333,  1.        ])</code>
    <p>The <monospace>markov</monospace> module can also be used for
    representing and solving discrete dynamic programs (also known as
    Markov decision processes) with finite states and actions:</p>
    <code language="python">&gt;&gt;&gt; R = [[5, 10],
...      [-1, -float('inf')]]  # Rewards
&gt;&gt;&gt; Q = [[(0.5, 0.5), (0, 1)],
...      [(0, 1), (0.5, 0.5)]]  # Transition probabilities
&gt;&gt;&gt; beta = 0.95  # Discount factor
&gt;&gt;&gt; ddp = qe.markov.DiscreteDP(R, Q, beta)</code>
    <p>The <monospace>DiscreteDP</monospace> class currently implements
    the following solution algorithms:</p>
    <list list-type="bullet">
      <list-item>
        <p>value iteration;</p>
      </list-item>
      <list-item>
        <p>policy iteration;</p>
      </list-item>
      <list-item>
        <p>modified policy iteration;</p>
      </list-item>
      <list-item>
        <p>linear programming.</p>
      </list-item>
    </list>
    <p>To solve the model:</p>
    <list list-type="bullet">
      <list-item>
        <p>By the <italic>value iteration</italic> method:</p>
        <p specific-use="wrapper">
          <code language="python">&gt;&gt;&gt; res = ddp.solve(method='value_iteration', v_init=[0, 0], epsilon=0.01)
&gt;&gt;&gt; res.sigma  # (Approximate) optimal policy function
array([0, 0])
&gt;&gt;&gt; res.v  # (Approximate) optimal value function
array([ -8.5665053 , -19.99507673])</code>
        </p>
      </list-item>
      <list-item>
        <p>By the <italic>policy iteration</italic> method:</p>
        <p specific-use="wrapper">
          <code language="python">&gt;&gt;&gt; res = ddp.solve(method='policy_iteration', v_init=[0, 0])
&gt;&gt;&gt; res.sigma  # Optimal policy function
array([0, 0])
&gt;&gt;&gt; res.v  # Optimal value function
array([ -8.57142857, -20.        ])</code>
        </p>
      </list-item>
    </list>
    <p>Similary, we can also solve the model using <italic>modified
    policy iteration</italic> and <italic>linear programming</italic> by
    changing the <monospace>method</monospace> option in
    <monospace>ddp.solve</monospace>.</p>
  </sec>
  <sec id="optimization">
    <title>Optimization</title>
    <p>The <monospace>optimize</monospace> module provides various
    routines for solving optimization problems and root finding.</p>
    <p>Although some methods such as <monospace>bisect</monospace> and
    <monospace>brentq</monospace> have been implemented in popular
    libraries such as SciPy, the major benefit of the
    <monospace>quantecon</monospace> implementation relative to other
    implementations is JIT-acceleration and hence they can be embedded
    in user-defined functions that target the Numba JIT compiler.</p>
    <sec id="linear-programming">
      <title>Linear Programming</title>
      <p>This module contains a linear programming solver based on the
      simplex method, <monospace>linprog_simplex</monospace>, which
      solves a linear program of the following form:</p>
      <p><disp-formula><alternatives>
      <tex-math><![CDATA[
      \begin{aligned}
      \max_{x} \ & c^T x \\
      \text{subject to } \ & A_{\mathrm{ub}} x \leq b_{\mathrm{ub}}, \\
      & A_{\mathrm{eq}} x = b_{\mathrm{eq}}, \\
      & x \geq 0. \\
      \end{aligned}
      ]]></tex-math>
      <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mtable><mml:mtr><mml:mtd columnalign="right" style="text-align: right"><mml:munder><mml:mo>max</mml:mo><mml:mi>x</mml:mi></mml:munder><mml:mspace width="0.222em"></mml:mspace></mml:mtd><mml:mtd columnalign="left" style="text-align: left"><mml:msup><mml:mi>c</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mi>x</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right" style="text-align: right"><mml:mrow><mml:mtext mathvariant="normal">subject to </mml:mtext><mml:mspace width="0.333em"></mml:mspace></mml:mrow><mml:mspace width="0.222em"></mml:mspace></mml:mtd><mml:mtd columnalign="left" style="text-align: left"><mml:msub><mml:mi>A</mml:mi><mml:mrow><mml:mi mathvariant="normal">u</mml:mi><mml:mi mathvariant="normal">b</mml:mi></mml:mrow></mml:msub><mml:mi>x</mml:mi><mml:mo>≤</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mrow><mml:mi mathvariant="normal">u</mml:mi><mml:mi mathvariant="normal">b</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right" style="text-align: right"></mml:mtd><mml:mtd columnalign="left" style="text-align: left"><mml:msub><mml:mi>A</mml:mi><mml:mrow><mml:mi mathvariant="normal">e</mml:mi><mml:mi mathvariant="normal">q</mml:mi></mml:mrow></mml:msub><mml:mi>x</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mrow><mml:mi mathvariant="normal">e</mml:mi><mml:mi mathvariant="normal">q</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right" style="text-align: right"></mml:mtd><mml:mtd columnalign="left" style="text-align: left"><mml:mi>x</mml:mi><mml:mo>≥</mml:mo><mml:mn>0</mml:mn><mml:mi>.</mml:mi></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p>
      <p>The following is a simple example solved by
      <monospace>linprog_simplex</monospace>:</p>
      <code language="python">&gt;&gt;&gt; c = [4, 3]
&gt;&gt;&gt; A_ub = [[1, 1],
...         [1, 2],
...         [2, 1]]
&gt;&gt;&gt; b_ub = [10, 16, 16]
&gt;&gt;&gt; c, A_ub, b_ub = map(np.asarray, [c, A_ub, b_ub])
&gt;&gt;&gt; res = qe.optimize.linprog_simplex(c, A_ub=A_ub, b_ub=b_ub)
&gt;&gt;&gt; res.x, res.fun, res.success
(array([6., 4.]), 36.0, True)
&gt;&gt;&gt; res.lambd  # Dual solution
array([2., 0., 1.])</code>
    </sec>
    <sec id="scalar-maximization">
      <title>Scalar Maximization</title>
      <p>The <monospace>optimize</monospace> module implements the
      Nelder-Mead algorithm
      (<xref alt="Gao &amp; Han, 2012" rid="ref-gao2012implementing" ref-type="bibr">Gao
      &amp; Han, 2012</xref>;
      <xref alt="Lagarias et al., 1998" rid="ref-lagarias1998convergence" ref-type="bibr">Lagarias
      et al., 1998</xref>;
      <xref alt="Singer &amp; Singer, 2004" rid="ref-singer2004efficient" ref-type="bibr">Singer
      &amp; Singer, 2004</xref>) for maximizing a scalar-valued function
      with one or more variables.</p>
      <code language="python">&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; @njit
... def rosenbrock(x):
...     return -(100 * (x[1] - x[0] ** 2) ** 2 + (1 - x[0])**2)
...
&gt;&gt;&gt; x0 = np.array([-2, 1])
&gt;&gt;&gt; res = qe.optimize.nelder_mead(rosenbrock, x0)
&gt;&gt;&gt; res.x, res.fun, res.success
(array([0.99999814, 0.99999756]), -1.6936258239463265e-10, True)</code>
      <p>There is also the scalar maximization function
      <monospace>brentq_max</monospace> which maximizes a function
      within a given bounded interval and returns a maximizer, the
      maximum value attained, and some additional information related to
      convergence and the number of iterations.</p>
      <code language="python">&gt;&gt;&gt; @njit
... def f(x):
...     return -(x + 2.0)**2 + 1.0
...
&gt;&gt;&gt; qe.optimize.brent_max(f, -3, 2)  # x, max_value_of_f, extra_info
(-2.0, 1.0, (0, 6))</code>
    </sec>
    <sec id="root-finding">
      <title>Root Finding</title>
      <p>This module also includes routines that find a root of a given
      function. Presently, <monospace>quantecon</monospace> has the
      following implementations:</p>
      <list list-type="bullet">
        <list-item>
          <p><monospace>bisect</monospace></p>
        </list-item>
        <list-item>
          <p><monospace>brentq</monospace></p>
        </list-item>
        <list-item>
          <p><monospace>newton</monospace></p>
        </list-item>
        <list-item>
          <p><monospace>newton_halley</monospace></p>
        </list-item>
        <list-item>
          <p><monospace>newton_secant</monospace></p>
        </list-item>
      </list>
      <p>The following snippet uses <monospace>brentq</monospace> to
      find the root of the function <inline-formula><alternatives>
      <tex-math><![CDATA[f]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>f</mml:mi></mml:math></alternatives></inline-formula>
      in the interval <inline-formula><alternatives>
      <tex-math><![CDATA[(-1, 2)]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>.</p>
      <code language="python">&gt;&gt;&gt; @njit
... def f(x):
...     return np.sin(4 * (x - 1/4)) + x + x**20 - 1
...
&gt;&gt;&gt; qe.optimize.brentq(f, -1, 2)
results(root=0.40829350427935973, function_calls=12, iterations=11, converged=True)</code>
    </sec>
  </sec>
  <sec id="miscellaneous-tools">
    <title>Miscellaneous Tools</title>
    <p>The library also contains some other tools that help in solving
    problems such as linear quadratic optimal control and discrete
    Lyapunov equations, analyzing dynamic linear economies, etc. A brief
    overview of some of these routines is given below:</p>
    <sec id="matrix-equations">
      <title>Matrix Equations</title>
      <p>The function <monospace>solve_discrete_lyapunov</monospace>
      computes the solution of the discrete Lyapunov equation given
      by:</p>
      <p><disp-formula><alternatives>
      <tex-math><![CDATA[
      AXA' - X + B = 0.
      ]]></tex-math>
      <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>A</mml:mi><mml:mi>X</mml:mi><mml:mi>A</mml:mi><mml:mi>′</mml:mi><mml:mo>−</mml:mo><mml:mi>X</mml:mi><mml:mo>+</mml:mo><mml:mi>B</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mi>.</mml:mi></mml:mrow></mml:math></alternatives></disp-formula></p>
      <code language="python">&gt;&gt;&gt; A = np.full((2, 2), .5)
&gt;&gt;&gt; B = np.array([[.5, -.5], [-.5, .5]])
&gt;&gt;&gt; qe.solve_discrete_lyapunov(A, B)
array([[ 0.5, -0.5],
       [-0.5,  0.5]])</code>
      <p>Similarly, the function
      <monospace>solve_discrete_riccati</monospace> computes the
      solution of the discrete-time algebraic Riccati equation
      (<xref alt="Chiang et al., 2010" rid="ref-chiang2010structured" ref-type="bibr">Chiang
      et al., 2010</xref>):</p>
      <p><disp-formula><alternatives>
      <tex-math><![CDATA[
      X = A'XA - (N + B'XA)'(B'XB + R)^{-1}(N + B'XA) + Q.
      ]]></tex-math>
      <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>X</mml:mi><mml:mo>=</mml:mo><mml:mi>A</mml:mi><mml:mi>′</mml:mi><mml:mi>X</mml:mi><mml:mi>A</mml:mi><mml:mo>−</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>N</mml:mi><mml:mo>+</mml:mo><mml:mi>B</mml:mi><mml:mi>′</mml:mi><mml:mi>X</mml:mi><mml:mi>A</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mi>′</mml:mi><mml:msup><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>B</mml:mi><mml:mi>′</mml:mi><mml:mi>X</mml:mi><mml:mi>B</mml:mi><mml:mo>+</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>N</mml:mi><mml:mo>+</mml:mo><mml:mi>B</mml:mi><mml:mi>′</mml:mi><mml:mi>X</mml:mi><mml:mi>A</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>Q</mml:mi><mml:mi>.</mml:mi></mml:mrow></mml:math></alternatives></disp-formula></p>
    </sec>
    <sec id="lq-control">
      <title>LQ Control</title>
      <p>The library has a class <monospace>LQ</monospace> for analyzing
      linear quadratic optimal control problems of either the infinite
      horizon form or the finite horizon form:</p>
      <code language="python">&gt;&gt;&gt; Q = np.array([[0., 0.], [0., 1]])
&gt;&gt;&gt; R = np.array([[1., 0.], [0., 0]])
&gt;&gt;&gt; RF = np.diag(np.full(2, 100))
&gt;&gt;&gt; A = np.full((2, 2), .95)
&gt;&gt;&gt; B = np.full((2, 2), -1.)
&gt;&gt;&gt; beta = .95
&gt;&gt;&gt; T = 1
&gt;&gt;&gt; lq_mat = qe.LQ(Q, R, A, B, beta=beta, T=T, Rf=RF)
&gt;&gt;&gt; lq_mat
Linear Quadratic control system
  - beta (discount parameter)       : 0.95
  - T (time horizon)                : 1
  - n (number of state variables)   : 2
  - k (number of control variables) : 2
  - j (number of shocks)            : 1</code>
    </sec>
    <sec id="graph-tools">
      <title>Graph Tools</title>
      <p>The library contains a class <monospace>DiGraph</monospace> to
      represent directed graphs and provide information about the graph
      structure such as strong connectivity, periodicity, etc.</p>
      <code language="python">&gt;&gt;&gt; adj_matrix = [[0, 1, 0, 0, 0],
...               [0, 0, 1, 0, 0],
...               [0, 0, 0, 1, 0],
...               [1, 0, 0, 0, 1],
...               [0, 0, 0, 1, 0]]
&gt;&gt;&gt; node_labels = ['a', 'b', 'c', 'd', 'e']
&gt;&gt;&gt; g = qe.DiGraph(adj_matrix, node_labels=node_labels)
&gt;&gt;&gt; g
Directed Graph:
  - n(number of nodes): 5</code>
      <list list-type="bullet">
        <list-item>
          <p>Check if the graph is strongly connected:</p>
          <p specific-use="wrapper">
            <code language="python">&gt;&gt;&gt; g.is_strongly_connected
True</code>
          </p>
        </list-item>
        <list-item>
          <p>Inspect the periodicity of the graph:</p>
          <p specific-use="wrapper">
            <code language="python">&gt;&gt;&gt; g.is_aperiodic
False
&gt;&gt;&gt; g.period
2
&gt;&gt;&gt; g.cyclic_components
[array(['a', 'c', 'e'], dtype='&lt;U1'), array(['b', 'd'], dtype='&lt;U1')]</code>
          </p>
        </list-item>
      </list>
    </sec>
  </sec>
</sec>
<sec id="future-work">
  <title>Future Work</title>
  <p>QuantEcon developers are considering future projects such as adding
  more equilibrium computation algorithms for N-player games and
  supporting extensive form games. In addition, QuantEcon aims to extend
  its current implementation to other backend libraries like JAX or
  other GPU providing libraries to utilize modern computing systems and
  provide faster execution speeds.</p>
</sec>
</body>
<back>
<ref-list>
  <ref id="ref-chiang2010structured">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Chiang</surname><given-names>Chun-Yueh</given-names></name>
        <name><surname>Fan</surname><given-names>Hung-Yuan</given-names></name>
        <name><surname>Lin</surname><given-names>Wen-Wei</given-names></name>
      </person-group>
      <article-title>Structured Doubling Algorithm for Discrete-Time Algebraic Riccati Equations with Singular Control Weighting Matrices</article-title>
      <source>Taiwanese Journal of Mathematics</source>
      <publisher-name>Mathematical Society of the Republic of China</publisher-name>
      <year iso-8601-date="2010">2010</year>
      <volume>14</volume>
      <issue>3A</issue>
      <pub-id pub-id-type="doi">10.11650/twjm/1500405875</pub-id>
      <fpage>933</fpage>
      <lpage>954</lpage>
    </element-citation>
  </ref>
  <ref id="ref-mclennan2005imitation">
    <element-citation publication-type="report">
      <person-group person-group-type="author">
        <name><surname>McLennan</surname><given-names>Andrew</given-names></name>
        <name><surname>Tourky</surname><given-names>Rabee</given-names></name>
      </person-group>
      <article-title>From Imitation Games to Kakutani</article-title>
      <publisher-name>University of Pennsylvania</publisher-name>
      <year iso-8601-date="2005">2005</year>
    </element-citation>
  </ref>
  <ref id="ref-lagarias1998convergence">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Lagarias</surname><given-names>Jeffrey C</given-names></name>
        <name><surname>Reeds</surname><given-names>James A</given-names></name>
        <name><surname>Wright</surname><given-names>Margaret H</given-names></name>
        <name><surname>Wright</surname><given-names>Paul E</given-names></name>
      </person-group>
      <article-title>Convergence Properties of the Nelder–Mead Simplex Method in Low Dimensions</article-title>
      <source>SIAM Journal on optimization</source>
      <publisher-name>SIAM</publisher-name>
      <year iso-8601-date="1998">1998</year>
      <volume>9</volume>
      <issue>1</issue>
      <fpage>112</fpage>
      <lpage>147</lpage>
    </element-citation>
  </ref>
  <ref id="ref-singer2004efficient">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Singer</surname><given-names>Saša</given-names></name>
        <name><surname>Singer</surname><given-names>Sanja</given-names></name>
      </person-group>
      <article-title>Efficient Implementation of the Nelder–Mead Search Algorithm</article-title>
      <source>Applied Numerical Analysis &amp; Computational Mathematics</source>
      <publisher-name>Wiley Online Library</publisher-name>
      <year iso-8601-date="2004">2004</year>
      <volume>1</volume>
      <issue>2</issue>
      <pub-id pub-id-type="doi">10.1002/anac.200410015</pub-id>
      <fpage>524</fpage>
      <lpage>534</lpage>
    </element-citation>
  </ref>
  <ref id="ref-gao2012implementing">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Gao</surname><given-names>Fuchang</given-names></name>
        <name><surname>Han</surname><given-names>Lixing</given-names></name>
      </person-group>
      <article-title>Implementing the Nelder-Mead Simplex Algorithm with Adaptive Parameters</article-title>
      <source>Computational Optimization and Applications</source>
      <publisher-name>Springer</publisher-name>
      <year iso-8601-date="2012">2012</year>
      <volume>51</volume>
      <issue>1</issue>
      <pub-id pub-id-type="doi">10.1007/s10589-010-9329-3</pub-id>
      <fpage>259</fpage>
      <lpage>277</lpage>
    </element-citation>
  </ref>
  <ref id="ref-codenotti2008">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Codenotti</surname><given-names>Bruno</given-names></name>
        <name><surname>De Rossi</surname><given-names>Stefano</given-names></name>
        <name><surname>Pagan</surname><given-names>Marino</given-names></name>
      </person-group>
      <article-title>An Experimental Analysis of Lemke-Howson Algorithm</article-title>
      <source>arXiv preprint arXiv:0811.3247</source>
      <year iso-8601-date="2008">2008</year>
    </element-citation>
  </ref>
  <ref id="ref-lemke1964equilibrium">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Lemke</surname><given-names>Carlton E</given-names></name>
        <name><surname>Howson</surname><given-names>Joseph T</given-names><suffix>Jr</suffix></name>
      </person-group>
      <article-title>Equilibrium Points of Bimatrix Games</article-title>
      <source>Journal of the Society for industrial and Applied Mathematics</source>
      <publisher-name>SIAM</publisher-name>
      <year iso-8601-date="1964">1964</year>
      <volume>12</volume>
      <issue>2</issue>
      <fpage>413</fpage>
      <lpage>423</lpage>
    </element-citation>
  </ref>
  <ref id="ref-lam2015numba">
    <element-citation publication-type="paper-conference">
      <person-group person-group-type="author">
        <name><surname>Lam</surname><given-names>Siu Kwan</given-names></name>
        <name><surname>Pitrou</surname><given-names>Antoine</given-names></name>
        <name><surname>Seibert</surname><given-names>Stanley</given-names></name>
      </person-group>
      <article-title>Numba: A LLVM-based Python JIT Compiler</article-title>
      <source>Proceedings of the second workshop on the LLVM compiler infrastructure in HPC</source>
      <year iso-8601-date="2015">2015</year>
      <fpage>1</fpage>
      <lpage>6</lpage>
    </element-citation>
  </ref>
  <ref id="ref-virtanen2020scipy">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Virtanen</surname><given-names>Pauli</given-names></name>
        <name><surname>Gommers</surname><given-names>Ralf</given-names></name>
        <name><surname>Oliphant</surname><given-names>Travis E</given-names></name>
        <name><surname>Haberland</surname><given-names>Matt</given-names></name>
        <name><surname>Reddy</surname><given-names>Tyler</given-names></name>
        <name><surname>Cournapeau</surname><given-names>David</given-names></name>
        <name><surname>Burovski</surname><given-names>Evgeni</given-names></name>
        <name><surname>Peterson</surname><given-names>Pearu</given-names></name>
        <name><surname>Weckesser</surname><given-names>Warren</given-names></name>
        <name><surname>Bright</surname><given-names>Jonathan</given-names></name>
        <name><surname>others</surname></name>
      </person-group>
      <article-title>SciPy 1.0: Fundamental Algorithms for Scientific Computing in Python</article-title>
      <source>Nature methods</source>
      <publisher-name>Nature Publishing Group</publisher-name>
      <year iso-8601-date="2020">2020</year>
      <volume>17</volume>
      <issue>3</issue>
      <fpage>261</fpage>
      <lpage>272</lpage>
    </element-citation>
  </ref>
  <ref id="ref-2020NumPy-Array">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Harris</surname><given-names>Charles R.</given-names></name>
        <name><surname>Millman</surname><given-names>K. Jarrod</given-names></name>
        <name><surname>Walt</surname><given-names>Stéfan J van der</given-names></name>
        <name><surname>Gommers</surname><given-names>Ralf</given-names></name>
        <name><surname>Virtanen</surname><given-names>Pauli</given-names></name>
        <name><surname>Cournapeau</surname><given-names>David</given-names></name>
        <name><surname>Wieser</surname><given-names>Eric</given-names></name>
        <name><surname>Taylor</surname><given-names>Julian</given-names></name>
        <name><surname>Berg</surname><given-names>Sebastian</given-names></name>
        <name><surname>Smith</surname><given-names>Nathaniel J.</given-names></name>
        <name><surname>Kern</surname><given-names>Robert</given-names></name>
        <name><surname>Picus</surname><given-names>Matti</given-names></name>
        <name><surname>Hoyer</surname><given-names>Stephan</given-names></name>
        <name><surname>Kerkwijk</surname><given-names>Marten H. van</given-names></name>
        <name><surname>Brett</surname><given-names>Matthew</given-names></name>
        <name><surname>Haldane</surname><given-names>Allan</given-names></name>
        <name><surname>Fernández del Río</surname><given-names>Jaime</given-names></name>
        <name><surname>Wiebe</surname><given-names>Mark</given-names></name>
        <name><surname>Peterson</surname><given-names>Pearu</given-names></name>
        <name><surname>Gérard-Marchant</surname><given-names>Pierre</given-names></name>
        <name><surname>Sheppard</surname><given-names>Kevin</given-names></name>
        <name><surname>Reddy</surname><given-names>Tyler</given-names></name>
        <name><surname>Weckesser</surname><given-names>Warren</given-names></name>
        <name><surname>Abbasi</surname><given-names>Hameer</given-names></name>
        <name><surname>Gohlke</surname><given-names>Christoph</given-names></name>
        <name><surname>Oliphant</surname><given-names>Travis E.</given-names></name>
      </person-group>
      <article-title>Array Programming with NumPy</article-title>
      <source>Nature</source>
      <year iso-8601-date="2020">2020</year>
      <volume>585</volume>
      <pub-id pub-id-type="doi">10.1038/s41586-020-2649-2</pub-id>
      <fpage>357</fpage>
      <lpage>362</lpage>
    </element-citation>
  </ref>
  <ref id="ref-tauchen_finite_1986">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Tauchen</surname><given-names>George</given-names></name>
      </person-group>
      <article-title>Finite State Markov-Chain Approximations to Univariate and Vector Autoregressions</article-title>
      <source>Economics Letters</source>
      <year iso-8601-date="1986">1986</year>
      <volume>20</volume>
      <issue>2</issue>
      <issn>0165-1765</issn>
      <pub-id pub-id-type="doi">10.1016/0165-1765(86)90168-0</pub-id>
      <fpage>177</fpage>
      <lpage>181</lpage>
    </element-citation>
  </ref>
  <ref id="ref-rouwenhorst_method_1995">
    <element-citation publication-type="chapter">
      <person-group person-group-type="author">
        <name><surname>Rouwenhorst</surname><given-names>K. Geert</given-names></name>
      </person-group>
      <article-title>Asset Pricing Implications of Equilibrium Business Cycle Models</article-title>
      <source>Frontiers of Business Cycle Research</source>
      <publisher-name>Princeton University Press</publisher-name>
      <year iso-8601-date="1995">1995</year>
      <date-in-citation content-type="access-date"><year iso-8601-date="2023-05-19">2023</year><month>05</month><day>19</day></date-in-citation>
      <pub-id pub-id-type="doi">10.2307/j.ctv14163jx.16</pub-id>
      <fpage>294</fpage>
      <lpage>330</lpage>
    </element-citation>
  </ref>
</ref-list>
</back>
</article>
