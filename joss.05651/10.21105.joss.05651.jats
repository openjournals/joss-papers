<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN"
                  "JATS-publishing1.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" dtd-version="1.2" article-type="other">
<front>
<journal-meta>
<journal-id></journal-id>
<journal-title-group>
<journal-title>Journal of Open Source Software</journal-title>
<abbrev-journal-title>JOSS</abbrev-journal-title>
</journal-title-group>
<issn publication-format="electronic">2475-9066</issn>
<publisher>
<publisher-name>Open Journals</publisher-name>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="publisher-id">5651</article-id>
<article-id pub-id-type="doi">10.21105/joss.05651</article-id>
<title-group>
<article-title>mpl-interactions: A Python Package for Interactive
Matplotlib Figures</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author">
<contrib-id contrib-id-type="orcid">https://orcid.org/0000-0002-7591-083X</contrib-id>
<name>
<surname>Hunt-Isaak</surname>
<given-names>Ian</given-names>
</name>
<xref ref-type="aff" rid="aff-1"/>
</contrib>
<contrib contrib-type="author">
<contrib-id contrib-id-type="orcid">https://orcid.org/0009-0002-0402-2306</contrib-id>
<name>
<surname>Russell</surname>
<given-names>John</given-names>
</name>
<xref ref-type="aff" rid="aff-2"/>
</contrib>
<contrib contrib-type="author">
<contrib-id contrib-id-type="orcid">https://orcid.org/0000-0003-2332-9223</contrib-id>
<name>
<surname>Hekstra</surname>
<given-names>Doeke</given-names>
</name>
<xref ref-type="aff" rid="aff-1"/>
<xref ref-type="aff" rid="aff-2"/>
</contrib>
<aff id="aff-1">
<institution-wrap>
<institution>John A. Paulson School of Engineering and Applied Sciences,
Harvard University, Cambridge, MA, USA</institution>
</institution-wrap>
</aff>
<aff id="aff-2">
<institution-wrap>
<institution>Department of Molecular and Cellular Biology, Harvard
University, Cambridge, MA, USA</institution>
</institution-wrap>
</aff>
</contrib-group>
<volume>9</volume>
<issue>93</issue>
<fpage>5651</fpage>
<permissions>
<copyright-statement>Authors of papers retain copyright and release the
work under a Creative Commons Attribution 4.0 International License (CC
BY 4.0)</copyright-statement>
<copyright-year>2022</copyright-year>
<copyright-holder>The article authors</copyright-holder>
<license license-type="open-access" xlink:href="https://creativecommons.org/licenses/by/4.0/">
<license-p>Authors of papers retain copyright and release the work under
a Creative Commons Attribution 4.0 International License (CC BY
4.0)</license-p>
</license>
</permissions>
<kwd-group kwd-group-type="author">
<kwd>Python</kwd>
<kwd>Matplotlib</kwd>
<kwd>Ipywidgets</kwd>
<kwd>Interactive</kwd>
<kwd>Visualization</kwd>
</kwd-group>
</article-meta>
</front>
<body>
<sec id="summary">
  <title>Summary</title>
  <p>Data exploration, model building and pedagogy all benefit from the
  ability to interactively update elements in Matplotlib
  (<xref alt="Hunter, 2007" rid="ref-HunterU003A2007" ref-type="bibr">Hunter,
  2007</xref>) figures. <monospace>mpl-interactions</monospace> enables
  this by making it easy for users to create Matplotlib figures in which
  the displayed data can be dynamically controlled through widgets.
  These widgets can be automatically generated by passing arguments such
  as arrays or shorthands (such as a tuple of numbers to generate a
  slider) to modified pyplot functions. After creation of these widgets,
  <monospace>mpl-interactions</monospace> updates plot elements without
  further user intervention. For ease of use, it adds these features
  while otherwise staying close to the
  <monospace>matplotlib.pyplot</monospace> interface.
  <monospace>mpl-interactions</monospace> is built such that parameters
  controlled by the generated widgets are easy to re-use for multiple
  plot elements, while not interfering with static elements. This design
  allows for building any figure that <monospace>Matplotlib</monospace>
  can produce, while adding interactivity to specific parts as
  desired.</p>
  <p>Complete tutorials, examples, and API documentation are available
  on https://mpl-interactions.readthedocs.io/en/stable/.</p>
</sec>
<sec id="statement-of-need">
  <title>Statement of Need</title>
  <p>The ability to interact dynamically with plots through widgets such
  as sliders can be a powerful tool in the scientific process and in
  pedagogy. For instance, varying a parameter of a mathematical model
  plotted on top of data helps to understand the relationship between
  the model and the data. Similarly, exploratory data analysis can be
  enhanced by interactively modifying aspects of the plot such as which
  points are displayed, or the threshold level of a displayed image.
  <monospace>mpl-interactions</monospace>’ core goal is to make this
  aspect of interactive plotting easier when using Matplotlib. Other
  interactive functionalities are out of scope as they are provided by
  Matplotlib (e.g., zooming and panning), or by other third party
  packages (e.g., point selection).</p>
  <p>Matplotlib provides mechanisms for updating elements (artists) in
  figures. However, the APIs for these artists are not consistent and
  some are under- or undocumented. Furthermore, the creation and
  positioning of the native Matplotlib widgets is nontrivial. While the
  <monospace>ipywidgets</monospace>
  (<xref alt="Community, 2015" rid="ref-interactive_Jupyter_widgetsU003A2015" ref-type="bibr">Community,
  2015</xref>) library makes widget creation and positioning easier, it
  is difficult to integrate with Matplotlib in a performant manner. The
  easiest way to do so is to use the <monospace>ipywidgets</monospace>’
  <monospace>interact()</monospace> function, which automatically
  generates sliders and other widgets to control arguments to arbitrary
  python functions. However, this can result in completely regenerating
  the figure which can be slow. Alternatively, the user needs to
  remember the specifics of how to update each individual artist. While
  <monospace>Matplotlib</monospace> and
  <monospace>ipywidgets</monospace> provide the tools for controlling
  plots with widgets, the overhead of implementing such control can
  overwhelm its utility. <monospace>mpl-interactions</monospace> fills
  this gap by making it easy for users to generate widgets that
  dynamically control plots.</p>
  <p>There are a wide range of data visualization tools for Python, such
  as Altair
  (<xref alt="VanderPlas et al., 2018" rid="ref-VanderPlas2018" ref-type="bibr">VanderPlas
  et al., 2018</xref>), Holoviz
  (<xref alt="Rudiger et al., 2020" rid="ref-philipp_rudiger_2020_3634720" ref-type="bibr">Rudiger
  et al., 2020</xref>), and Plotly
  (<xref alt="Inc., 2015" rid="ref-plotly" ref-type="bibr">Inc.,
  2015</xref>), which provide rich interactive plotting experiences.
  These tools often have overlapping functionality with
  <monospace>mpl-interactions</monospace> and in some cases provide a
  greater range of interactive capabilities. However, they may not be
  useful for a user already invested in using Matplotlib, or for a user
  for whom Matplotlib is otherwise the best solution. For such users
  <monospace>mpl-interactions</monospace> adds functionality to
  <monospace>Matplotlib</monospace>. To this end
  <monospace>mpl-interactions</monospace> closely follows the semantics
  of the Matplotlib API, rather than creating a separate set of
  semantics, like the other mentioned libraries. Thus, it enhances an
  analysis workflow that uses Matplotlib by enabling users to add
  interactive features to a library they are already using. Otherwise
  user would need to use multiple plotting libraries for different
  aspects of the data analysis process.</p>
</sec>
<sec id="overview">
  <title>Overview</title>
  <p><monospace>mpl-interactions</monospace> provides several key
  features to make generating interactive figures simple. The first is
  what arguments are accepted. While <monospace>Matplotlib</monospace>
  requires users to pass arrays as arguments,
  <monospace>mpl-interactions</monospace> allows passing a function that
  returns numeric values. Parameters to these functions are specified by
  adding extra keyword arguments (<monospace>kwargs</monospace>) to the
  plotting function call. Then, <monospace>mpl-interactions</monospace>
  will generate the appropriate widgets for the parameters and run the
  functions to generate the numerical data to plot. For example, to plot
  a sinusoid and control its amplitude and frequency using sliders, a
  function returning the <monospace>y</monospace> values is defined and
  passed as the <monospace>y</monospace> parameter to the
  <monospace>plot</monospace> function. The ranges of the
  <monospace>A</monospace> and <monospace>f</monospace> parameters are
  defined as extra keyword arguments using tuples as a shorthand for
  what widget to generate.</p>
  <code language="python">import mpl_interactions.ipyplot as iplt
import matplotlib.pyplot as plt
import numpy as np

fig, ax = plt.subplots()

def sinusoid(x, A, f):
    return A*np.sin(x * f)

x = np.linspace(0, np.pi, 100)

ctrls = iplt.plot(x, sinusoid, A=(1, 10), f = (.5, 2))
plt.show()</code>
  <fig>
    <caption><p>Multiple states of the figure resulting from moving the
    sliders after running above example in jupyter
    lab.<styled-content id="figU003Asinusoid"></styled-content></p></caption>
    <graphic mimetype="image" mime-subtype="png" xlink:href="media/imgs/sin-composed.png" />
  </fig>
  <p>A second important feature of
  <monospace>mpl-interactions</monospace> is that interactive plot
  components are not isolated from each other. That is, the control
  widgets generated from one plotting call can be re-used to control
  other components. In addition to showing the re-use of control widgets
  this example demonstrates how Matplotlib styling arguments (such as
  <monospace>vmin</monospace>) can be controlled through widgets.</p>
  <code language="python">N = 128
rng = np.random.default_rng(seed=1995)
im = rng.normal(size=(N,N))

fig, axs = plt.subplots(1, 2, figsize=(12, 5))


# create interactive controls
ctrls = iplt.imshow(im, vmin_vmax=(&quot;r&quot;, im.min(), im.max()), ax=axs[0])

# plot histogram of pixel intensities

# by indexing the ctrls object it is possible to
# re-use the the vmin and vmax created by imshow
# to control the position of the axvlines
iplt.axvline(ctrls[&quot;vmin&quot;], ax=axs[1], c=&quot;k&quot;)
iplt.axvline(ctrls[&quot;vmax&quot;], ax=axs[1], c=&quot;k&quot;);
axs[1].hist(im.flatten(), bins=&quot;auto&quot;)
axs[1].set_title(&quot;Histogram of Pixel Intensities&quot;)
axs[1].set_xlabel('Pixel Intensity')</code>
  <fig>
    <caption><p>An imshow where the thresholds of the colorbar are
    controlled by the <monospace>vmin_vmax</monospace> range slider.
    While the slider is created by the <monospace>imshow</monospace>
    call, its interactive parameters can be reused to control the
    position of the veritcal lines on the histogram.</p></caption>
    <graphic mimetype="image" mime-subtype="png" xlink:href="media/imgs/threshold-dark.png" />
  </fig>
  <p>Finally, <monospace>mpl-interactions</monospace> allows the reuse
  of Python functions performing mathematical operations in multiple
  parts of user code, rather than requiring users to write a plotting
  specific version. For example, below the
  <monospace>logistic_growth</monospace> function is used for both curve
  fitting and an interactive display in order to better understand the
  role of the model parameters.</p>
  <code language="python">%matplotlib ipympl
import matplotlib.pyplot as plt
import numpy as np
from scipy.optimize import curve_fit

import mpl_interactions.ipyplot as iplt


def logistic_growth(t, L, k, t0):
    return L / (1 + np.exp(-k * (t - t0)))


# create a synthetic dataset of logistic growth
rng = np.random.default_rng(seed=1995)
t_data = np.sort(rng.uniform(0, 10, size=50))
y_data = logistic_growth(
  t_data, L=5, k=1, t0=1) + rng.normal(size=t_data.size, scale=0.1
)


# You can use the `logistic_growth` function to curve_fit
popt, pcov = curve_fit(logistic_growth, t_data, y_data)


# Now you can directly the same function to make
# an interactive plot to better understand its parameters
fig, axs = plt.subplots(1, 2, sharey=True)
axs[0].plot(t_data, y_data, &quot;o&quot;)
axs[0].plot(t_data, logistic_growth(t_data, *popt))
axs[0].set_title(&quot;Data + Fit&quot;)
axs[1].set_title(&quot;Interactive Exploration&quot;)

ctrls = iplt.plot(
    np.linspace(0, 10),
    logistic_growth,
    L=(0.5, 10),
    k=(0.1, 1),
    t0=(0, 2.5),
    ax=axs[1],
    label=&quot;interactive&quot;,
)
axs[1].plot(t_data, logistic_growth(t_data, *popt), &quot;--&quot;, label=&quot;fit&quot;)
plt.legend()</code>
  <fig>
    <caption><p>Generated figure and sliders after running above example
    in jupyter
    lab.<styled-content id="figU003Alogistic"></styled-content></p></caption>
    <graphic mimetype="image" mime-subtype="png" xlink:href="media/imgs/logistic_growth-dark.png" />
  </fig>
  <p>This framework makes it easy to generate complex interactive
  visualizations. It also enables
  <monospace>mpl-interactions</monospace> to manage generating GIFs. Any
  parameter controlled through <monospace>mpl-interactions</monospace>
  can be used to automatically generate a gif of the plot changing as a
  function of that parameter
  (<ext-link ext-link-type="uri" xlink:href="https://mpl-interactions.readthedocs.io/en/stable/examples/animations.html">Animation
  Documentation</ext-link>). Thus,
  <monospace>mpl-interactions</monospace> can assist across the data
  visualization process, from initial exploration to the creation of a
  final animated plot as a GIF.</p>
</sec>
<sec id="acknowledgements">
  <title>Acknowledgements</title>
  <p>This work was supported by a National Defense Science and
  Engineering Graduate Fellowship (FA9550-19-F-0008, to IHI), the George
  W. Merck Fund of the New York Community Trust (award 338034, to DRH),
  and funds from Harvard University.</p>
  <p>We thank Dr. K. Dalton from stimulating discussion, and Easun
  Arunachalam for feedback on drafts of this paper. In addition, many
  users have contributed features and bug fixes. Of particular note are
  Remco de Boer, and Samantha Hamilton who made contributions to
  documentation and code, and documentation respectively. A full list of
  coding contributors can be found here:
  https://github.com/mpl-extensions/mpl-interactions/graphs/contributors</p>
  <p>Finally, many users have contributed in ways other than coding. For
  example by raising issues either with the package or documentation.
  These users are recognized here:
  https://github.com/mpl-extensions/mpl-interactions#contributors-</p>
</sec>
</body>
<back>
<ref-list>
  <ref id="ref-HunterU003A2007">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Hunter</surname><given-names>J. D.</given-names></name>
      </person-group>
      <article-title>Matplotlib: A 2D graphics environment</article-title>
      <source>Computing in Science &amp; Engineering</source>
      <publisher-name>IEEE COMPUTER SOC</publisher-name>
      <year iso-8601-date="2007">2007</year>
      <volume>9</volume>
      <issue>3</issue>
      <pub-id pub-id-type="doi">10.1109/MCSE.2007.55</pub-id>
      <fpage>90</fpage>
      <lpage>95</lpage>
    </element-citation>
  </ref>
  <ref id="ref-interactive_Jupyter_widgetsU003A2015">
    <element-citation publication-type="manuscript">
      <person-group person-group-type="author">
        <name><surname>Community</surname></name>
      </person-group>
      <article-title>Ipywidgets</article-title>
      <year iso-8601-date="2015">2015</year>
      <uri>https://github.com/jupyter-widgets/ipywidgets</uri>
    </element-citation>
  </ref>
  <ref id="ref-VanderPlas2018">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>VanderPlas</surname><given-names>Jacob</given-names></name>
        <name><surname>Granger</surname><given-names>Brian E.</given-names></name>
        <name><surname>Heer</surname><given-names>Jeffrey</given-names></name>
        <name><surname>Moritz</surname><given-names>Dominik</given-names></name>
        <name><surname>Wongsuphasawat</surname><given-names>Kanit</given-names></name>
        <name><surname>Satyanarayan</surname><given-names>Arvind</given-names></name>
        <name><surname>Lees</surname><given-names>Eitan</given-names></name>
        <name><surname>Timofeev</surname><given-names>Ilia</given-names></name>
        <name><surname>Welsh</surname><given-names>Ben</given-names></name>
        <name><surname>Sievert</surname><given-names>Scott</given-names></name>
      </person-group>
      <article-title>Altair: Interactive statistical visualizations for python</article-title>
      <source>Journal of Open Source Software</source>
      <publisher-name>The Open Journal</publisher-name>
      <year iso-8601-date="2018">2018</year>
      <volume>3</volume>
      <issue>32</issue>
      <uri>https://doi.org/10.21105/joss.01057</uri>
      <pub-id pub-id-type="doi">10.21105/joss.01057</pub-id>
      <fpage>1057</fpage>
      <lpage></lpage>
    </element-citation>
  </ref>
  <ref id="ref-philipp_rudiger_2020_3634720">
    <element-citation publication-type="software">
      <person-group person-group-type="author">
        <name><surname>Rudiger</surname><given-names>Philipp</given-names></name>
        <name><surname>Signell</surname><given-names>Julia</given-names></name>
        <name><surname>Bednar</surname><given-names>James A.</given-names></name>
        <name><surname>Andrew</surname></name>
        <name><surname>Stevens</surname><given-names>Jean-Luc</given-names></name>
        <name><surname>B</surname><given-names>Chris</given-names></name>
        <name><surname>Samuels</surname><given-names>Jordan</given-names></name>
        <name><surname>Todd</surname></name>
        <name><surname>PEDOT</surname><given-names>Thomas</given-names></name>
        <name><surname>Oord</surname><given-names>Sander van den</given-names></name>
        <name><surname>Mease</surname><given-names>Jon</given-names></name>
        <name><surname>Virshup</surname><given-names>Isaac</given-names></name>
        <name><surname>Corona</surname><given-names>Gabriel</given-names></name>
        <name><surname>Hermes</surname><given-names>Danny</given-names></name>
        <name><surname>H.</surname><given-names>Curtis</given-names></name>
        <name><surname>Graser</surname><given-names>Anita</given-names></name>
      </person-group>
      <article-title>Holoviz/hvplot: Version 0.5.2</article-title>
      <publisher-name>Zenodo</publisher-name>
      <year iso-8601-date="2020-02">2020</year><month>02</month>
      <uri>https://doi.org/10.5281/zenodo.3634720</uri>
      <pub-id pub-id-type="doi">10.5281/zenodo.3634720</pub-id>
    </element-citation>
  </ref>
  <ref id="ref-plotly">
    <element-citation publication-type="webpage">
      <person-group person-group-type="author">
        <name><surname>Inc.</surname><given-names>Plotly Technologies</given-names></name>
      </person-group>
      <article-title>Collaborative data science</article-title>
      <publisher-name>Plotly Technologies Inc.</publisher-name>
      <publisher-loc>Montreal, QC</publisher-loc>
      <year iso-8601-date="2015">2015</year>
      <uri>https://plot.ly</uri>
    </element-citation>
  </ref>
</ref-list>
</back>
</article>
