<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN"
                  "JATS-publishing1.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" dtd-version="1.2" article-type="other">
<front>
<journal-meta>
<journal-id></journal-id>
<journal-title-group>
<journal-title>Journal of Open Source Software</journal-title>
<abbrev-journal-title>JOSS</abbrev-journal-title>
</journal-title-group>
<issn publication-format="electronic">2475-9066</issn>
<publisher>
<publisher-name>Open Journals</publisher-name>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="publisher-id">8330</article-id>
<article-id pub-id-type="doi">10.21105/joss.08330</article-id>
<title-group>
<article-title>SDA: a symbolic differential algebra package in
C++</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author" corresp="yes">
<contrib-id contrib-id-type="orcid">https://orcid.org/0000-0001-7701-4118</contrib-id>
<name>
<surname>Zhang</surname>
<given-names>He</given-names>
</name>
<xref ref-type="aff" rid="aff-1"/>
<xref ref-type="corresp" rid="cor-1"><sup>*</sup></xref>
</contrib>
<aff id="aff-1">
<institution-wrap>
<institution>Thomas Jefferson National Accelerator Facility, Newport
News, VA 23606, USA</institution>
</institution-wrap>
</aff>
</contrib-group>
<author-notes>
<corresp id="cor-1">* E-mail: <email></email></corresp>
</author-notes>
<pub-date date-type="pub" publication-format="electronic" iso-8601-date="2024-10-21">
<day>21</day>
<month>10</month>
<year>2024</year>
</pub-date>
<volume>10</volume>
<issue>112</issue>
<fpage>8330</fpage>
<permissions>
<copyright-statement>Authors of papers retain copyright and release the
work under a Creative Commons Attribution 4.0 International License (CC
BY 4.0)</copyright-statement>
<copyright-year>2025</copyright-year>
<copyright-holder>The article authors</copyright-holder>
<license license-type="open-access" xlink:href="https://creativecommons.org/licenses/by/4.0/">
<license-p>Authors of papers retain copyright and release the work under
a Creative Commons Attribution 4.0 International License (CC BY
4.0)</license-p>
</license>
</permissions>
<kwd-group kwd-group-type="author">
<kwd>differential algebra</kwd>
<kwd>truncated power series algebra</kwd>
<kwd>symbolic calculation</kwd>
<kwd>higher-order derivatives</kwd>
<kwd>accelerator physics</kwd>
<kwd>astronomy</kwd>
<kwd>beam dynamics</kwd>
</kwd-group>
</article-meta>
</front>
<body>
<sec id="summary">
  <title>Summary</title>
  <p>Truncated Power Series Algebra (TPSA), or Differential Algebra
  (DA), is a well-established tool in accelerator physics, commonly used
  for generating high-order maps of dynamic systems, as well as in
  symplectic tracking, normal form analysis, verified integration,
  optimization, and fast multipole methods. This package is the first to
  perform symbolic DA computations, enabling traceability of initial
  condition contributions and runtime reduction for repeated DA
  calculations, potentially expanding DA‚Äôs applications.</p>
</sec>
<sec id="background">
  <title>Background</title>
  <p>The fundamental concept in DA is the DA vector, which can be
  considered as the Taylor expansion of a function at a specific point
  from a practical perspective.</p>
  <p>Considering a function <inline-formula><alternatives>
  <tex-math><![CDATA[f(\mathbf{x})]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>f</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>ùê±</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
  and its Taylor expansion <inline-formula><alternatives>
  <tex-math><![CDATA[f_{\mathrm{T}}(\mathbf{x}_0)]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mi mathvariant="normal">T</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>ùê±</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
  at the point <inline-formula><alternatives>
  <tex-math><![CDATA[\mathbf{x}_0]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>ùê±</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:math></alternatives></inline-formula>
  up to order <inline-formula><alternatives>
  <tex-math><![CDATA[n]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>n</mml:mi></mml:math></alternatives></inline-formula>,
  we can define the equivalence relation between the Taylor expansion
  and the DA vector as:</p>
  <p><disp-formula><alternatives>
  <tex-math><![CDATA[ [f]_n = f_{\mathrm{T}}(\mathbf{x}_0) = \sum {C_{n_1,n_2, ..., n_v}} \cdot d_1^{n_1} \cdot \dots \cdot d_v^{n_v}, ]]></tex-math>
  <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mi>f</mml:mi><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow><mml:mi>n</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>f</mml:mi><mml:mi mathvariant="normal">T</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>ùê±</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mo>‚àë</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mi>.</mml:mi><mml:mi>.</mml:mi><mml:mi>.</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>n</mml:mi><mml:mi>v</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo>‚ãÖ</mml:mo><mml:msubsup><mml:mi>d</mml:mi><mml:mn>1</mml:mn><mml:msub><mml:mi>n</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:msubsup><mml:mo>‚ãÖ</mml:mo><mml:mi>‚Ä¶</mml:mi><mml:mo>‚ãÖ</mml:mo><mml:msubsup><mml:mi>d</mml:mi><mml:mi>v</mml:mi><mml:msub><mml:mi>n</mml:mi><mml:mi>v</mml:mi></mml:msub></mml:msubsup><mml:mo>,</mml:mo></mml:mrow></mml:math></alternatives></disp-formula>
  where <inline-formula><alternatives>
  <tex-math><![CDATA[\mathbf{x} = (x_1, x_2, \dots, x_v)]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>ùê±</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mi>‚Ä¶</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>v</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>,
  and <inline-formula><alternatives>
  <tex-math><![CDATA[n \ge n_1 + n_2 + \dots + n_v]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>n</mml:mi><mml:mo>‚â•</mml:mo><mml:msub><mml:mi>n</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:mi>‚Ä¶</mml:mi><mml:mo>+</mml:mo><mml:msub><mml:mi>n</mml:mi><mml:mi>v</mml:mi></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>.
  Here <inline-formula><alternatives>
  <tex-math><![CDATA[d_i]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>d</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
  is a special number: it represents a small variance in
  <inline-formula><alternatives>
  <tex-math><![CDATA[x_i]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></alternatives></inline-formula>.
  To add two DA vectors, we simply add the coefficients of the like
  terms. To multiply two DA vectors, we multiply each term in the first
  with all the terms in the second and then combine like terms, ignoring
  all terms above order <inline-formula><alternatives>
  <tex-math><![CDATA[n]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>n</mml:mi></mml:math></alternatives></inline-formula>.
  Given two DA vectors <inline-formula><alternatives>
  <tex-math><![CDATA[[a]_n]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow><mml:mi>n</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
  and <inline-formula><alternatives>
  <tex-math><![CDATA[[b]_n]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow><mml:mi>n</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
  and a scalar c, we have</p>
  <p><named-content id="eqU003Aaddmlt" content-type="equation"><disp-formula><alternatives>
  <tex-math><![CDATA[\begin{aligned}
  _{n}+[b]_{n} & := & [a+b]_{n},\nonumber \\
  c\cdot[a]_{n} & := & [c\cdot a]_{n},\\
  {}[a]_{n}\cdot[b]_{n} & := & [a\cdot b]_{n}.\nonumber 
  \end{aligned}]]></tex-math>
  <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mtable><mml:mtr><mml:mtd columnalign="right" style="text-align: right"><mml:msub><mml:mi></mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow><mml:mi>n</mml:mi></mml:msub></mml:mtd><mml:mtd columnalign="left" style="text-align: left"><mml:mo>:=</mml:mo></mml:mtd><mml:mtd columnalign="right" style="text-align: right"><mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mi>a</mml:mi><mml:mo>+</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow><mml:mi>n</mml:mi></mml:msub><mml:mo>,</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right" style="text-align: right"><mml:mi>c</mml:mi><mml:mo>‚ãÖ</mml:mo><mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow><mml:mi>n</mml:mi></mml:msub></mml:mtd><mml:mtd columnalign="left" style="text-align: left"><mml:mo>:=</mml:mo></mml:mtd><mml:mtd columnalign="right" style="text-align: right"><mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mi>c</mml:mi><mml:mo>‚ãÖ</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow><mml:mi>n</mml:mi></mml:msub><mml:mo>,</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right" style="text-align: right"><mml:mrow></mml:mrow><mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow><mml:mi>n</mml:mi></mml:msub><mml:mo>‚ãÖ</mml:mo><mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow><mml:mi>n</mml:mi></mml:msub></mml:mtd><mml:mtd columnalign="left" style="text-align: left"><mml:mo>:=</mml:mo></mml:mtd><mml:mtd columnalign="right" style="text-align: right"><mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mi>a</mml:mi><mml:mo>‚ãÖ</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow><mml:mi>n</mml:mi></mml:msub><mml:mi>.</mml:mi></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></named-content></p>
  <p>According to the fixed point theorem
  (<xref alt="Berz, 1999" rid="ref-AIEP108book" ref-type="bibr">Berz,
  1999</xref>), the inverse of a DA vector that is not infinitely small
  can be calculated in a finite number of iterations. The derivation
  operator <inline-formula><alternatives>
  <tex-math><![CDATA[\partial_v]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>‚àÇ</mml:mi><mml:mi>v</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
  with respect to the <inline-formula><alternatives>
  <tex-math><![CDATA[v^{\mathrm{th}}]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msup><mml:mi>v</mml:mi><mml:mrow><mml:mi mathvariant="normal">t</mml:mi><mml:mi mathvariant="normal">h</mml:mi></mml:mrow></mml:msup></mml:math></alternatives></inline-formula>
  variable and its inverse operator <inline-formula><alternatives>
  <tex-math><![CDATA[\partial^{-1}v]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msup><mml:mi>‚àÇ</mml:mi><mml:mrow><mml:mi>‚àí</mml:mi><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mi>v</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
  can be carried out on a term-by-term basis on
  <inline-formula><alternatives>
  <tex-math><![CDATA[[a]_n]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow><mml:mi>n</mml:mi></mml:msub></mml:math></alternatives></inline-formula>.
  A DA vector can be used in calculations just as a number.</p>
  <p>The symbolic DA combines DA with symbolic calculation. Any
  coefficient of a Symbolic DA (SDA) vector is an explicit expression of
  the symbols in lieu of a number.</p>
</sec>
<sec id="statement-of-need">
  <title>Statement of need</title>
  <p>DA has been used in particle beam dynamic analysis since the 1980s
  and gradually extended to other fields. DA provides powerful tools
  (<xref alt="Berz, 1991a" rid="ref-caprimap" ref-type="bibr">Berz,
  1991a</xref>,
  <xref alt="1991b" rid="ref-monthnf" ref-type="bibr">1991b</xref>) for
  analyzing dynamic systems. It is also used in various numerical
  algorithms, e.g., verified integration
  (<xref alt="Berz &amp; Makino, 1998" rid="ref-rdaint" ref-type="bibr">Berz
  &amp; Makino, 1998</xref>), global optimization
  (<xref alt="Makino &amp; Berz, 2005" rid="ref-makino2005verified" ref-type="bibr">Makino
  &amp; Berz, 2005</xref>), and fast multipole method
  (<xref alt="Zhang &amp; Berz, 2011" rid="ref-FMMCPO2010" ref-type="bibr">Zhang
  &amp; Berz, 2011</xref>). DA tools are available in particle
  accelerator simulators
  (<xref alt="Deniau et al., 2017" rid="ref-MADX" ref-type="bibr">Deniau
  et al., 2017</xref>;
  <xref alt="Forest et al., 2002" rid="ref-forest2002introduction" ref-type="bibr">Forest
  et al., 2002</xref>;
  <xref alt="Grote &amp; Schmidt, 2003" rid="ref-grote2003mad" ref-type="bibr">Grote
  &amp; Schmidt, 2003</xref>;
  <xref alt="Makino &amp; Berz, 2006" rid="ref-COSYCAP04" ref-type="bibr">Makino
  &amp; Berz, 2006</xref>) or as stand-alone libraries
  (<xref alt="Massari et al., 2018" rid="ref-massari2018differential" ref-type="bibr">Massari
  et al., 2018</xref>;
  <xref alt="Massari &amp; Wittig, 2021" rid="ref-DACE" ref-type="bibr">Massari
  &amp; Wittig, 2021</xref>;
  <xref alt="Zhang, 2024" rid="ref-zhang2024cpptpsa" ref-type="bibr">Zhang,
  2024</xref>). All of them only perform numerical DA calculations. This
  is the first and only library for symbolic DA calculations.</p>
  <p>The SDA package can be used in several important ways. First, in
  high-performance computing scenarios involving differential algebra
  (DA), it can produce explicit expressions for the results of complex
  DA calculations. These expressions enable the generation of highly
  efficient code that eliminates the need for runtime DA computations,
  resulting in significant performance improvements
  (<xref alt="Zhang, 2025a" rid="ref-zhang2025Boosting" ref-type="bibr">Zhang,
  2025a</xref>). This was the original motivation for developing the
  package. Second, as a tool for dynamic analysis, it supports
  parametric and time-dependent studies by allowing DA maps to vary with
  symbolic parameters. This makes it possible to analyze how system
  behavior changes with evolving settings‚Äîsomething difficult to achieve
  with numerical DA alone. Finally, it provides a new way to obtain
  symbolic expressions of higher-order derivatives by following the
  algorithmic differentiation process, thus bridging the gap between
  symbolic and numerical approaches
  (<xref alt="Zhang, 2025b" rid="ref-zhang2025higher" ref-type="bibr">Zhang,
  2025b</xref>).</p>
</sec>
<sec id="features">
  <title>Features</title>
  <p>This library is based on the numerical DA library, cppTPSA
  (<xref alt="Zhang, 2024" rid="ref-zhang2024cpptpsa" ref-type="bibr">Zhang,
  2024</xref>). All the DA calculations are carried out on symbols using
  exactly the same algorithms in cppTPSA by employing the SymEngine
  library
  (<xref alt="Fernando et al., 2024" rid="ref-Fernando2024SymEngine" ref-type="bibr">Fernando
  et al., 2024</xref>). Users can compile the source code into a static
  or shared library and install it on their system. The main features of
  this library are:</p>
  <list list-type="order">
    <list-item>
      <p>A custom SDA vector type with overloaded math operations,
      including composition, differentiation, and inverse.</p>
    </list-item>
    <list-item>
      <p>Extraction of explicit expressions for partial derivatives.</p>
    </list-item>
    <list-item>
      <p>Generation of callable functions from an SDA vector.</p>
    </list-item>
    <list-item>
      <p>Conversion of symbolic SDA to numerical DA.</p>
    </list-item>
  </list>
  <p>The following code shows how to calculate the SDA vector of
  <inline-formula><alternatives>
  <tex-math><![CDATA[1/\sqrt{x^2+y^2}]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mn>1</mml:mn><mml:mi>/</mml:mi><mml:msqrt><mml:mrow><mml:msup><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>+</mml:mo><mml:msup><mml:mi>y</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:msqrt></mml:mrow></mml:math></alternatives></inline-formula>
  up to the third order. After initializing a memory pool for 400 SDA
  vectors and defining the symbols, <inline-formula><alternatives>
  <tex-math><![CDATA[x]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>x</mml:mi></mml:math></alternatives></inline-formula>
  and <inline-formula><alternatives>
  <tex-math><![CDATA[y]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>y</mml:mi></mml:math></alternatives></inline-formula>,
  the SDA vector <inline-formula><alternatives>
  <tex-math><![CDATA[f]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>f</mml:mi></mml:math></alternatives></inline-formula>
  is calculated and shown in
  <xref alt="[fig:sda]" rid="figU003Asda">[fig:sda]</xref>. The orders
  of the bases, the index of each term, and the coefficient of each term
  as a function of <inline-formula><alternatives>
  <tex-math><![CDATA[x]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>x</mml:mi></mml:math></alternatives></inline-formula>
  and <inline-formula><alternatives>
  <tex-math><![CDATA[y]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>y</mml:mi></mml:math></alternatives></inline-formula>
  are displayed in columns.</p>
  <code language="c++">#include &lt;iostream&gt;
#include &lt;sda.h&gt;
typedef SymbDA::DAVector SDA;
using SymEngine::Expression;

int main() {
    int order{3}, dim{2}, pool{400};
    SymbDA::da_init(order, dim, pool);
    auto&amp; sda = SymbDA::da;
    Expression sx(&quot;x&quot;), sy(&quot;y&quot;);
    SDA f = 1/sqrt((sx+sda[0])*(sx+sda[0]) + (sy+sda[1])*(sy+sda[1]));
    std::cout&lt;&lt;f;
}</code>
  <fig>
    <caption><p>Example code
    output.<styled-content id="figU003Asda"></styled-content></p></caption>
    <graphic mimetype="image" mime-subtype="png" xlink:href="fig_sda.png" />
  </fig>
</sec>
<sec id="verification">
  <title>Verification</title>
  <p>This library has been verified with the numerical DA library,
  cppTPSA, by assigning values to all the symbols in an SDA vector and
  checking it against direct calculation using cppTPSA. As an example,
  For example,
  <xref alt="[fig:veri_sda]" rid="figU003Averi_sda">[fig:veri_sda]</xref>
  and
  <xref alt="[fig:veri_da]" rid="figU003Averi_da">[fig:veri_da]</xref>
  show the DA vector <inline-formula><alternatives>
  <tex-math><![CDATA[v = \exp(1.5926 + d_1^2 + 5.3897\cdot d_2)]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>v</mml:mi><mml:mo>=</mml:mo><mml:mo>exp</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>1.5926</mml:mn><mml:mo>+</mml:mo><mml:msubsup><mml:mi>d</mml:mi><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:msubsup><mml:mo>+</mml:mo><mml:mn>5.3897</mml:mn><mml:mo>‚ãÖ</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
  to the fifth order, calculated by SDA and DA respectively. We
  calculate the relative error for each non-zero coefficient. This
  procedure is repeated 1,000 times for all the math functions in the
  SDA lib and the absolute values of the relative errors are all below
  <inline-formula><alternatives>
  <tex-math><![CDATA[1\times 10^{-15}]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mn>1</mml:mn><mml:mo>√ó</mml:mo><mml:msup><mml:mn>10</mml:mn><mml:mrow><mml:mi>‚àí</mml:mi><mml:mn>15</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></alternatives></inline-formula>.</p>
  <fig>
    <caption><p>SDA
    output.<styled-content id="figU003Averi_sda"></styled-content></p></caption>
    <graphic mimetype="image" mime-subtype="png" xlink:href="fig_veri_sda.png" />
  </fig>
  <fig>
    <caption><p>cppTPSA
    output.<styled-content id="figU003Averi_da"></styled-content></p></caption>
    <graphic mimetype="image" mime-subtype="png" xlink:href="fig_veri_da.png" />
  </fig>
</sec>
<sec id="acknowledgements">
  <title>Acknowledgements</title>
  <p>This material is based upon work supported by the U.S. Department
  of Energy, Office of Science, Office of Nuclear Physics under contract
  DE-AC05-06OR23177.</p>
</sec>
</body>
<back>
<ref-list>
  <title></title>
  <ref id="ref-caprimap">
    <element-citation publication-type="paper-conference">
      <person-group person-group-type="author">
        <name><surname>Berz</surname><given-names>M.</given-names></name>
      </person-group>
      <article-title>Symplectic tracking in circular accelerators with high order maps</article-title>
      <source>Nonlinear problems in future particle accelerators</source>
      <publisher-name>World Scientific</publisher-name>
      <year iso-8601-date="1991">1991</year>
      <fpage>288</fpage>
      <lpage></lpage>
    </element-citation>
  </ref>
  <ref id="ref-monthnf">
    <element-citation publication-type="chapter">
      <person-group person-group-type="author">
        <name><surname>Berz</surname><given-names>M.</given-names></name>
      </person-group>
      <article-title>High-order computation and normal form analysis of repetitive systems, in: M. Month (Ed), physics of particle accelerators</article-title>
      <publisher-name>American Institute of Physics</publisher-name>
      <publisher-loc>New York</publisher-loc>
      <year iso-8601-date="1991">1991</year>
      <volume>249</volume>
      <pub-id pub-id-type="doi">10.1063/1.41975</pub-id>
      <fpage>456</fpage>
      <lpage></lpage>
    </element-citation>
  </ref>
  <ref id="ref-rdaint">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Berz</surname><given-names>M.</given-names></name>
        <name><surname>Makino</surname><given-names>K.</given-names></name>
      </person-group>
      <article-title>Verified integration of ODEs and flows using differential algebraic methods on high-order Taylor models</article-title>
      <source>Reliable Computing</source>
      <year iso-8601-date="1998">1998</year>
      <volume>4</volume>
      <pub-id pub-id-type="doi">10.1023/A:1024467732637</pub-id>
      <fpage>361</fpage>
      <lpage>369</lpage>
    </element-citation>
  </ref>
  <ref id="ref-makino2005verified">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Makino</surname><given-names>K.</given-names></name>
        <name><surname>Berz</surname><given-names>M.</given-names></name>
      </person-group>
      <article-title>Verified global optimization with Taylor model based range bounders</article-title>
      <source>Transactions on computers</source>
      <year iso-8601-date="2005">2005</year>
      <volume>11</volume>
      <issue>4</issue>
      <uri>https://www.bmtdynamics.org/pub/papers/GOM05/GOM05.pdf</uri>
      <fpage>1611</fpage>
      <lpage>1618</lpage>
    </element-citation>
  </ref>
  <ref id="ref-FMMCPO2010">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Zhang</surname><given-names>H.</given-names></name>
        <name><surname>Berz</surname><given-names>M.</given-names></name>
      </person-group>
      <article-title>The fast multipole method in the differential algebra framework</article-title>
      <source>Nuclear Instruments and Methods A 645</source>
      <year iso-8601-date="2011">2011</year>
      <pub-id pub-id-type="doi">10.1016/j.nima.2011.01.053</pub-id>
      <fpage>338</fpage>
      <lpage>344</lpage>
    </element-citation>
  </ref>
  <ref id="ref-AIEP108book">
    <element-citation publication-type="book">
      <person-group person-group-type="author">
        <name><surname>Berz</surname><given-names>M.</given-names></name>
      </person-group>
      <source>Modern map methods in particle beam physics</source>
      <publisher-name>Academic Press</publisher-name>
      <publisher-loc>San Diego</publisher-loc>
      <year iso-8601-date="1999">1999</year>
      <isbn>0-12-014750-5</isbn>
      <pub-id pub-id-type="doi">10.1016/s1076-5670(08)x7018-1</pub-id>
    </element-citation>
  </ref>
  <ref id="ref-COSYCAP04">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Makino</surname><given-names>K.</given-names></name>
        <name><surname>Berz</surname><given-names>M.</given-names></name>
      </person-group>
      <article-title>COSY INFINITY version 9</article-title>
      <source>Nuclear Instruments and Methods</source>
      <year iso-8601-date="2006">2006</year>
      <volume>558</volume>
      <pub-id pub-id-type="doi">10.1016/j.nima.2005.11.109</pub-id>
      <fpage>346</fpage>
      <lpage>350</lpage>
    </element-citation>
  </ref>
  <ref id="ref-forest2002introduction">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Forest</surname><given-names>Etienne</given-names></name>
        <name><surname>Schmidt</surname><given-names>Frank</given-names></name>
        <name><surname>McIntosh</surname><given-names>Eric</given-names></name>
      </person-group>
      <article-title>Introduction to the polymorphic tracking code</article-title>
      <source>KEK report</source>
      <year iso-8601-date="2002">2002</year>
      <volume>3</volume>
      <uri>https://inspirehep.net/literature/591979</uri>
      <fpage>2002</fpage>
      <lpage></lpage>
    </element-citation>
  </ref>
  <ref id="ref-massari2018differential">
    <element-citation publication-type="chapter">
      <person-group person-group-type="author">
        <name><surname>Massari</surname><given-names>M.</given-names></name>
        <name><surname>Di Lizia</surname><given-names>Pierluigi</given-names></name>
        <name><surname>Cavenago</surname><given-names>Francesco</given-names></name>
        <name><surname>Wittig</surname><given-names>Alexander</given-names></name>
      </person-group>
      <article-title>Differential algebra software library with automatic code generation for space embedded applications</article-title>
      <source>2018 AIAA information systems-AIAA infotech@ aerospace</source>
      <year iso-8601-date="2018">2018</year>
      <pub-id pub-id-type="doi">10.2514/6.2018-0398</pub-id>
      <fpage>0398</fpage>
      <lpage></lpage>
    </element-citation>
  </ref>
  <ref id="ref-DACE">
    <element-citation>
      <person-group person-group-type="author">
        <name><surname>Massari</surname><given-names>M.</given-names></name>
        <name><surname>Wittig</surname><given-names>A.</given-names></name>
      </person-group>
      <article-title>DACE: The differential algebra computational toolbox</article-title>
      <source>GitHub repository</source>
      <publisher-name>GitHub</publisher-name>
      <year iso-8601-date="2021">2021</year>
      <uri>https://github.com/dacelib/dace</uri>
    </element-citation>
  </ref>
  <ref id="ref-grote2003mad">
    <element-citation publication-type="paper-conference">
      <person-group person-group-type="author">
        <name><surname>Grote</surname><given-names>H</given-names></name>
        <name><surname>Schmidt</surname><given-names>F</given-names></name>
      </person-group>
      <article-title>MAD-X-an upgrade from MAD8</article-title>
      <source>Proceedings of the 2003 particle accelerator conference</source>
      <publisher-name>IEEE</publisher-name>
      <year iso-8601-date="2003">2003</year>
      <volume>5</volume>
      <pub-id pub-id-type="doi">10.1109/PAC.2003.1289960</pub-id>
      <fpage>3497</fpage>
      <lpage>3499</lpage>
    </element-citation>
  </ref>
  <ref id="ref-MADX">
    <element-citation>
      <person-group person-group-type="author">
        <name><surname>Deniau</surname><given-names>L.</given-names></name>
        <name><surname>Skowronski</surname><given-names>P.</given-names></name>
        <name><surname>Roy</surname><given-names>G.</given-names></name>
        <name><surname>others</surname></name>
      </person-group>
      <article-title>MAD-X: Methodical accelerator design</article-title>
      <source>GitHub repository</source>
      <publisher-name>GitHub</publisher-name>
      <year iso-8601-date="2017">2017</year>
      <uri>https://github.com/MethodicalAcceleratorDesign/MAD-X</uri>
      <pub-id pub-id-type="doi">10.5281/zenodo.7900975</pub-id>
    </element-citation>
  </ref>
  <ref id="ref-zhang2024cpptpsa">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Zhang</surname><given-names>H.</given-names></name>
      </person-group>
      <article-title>cppTPSA/pyTPSA: A C++/Python package for truncated power series algebra</article-title>
      <source>Journal of Open Source Software</source>
      <year iso-8601-date="2024">2024</year>
      <volume>9</volume>
      <issue>94</issue>
      <pub-id pub-id-type="doi">10.21105/joss.04818</pub-id>
      <fpage>4818</fpage>
      <lpage></lpage>
    </element-citation>
  </ref>
  <ref id="ref-Fernando2024SymEngine">
    <element-citation publication-type="webpage">
      <person-group person-group-type="author">
        <name><surname>Fernando</surname><given-names>Isuru</given-names></name>
        <name><surname>ƒåert√≠k</surname><given-names>Ond≈ôej</given-names></name>
        <name><surname>others</surname></name>
      </person-group>
      <article-title>SymEngine</article-title>
      <year iso-8601-date="2024">2024</year>
      <uri>https://github.com/symengine/symengine</uri>
    </element-citation>
  </ref>
  <ref id="ref-zhang2025Boosting">
    <element-citation publication-type="pamphlet">
      <person-group person-group-type="author">
        <name><surname>Zhang</surname><given-names>H.</given-names></name>
      </person-group>
      <article-title>Boosting the efficiency of the differential AlgebraBased fast multipole method operators using symbolic calculation</article-title>
      <publisher-name>Presented at the meeting of SIAM CSE25, Fort Worth, Texas, U.S.</publisher-name>
      <year iso-8601-date="2025">2025</year>
      <uri>https://www.siam.org/media/fyvh3qlf/cse25_abstracts.pdf</uri>
    </element-citation>
  </ref>
  <ref id="ref-zhang2025higher">
    <element-citation>
      <person-group person-group-type="author">
        <name><surname>Zhang</surname><given-names>H.</given-names></name>
      </person-group>
      <article-title>Higher-order automatic differentiation using symbolic differential algebra: Bridging the gap between algorithmic and symbolic differentiation</article-title>
      <year iso-8601-date="2025">2025</year>
      <uri>https://arxiv.org/abs/2506.00796</uri>
    </element-citation>
  </ref>
</ref-list>
</back>
</article>
