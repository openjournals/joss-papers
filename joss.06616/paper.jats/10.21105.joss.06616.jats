<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN"
                  "JATS-publishing1.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" dtd-version="1.2" article-type="other">
<front>
<journal-meta>
<journal-id></journal-id>
<journal-title-group>
<journal-title>Journal of Open Source Software</journal-title>
<abbrev-journal-title>JOSS</abbrev-journal-title>
</journal-title-group>
<issn publication-format="electronic">2475-9066</issn>
<publisher>
<publisher-name>Open Journals</publisher-name>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="publisher-id">6616</article-id>
<article-id pub-id-type="doi">10.21105/joss.06616</article-id>
<title-group>
<article-title>IonDiff: command-line tool to identify ionic diffusion
events and hopping correlations in molecular dynamics
simulations</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author">
<contrib-id contrib-id-type="orcid">https://orcid.org/0000-0003-3949-5058</contrib-id>
<name>
<surname>López</surname>
<given-names>Cibrán</given-names>
</name>
<xref ref-type="aff" rid="aff-1"/>
<xref ref-type="aff" rid="aff-2"/>
</contrib>
<contrib contrib-type="author">
<contrib-id contrib-id-type="orcid">https://orcid.org/0000-0002-4086-4191</contrib-id>
<name>
<surname>Rurali</surname>
<given-names>Riccardo</given-names>
</name>
<xref ref-type="aff" rid="aff-3"/>
</contrib>
<contrib contrib-type="author" corresp="yes">
<contrib-id contrib-id-type="orcid">https://orcid.org/0000-0002-6501-4513</contrib-id>
<name>
<surname>Cazorla</surname>
<given-names>Claudio</given-names>
</name>
<xref ref-type="aff" rid="aff-1"/>
<xref ref-type="aff" rid="aff-2"/>
<xref ref-type="corresp" rid="cor-1"><sup>*</sup></xref>
</contrib>
<aff id="aff-1">
<institution-wrap>
<institution>Departament de Física, Universitat Politècnica de
Catalunya, 08034 Barcelona, Spain.</institution>
</institution-wrap>
</aff>
<aff id="aff-2">
<institution-wrap>
<institution>Barcelona Research Center in Multiscale Science and
Engineering, Universitat Politècnica de Catalunya, 08019 Barcelona,
Spain.</institution>
</institution-wrap>
</aff>
<aff id="aff-3">
<institution-wrap>
<institution>Institut de Ciència de Materials de Barcelona, ICMAB-CSIC,
Campus UAB, 08193 Bellaterra, Spain.</institution>
</institution-wrap>
</aff>
</contrib-group>
<author-notes>
<corresp id="cor-1">* E-mail: <email></email></corresp>
</author-notes>
<pub-date date-type="pub" publication-format="electronic" iso-8601-date="2023-12-16">
<day>16</day>
<month>12</month>
<year>2023</year>
</pub-date>
<volume>9</volume>
<issue>99</issue>
<fpage>6616</fpage>
<permissions>
<copyright-statement>Authors of papers retain copyright and release the
work under a Creative Commons Attribution 4.0 International License (CC
BY 4.0)</copyright-statement>
<copyright-year>2022</copyright-year>
<copyright-holder>The article authors</copyright-holder>
<license license-type="open-access" xlink:href="https://creativecommons.org/licenses/by/4.0/">
<license-p>Authors of papers retain copyright and release the work under
a Creative Commons Attribution 4.0 International License (CC BY
4.0)</license-p>
</license>
</permissions>
<kwd-group kwd-group-type="author">
<kwd>Python</kwd>
<kwd>Molecular dynamics</kwd>
<kwd>Solid-state electrolytes</kwd>
</kwd-group>
</article-meta>
</front>
<body>
<sec id="summary">
  <title>Summary</title>
  <p>Molecular dynamics (MD) simulations of fast-ion conductors render
  the trajectories of the atoms comprising them. However, extracting
  meaningful insights from this data is often a challenge since most
  common analysis techniques rely on active supervision of the
  simulations and definition of arbitrary material-dependent parameters,
  thus frustrating high-throughput screenings. In particular, to the
  best of our knowledge, determination of exact ionic migration paths
  and the level of coordination between mobile particles in diffusive
  events has not been previously addressed in a systematic and
  quantitative manner, despite its central role in the understanding and
  design of high-performance solid-state electrolytes. Here, we
  introduce a completely unsupervised approach for analyzing ion-hopping
  events in MD simulations. Based on k-means clustering, our algorithm
  identifies with precision which particles diffuse and when during a
  simulation, thus identifying their exact migration paths. This
  analysis also allows for the quantification of correlations between
  many diffusing ions as well as of key atomistic descriptors like the
  duration/length of diffusion events and residence times. Moreover, the
  present implementation introduces an optimized code for computing the
  full ion diffusion coefficient, that is, entirely considering ionic
  correlations, thus going beyond the dilute limit approximation.</p>
</sec>
<sec id="statement-of-need">
  <title>Statement of need</title>
  <p>Fast-ion conductors (FIC) are materials in which some of their
  constituent atoms diffuse with large drift velocities comparable to
  those found in liquids
  (<xref alt="Hull, 2004" rid="ref-Hull2004" ref-type="bibr">Hull,
  2004</xref>;
  <xref alt="Sagotra &amp; Cazorla, 2017" rid="ref-Sagotra2017" ref-type="bibr">Sagotra
  &amp; Cazorla, 2017</xref>). FIC are the pillars of many energy
  conversion and storage technologies like solid-state electrochemical
  batteries and fuel cells. Molecular dynamics (MD) simulation is a
  computational method that employs Newton’s laws to evaluate the
  trajectory of ions in complex atomic and molecular systems. MD
  simulations of FIC are highly valuable since they can describe in
  detail the diffusion and vibration of the constituent ions.
  Nevertheless, there is a notable lack of user-friendly computational
  tools for analyzing the outputs of FIC MD simulations in an
  unsupervised and materials-independent manner, thus frustrating the
  fundamental understanding and possible rational design of FIC.</p>
</sec>
<sec id="iondiff">
  <title>IonDiff</title>
  <p><bold>IonDiff</bold> efficiently addresses the challenge described
  above by implementing unsupervised machine learning approaches in a
  repository of Python scripts designed to extract the exact migrating
  paths of diffusive particles from MD simulations, along with other
  physically relevant quantities like the degree of correlation between
  diffusive ions, ionic residence times in metastable positions and the
  length and duration of ionic hops. Additionally, IonDiff efficiently
  and seamlessly evaluates full ion diffusion coefficients, which in
  contrast to tracer ion diffusion coefficients fully encompass ionic
  correlations. Periodic boundary conditions are fully accounted for by
  IonDiff.</p>
  <p>The repository is divided into three independent
  functionalities:</p>
  <list list-type="bullet">
    <list-item>
      <p><italic>identify_diffusion</italic>: extraction of the
      migration paths from a given MD simulation. It generates a
      <bold>DIFFUSION</bold> file in the folder containing the inputs
      and outputs of the MD simulation. This file contains all the
      necessary atomistic information for the following analysis of
      ionic diffusion events.</p>
    </list-item>
    <list-item>
      <p><italic>analyze_correlations</italic>: analysis of the
      correlations between ionic diffusion events extracted from a
      series of MD simulations (the <bold>DIFFUSION</bold> file for each
      of these simulations will be generated if it does not exist yet).
      A more technically detailed description of this functionality can
      be found in the Methods section and in
      (<xref alt="López et al., 2024b" rid="ref-Lopez2024" ref-type="bibr">López
      et al., 2024b</xref>).</p>
    </list-item>
    <list-item>
      <p><italic>analyze_descriptors</italic>: extraction and analysis
      of spatio-temporal descriptors involving the ionic diffusion
      events identified in the MD simulations. In this library, an
      optimized approach for computing the full ionic diffusion
      coefficient (i.e., including ionic cross correlations, proven to
      be non-negligible in FIC
      (<xref alt="López et al., 2024b" rid="ref-Lopez2024" ref-type="bibr">López
      et al., 2024b</xref>;
      <xref alt="Molinari et al., 2021" rid="ref-Molinari2021" ref-type="bibr">Molinari
      et al., 2021</xref>;
      <xref alt="Sasaki et al., 2023" rid="ref-Sasaki2023" ref-type="bibr">Sasaki
      et al., 2023</xref>) is implemented. A technically detailed
      description of this functionality can be found in
      (<xref alt="López et al., 2024b" rid="ref-Lopez2024" ref-type="bibr">López
      et al., 2024b</xref>).</p>
    </list-item>
  </list>
  <p>The minimal input needed (besides the file containing the actual
  atomistic trajectories) consists in an <bold>INCAR</bold> file with
  the <bold>POTIM</bold> and <bold>NBLOCK</bold> flags (indicating the
  simulation time step and the frequency with which the configurations
  are written, respectively). After installation, all routines are
  easily controlled from the command line. More detailed information can
  be found in the documentation of the project (including specific
  <bold>README</bold>s within each folder).</p>
  <p>The script allows graphing the identified diffusion paths for each
  simulated particle and provides the confidence interval associated
  with the results retrieved by the algorithm. An example of the
  analysis performed on an <italic>ab initio</italic> MD (AIMD)
  simulation based on density functional theory (DFT) is shown in
  <xref alt="[fig:diffusion-detection]" rid="figU003Adiffusion-detection">[fig:diffusion-detection]</xref>.
  The AIMD configurations file employed in this example is available
  online at
  (<xref alt="López et al., 2024a" rid="ref-database" ref-type="bibr">López
  et al., 2024a</xref>), along with many other AIMD simulations
  comprehensively analyzed in two previous works
  (<xref alt="López et al., 2023" rid="ref-Lopez2023" ref-type="bibr">López
  et al., 2023</xref>,
  <xref alt="2024b" rid="ref-Lopez2024" ref-type="bibr">2024b</xref>).</p>
  <fig>
    <caption><p>Example of the performance of our unsupervised algorithm
    at extracting the diffusive path for an arbitrary particle in an
    AIMD simulation of SrCoO<sub>3-x</sub> at a temperature of 400K.
    Green and orange dots reproduce two different ionic vibrational
    centers while the blue dots represent the ion diffusion path between
    them.
    <styled-content id="figU003Adiffusion-detection"></styled-content></p></caption>
    <graphic mimetype="application" mime-subtype="pdf" xlink:href="figure.pdf" />
  </fig>
  <p>Moreover, users may find information regarding their previous
  executions of the scripts in the <italic>logs</italic> folder, which
  should be used to track possible errors inn the data format and more.
  Finally, a number of tests for checking out all <bold>IonDiff</bold>
  functions can be found in the <italic>tests</italic> folder.</p>
  <p>Mainly, our code is based on the sklearn
  (<xref alt="Pedregosa et al., 2011" rid="ref-Pedregosa2011" ref-type="bibr">Pedregosa
  et al., 2011</xref>) implementation of the k-means clustering method.
  The default values of the sklearn hyperparameters are the ones used by
  IonDiff, although these can be varied at wish by the user.
  Additionally, the python libraries numpy
  (<xref alt="Harris et al., 2020" rid="ref-Harris2020" ref-type="bibr">Harris
  et al., 2020</xref>) and matplotlib
  (<xref alt="Hunter, 2007" rid="ref-Hunter2007" ref-type="bibr">Hunter,
  2007</xref>) are used to perform numerical analysis and plotting,
  respectively. The current IonDiff version reads information from VASP
  (<xref alt="Kresse &amp; Furthmüller, 1996" rid="ref-Kresse1996" ref-type="bibr">Kresse
  &amp; Furthmüller, 1996</xref>) simulations; future releases, already
  under active development, will extend its scope to simulation data
  obtained from other quantum and classical molecular dynamics
  packages.</p>
</sec>
<sec id="methods">
  <title>Methods</title>
  <sec id="ionic-conductivity">
    <title>Ionic conductivity</title>
    <p>The (full) ionic diffusion coefficient consists of two parts
    (<xref alt="Molinari et al., 2021" rid="ref-Molinari2021" ref-type="bibr">Molinari
    et al., 2021</xref>;
    <xref alt="Sasaki et al., 2023" rid="ref-Sasaki2023" ref-type="bibr">Sasaki
    et al., 2023</xref>), one that involves the mean-square displacement
    of a particle with itself (<inline-formula><alternatives>
    <tex-math><![CDATA[\mathrm{MSD_{self}}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi mathvariant="normal">M</mml:mi><mml:mi mathvariant="normal">S</mml:mi><mml:msub><mml:mi mathvariant="normal">D</mml:mi><mml:mrow><mml:mi mathvariant="normal">s</mml:mi><mml:mi mathvariant="normal">e</mml:mi><mml:mi mathvariant="normal">l</mml:mi><mml:mi mathvariant="normal">f</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>)
    and another that represents the mean-squared displacement of a
    particle with all others (<inline-formula><alternatives>
    <tex-math><![CDATA[\mathrm{MSD_{distinct}}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi mathvariant="normal">M</mml:mi><mml:mi mathvariant="normal">S</mml:mi><mml:msub><mml:mi mathvariant="normal">D</mml:mi><mml:mrow><mml:mi mathvariant="normal">d</mml:mi><mml:mi mathvariant="normal">i</mml:mi><mml:mi mathvariant="normal">s</mml:mi><mml:mi mathvariant="normal">t</mml:mi><mml:mi mathvariant="normal">i</mml:mi><mml:mi mathvariant="normal">n</mml:mi><mml:mi mathvariant="normal">c</mml:mi><mml:mi mathvariant="normal">t</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>).
    <inline-formula><alternatives>
    <tex-math><![CDATA[\mathrm{MSD_{distinct}}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi mathvariant="normal">M</mml:mi><mml:mi mathvariant="normal">S</mml:mi><mml:msub><mml:mi mathvariant="normal">D</mml:mi><mml:mrow><mml:mi mathvariant="normal">d</mml:mi><mml:mi mathvariant="normal">i</mml:mi><mml:mi mathvariant="normal">s</mml:mi><mml:mi mathvariant="normal">t</mml:mi><mml:mi mathvariant="normal">i</mml:mi><mml:mi mathvariant="normal">n</mml:mi><mml:mi mathvariant="normal">c</mml:mi><mml:mi mathvariant="normal">t</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>
    accounts for the influence of many-atom correlations in ionic
    diffusive events. Typically, the distinct part of the MSD is
    neglected in order to accelerate the estimation and convergence of
    diffusion coefficients. However, many-ion correlations have been
    recently demonstrated to be essential in FIC
    (<xref alt="López et al., 2024b" rid="ref-Lopez2024" ref-type="bibr">López
    et al., 2024b</xref>) and hence should not be disregarded in
    practice. IonDiff provides a novel implementation of the full ionic
    diffusion coefficient calculation, exploiting the matrix
    representation of this calculation.</p>
    <p>The ionic conductivity (<inline-formula><alternatives>
    <tex-math><![CDATA[\sigma]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>σ</mml:mi></mml:math></alternatives></inline-formula>)
    is computed as
    (<xref alt="Sasaki et al., 2023" rid="ref-Sasaki2023" ref-type="bibr">Sasaki
    et al., 2023</xref>):</p>
    <p><disp-formula><alternatives>
    <tex-math><![CDATA[\begin{gathered}
            \sigma = \lim_{\Delta t \to \infty} \frac{e^2}{2 n_d V k_{\mathrm{B}} T} \left[ \sum_i z_i^2 \langle \left[ \mathbf{r}_i(t_0 + \Delta t) - \mathbf{r}_i(t_0) \right]^2 \rangle_{t_0} + \right. \\
            \left. + \sum_{i, j \neq i} z_i z_j \langle \left[ \mathbf{r}_i(t_0 + \Delta t) - \mathbf{r}_i(t_0) \right] \cdot \left[ \mathbf{r}_j(t_0 + \Delta t) - \mathbf{r}_j(t_0) \right] \rangle_{t_0} \right]
        \end{gathered}]]></tex-math>
    <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mtable><mml:mtr><mml:mtd columnalign="center" style="text-align: center"><mml:mi>σ</mml:mi><mml:mo>=</mml:mo><mml:munder><mml:mo>lim</mml:mo><mml:mrow><mml:mi>Δ</mml:mi><mml:mi>t</mml:mi><mml:mo>→</mml:mo><mml:mi>∞</mml:mi></mml:mrow></mml:munder><mml:mfrac><mml:msup><mml:mi>e</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mrow><mml:mn>2</mml:mn><mml:msub><mml:mi>n</mml:mi><mml:mi>d</mml:mi></mml:msub><mml:mi>V</mml:mi><mml:msub><mml:mi>k</mml:mi><mml:mi mathvariant="normal">B</mml:mi></mml:msub><mml:mi>T</mml:mi></mml:mrow></mml:mfrac><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mi>i</mml:mi></mml:munder><mml:msubsup><mml:mi>z</mml:mi><mml:mi>i</mml:mi><mml:mn>2</mml:mn></mml:msubsup><mml:mo stretchy="false" form="prefix">⟨</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:msub><mml:mi>𝐫</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:mi>Δ</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:msub><mml:mi>𝐫</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:msub><mml:mo stretchy="false" form="postfix">⟩</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:msub><mml:mo>+</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="center" style="text-align: center"><mml:mrow><mml:mi>+</mml:mi><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>≠</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:munder><mml:msub><mml:mi>z</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mi>z</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false" form="prefix">⟨</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:msub><mml:mi>𝐫</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:mi>Δ</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:msub><mml:mi>𝐫</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow><mml:mo>⋅</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:msub><mml:mi>𝐫</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:mi>Δ</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:msub><mml:mi>𝐫</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow><mml:msub><mml:mo stretchy="false" form="postfix">⟩</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:msub><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p>
    <p>where <inline-formula><alternatives>
    <tex-math><![CDATA[e]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>e</mml:mi></mml:math></alternatives></inline-formula>,
    <inline-formula><alternatives>
    <tex-math><![CDATA[V]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>V</mml:mi></mml:math></alternatives></inline-formula>,
    <inline-formula><alternatives>
    <tex-math><![CDATA[k_{\mathrm{B}}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>k</mml:mi><mml:mi mathvariant="normal">B</mml:mi></mml:msub></mml:math></alternatives></inline-formula>,
    and <inline-formula><alternatives>
    <tex-math><![CDATA[T]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>T</mml:mi></mml:math></alternatives></inline-formula>
    are the elementary charge, system volume, Boltzmann constant, and
    temperature of the MD simulation, respectively,
    <inline-formula><alternatives>
    <tex-math><![CDATA[z_i]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>z</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
    the ionic charge and <inline-formula><alternatives>
    <tex-math><![CDATA[\mathbf{r}_i = x_{1i} \hat{i} + x_{2i} \hat{j} + x_{3i} \hat{k}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>𝐫</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mn>1</mml:mn><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mover><mml:mi>i</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mo>+</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mn>2</mml:mn><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mover><mml:mi>j</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mo>+</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mn>3</mml:mn><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mover><mml:mi>k</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover></mml:mrow></mml:math></alternatives></inline-formula>
    the Cartesian position of particle <inline-formula><alternatives>
    <tex-math><![CDATA[i]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>i</mml:mi></mml:math></alternatives></inline-formula>,
    <inline-formula><alternatives>
    <tex-math><![CDATA[n_d]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>n</mml:mi><mml:mi>d</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
    the number of spatial dimensions, <inline-formula><alternatives>
    <tex-math><![CDATA[\Delta t]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>Δ</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
    the time window, and <inline-formula><alternatives>
    <tex-math><![CDATA[t_0]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>t</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:math></alternatives></inline-formula>
    the temporal offset of <inline-formula><alternatives>
    <tex-math><![CDATA[\Delta t]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>Δ</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>.
    Thus, for those simulations in which only one atomic species
    diffuses, the three-dimensional ionic diffusion coefficient
    reads:</p>
    <p><disp-formula><alternatives>
    <tex-math><![CDATA[\begin{gathered}
            D = \lim_{\Delta t \to \infty} \frac{1}{6 \Delta t} \left[ \sum_i \langle \left[ \mathbf{r}_i(t_0 + \Delta t) - \mathbf{r}_i(t_0) \right]^2 \rangle_{t_0} + \right. \\
            \left. + \sum_{i, j \neq i} \langle \left[ \mathbf{r}_i(t_0 + \Delta t) - \mathbf{r}_i(t_0) \right] \cdot \left[ \mathbf{r}_j(t_0 + \Delta t) - \mathbf{r}_j(t_0) \right] \rangle_{t_0} \right] = \\
            = \lim_{\Delta t \to \infty} \frac{1}{6 \Delta t} \left[ \mathrm{MSD_{self}} (\Delta t) + \mathrm{MSD_{distinct}} (\Delta t) \right]
        \end{gathered}]]></tex-math>
    <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mtable><mml:mtr><mml:mtd columnalign="center" style="text-align: center"><mml:mi>D</mml:mi><mml:mo>=</mml:mo><mml:munder><mml:mo>lim</mml:mo><mml:mrow><mml:mi>Δ</mml:mi><mml:mi>t</mml:mi><mml:mo>→</mml:mo><mml:mi>∞</mml:mi></mml:mrow></mml:munder><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mn>6</mml:mn><mml:mi>Δ</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:mfrac><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mi>i</mml:mi></mml:munder><mml:mo stretchy="false" form="prefix">⟨</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:msub><mml:mi>𝐫</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:mi>Δ</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:msub><mml:mi>𝐫</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:msub><mml:mo stretchy="false" form="postfix">⟩</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:msub><mml:mo>+</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="center" style="text-align: center"><mml:mrow><mml:mi>+</mml:mi><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>≠</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:munder><mml:mo stretchy="false" form="prefix">⟨</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:msub><mml:mi>𝐫</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:mi>Δ</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:msub><mml:mi>𝐫</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow><mml:mo>⋅</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:msub><mml:mi>𝐫</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:mi>Δ</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:msub><mml:mi>𝐫</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow><mml:msub><mml:mo stretchy="false" form="postfix">⟩</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:msub><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow><mml:mo>=</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="center" style="text-align: center"><mml:mo>=</mml:mo><mml:munder><mml:mo>lim</mml:mo><mml:mrow><mml:mi>Δ</mml:mi><mml:mi>t</mml:mi><mml:mo>→</mml:mo><mml:mi>∞</mml:mi></mml:mrow></mml:munder><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mn>6</mml:mn><mml:mi>Δ</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:mfrac><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mrow><mml:mi mathvariant="normal">M</mml:mi><mml:mi mathvariant="normal">S</mml:mi><mml:msub><mml:mi mathvariant="normal">D</mml:mi><mml:mrow><mml:mi mathvariant="normal">s</mml:mi><mml:mi mathvariant="normal">e</mml:mi><mml:mi mathvariant="normal">l</mml:mi><mml:mi mathvariant="normal">f</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>Δ</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mrow><mml:mi mathvariant="normal">M</mml:mi><mml:mi mathvariant="normal">S</mml:mi><mml:msub><mml:mi mathvariant="normal">D</mml:mi><mml:mrow><mml:mi mathvariant="normal">d</mml:mi><mml:mi mathvariant="normal">i</mml:mi><mml:mi mathvariant="normal">s</mml:mi><mml:mi mathvariant="normal">t</mml:mi><mml:mi mathvariant="normal">i</mml:mi><mml:mi mathvariant="normal">n</mml:mi><mml:mi mathvariant="normal">c</mml:mi><mml:mi mathvariant="normal">t</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>Δ</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p>
    <p>All the ionic displacements appearing in Eq. (2) can be computed
    just once and stored in a four-dimensional array, thus allowing for
    simple vectorization and fast processing with python libraries
    (e.g., numpy) as compared to traditional calculation loops. Then,
    for a simulation with <inline-formula><alternatives>
    <tex-math><![CDATA[n_t]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>n</mml:mi><mml:mi>t</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
    time steps, <inline-formula><alternatives>
    <tex-math><![CDATA[n_{\Delta t}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>n</mml:mi><mml:mrow><mml:mi>Δ</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>
    temporal windows, and <inline-formula><alternatives>
    <tex-math><![CDATA[n_p]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>n</mml:mi><mml:mi>p</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
    atoms for the diffusive species, we only need to compute:</p>
    <p><disp-formula><alternatives>
    <tex-math><![CDATA[\Delta x (\Delta t, i, d, t_0) = x_{di} (t_0 + \Delta t) - x_{di} (t_0)]]></tex-math>
    <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>Δ</mml:mi><mml:mi>x</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>Δ</mml:mi><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>d</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>d</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:mi>Δ</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>d</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></disp-formula></p>
    <p>being <inline-formula><alternatives>
    <tex-math><![CDATA[\Delta x(\Delta t, i, d, t_0)]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>Δ</mml:mi><mml:mi>x</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>Δ</mml:mi><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>d</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
    a four-dimensional array of dimension <inline-formula><alternatives>
    <tex-math><![CDATA[n_{\Delta t} \times n_t \times n_p \times n_d]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mrow><mml:mi>Δ</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>n</mml:mi><mml:mi>t</mml:mi></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>n</mml:mi><mml:mi>p</mml:mi></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>n</mml:mi><mml:mi>d</mml:mi></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>
    that stores all mean displacements of temporal length
    <inline-formula><alternatives>
    <tex-math><![CDATA[\Delta t]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>Δ</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
    for particle <inline-formula><alternatives>
    <tex-math><![CDATA[i]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>i</mml:mi></mml:math></alternatives></inline-formula>
    in space dimension <inline-formula><alternatives>
    <tex-math><![CDATA[d]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>d</mml:mi></mml:math></alternatives></inline-formula>.
    This leads to:</p>
    <p><disp-formula><alternatives>
    <tex-math><![CDATA[\begin{gathered}
            \mathrm{MSD_{self}} (\Delta t) = \frac{1}{n_p} \sum_{i = 1}^{n_p} \langle \sum_{d} \Delta x (\Delta t, i, d, t_0) \cdot \Delta x (\Delta t, i, d, t_0) \rangle_{t_0} \\
            \mathrm{MSD_{distinct}} (\Delta t) = \frac{2}{n_p (n_p-1)} \sum_{i = 1}^{n_p} \sum_{j = i+1}^{n_p} \langle \sum_{d} \Delta x (\Delta t, i, d, t_0) \cdot \Delta x (\Delta t, j, d, t_0) \rangle_{t_0}
        \end{gathered}]]></tex-math>
    <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mtable><mml:mtr><mml:mtd columnalign="center" style="text-align: center"><mml:mrow><mml:mi mathvariant="normal">M</mml:mi><mml:mi mathvariant="normal">S</mml:mi><mml:msub><mml:mi mathvariant="normal">D</mml:mi><mml:mrow><mml:mi mathvariant="normal">s</mml:mi><mml:mi mathvariant="normal">e</mml:mi><mml:mi mathvariant="normal">l</mml:mi><mml:mi mathvariant="normal">f</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>Δ</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:msub><mml:mi>n</mml:mi><mml:mi>p</mml:mi></mml:msub></mml:mfrac><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mi>p</mml:mi></mml:msub></mml:munderover><mml:mo stretchy="false" form="prefix">⟨</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mi>d</mml:mi></mml:munder><mml:mi>Δ</mml:mi><mml:mi>x</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>Δ</mml:mi><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>d</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>⋅</mml:mo><mml:mi>Δ</mml:mi><mml:mi>x</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>Δ</mml:mi><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>d</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:msub><mml:mo stretchy="false" form="postfix">⟩</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="center" style="text-align: center"><mml:mrow><mml:mi mathvariant="normal">M</mml:mi><mml:mi mathvariant="normal">S</mml:mi><mml:msub><mml:mi mathvariant="normal">D</mml:mi><mml:mrow><mml:mi mathvariant="normal">d</mml:mi><mml:mi mathvariant="normal">i</mml:mi><mml:mi mathvariant="normal">s</mml:mi><mml:mi mathvariant="normal">t</mml:mi><mml:mi mathvariant="normal">i</mml:mi><mml:mi mathvariant="normal">n</mml:mi><mml:mi mathvariant="normal">c</mml:mi><mml:mi mathvariant="normal">t</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>Δ</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mn>2</mml:mn><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mi>p</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>n</mml:mi><mml:mi>p</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:mfrac><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mi>p</mml:mi></mml:msub></mml:munderover><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mi>p</mml:mi></mml:msub></mml:munderover><mml:mo stretchy="false" form="prefix">⟨</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mi>d</mml:mi></mml:munder><mml:mi>Δ</mml:mi><mml:mi>x</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>Δ</mml:mi><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>d</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>⋅</mml:mo><mml:mi>Δ</mml:mi><mml:mi>x</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>Δ</mml:mi><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>d</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:msub><mml:mo stretchy="false" form="postfix">⟩</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p>
    <p>Note that we keep <inline-formula><alternatives>
    <tex-math><![CDATA[D_{\mathrm{self}}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mi mathvariant="normal">s</mml:mi><mml:mi mathvariant="normal">e</mml:mi><mml:mi mathvariant="normal">l</mml:mi><mml:mi mathvariant="normal">f</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>
    and <inline-formula><alternatives>
    <tex-math><![CDATA[D_{\mathrm{distinct}}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mi mathvariant="normal">d</mml:mi><mml:mi mathvariant="normal">i</mml:mi><mml:mi mathvariant="normal">s</mml:mi><mml:mi mathvariant="normal">t</mml:mi><mml:mi mathvariant="normal">i</mml:mi><mml:mi mathvariant="normal">n</mml:mi><mml:mi mathvariant="normal">c</mml:mi><mml:mi mathvariant="normal">t</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>
    separate since this allows for a straightforward evaluation of the
    <inline-formula><alternatives>
    <tex-math><![CDATA[D]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>D</mml:mi></mml:math></alternatives></inline-formula>
    contributions resulting from the ionic correlations without
    increasing the code complexity.</p>
    <p>In terms of memory resources, this implementation scales linearly
    with the length of the temporal window, the total duration of the
    simulation and the number of mobile ions.</p>
  </sec>
  <sec id="ionic-hop-identification">
    <title>Ionic hop identification</title>
    <p>Our method for identifying vibrational centers from sequential
    ionic configurations relies on k-means clustering, an unsupervised
    machine learning algorithm. This method assumes isotropy in the
    fluctuations of non-diffusive particles. Importantly, our approach
    circumvents the need for defining arbitrary, materials-dependent
    threshold distances to analyze ionic hops.</p>
    <p>K-means algorithm constructs spherical groups that, for every
    subgroup <inline-formula><alternatives>
    <tex-math><![CDATA[G_I]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>G</mml:mi><mml:mi>I</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
    in a dataset, minimize the sum of squares:</p>
    <p><disp-formula><alternatives>
    <tex-math><![CDATA[\sum_{i \in G_I} \min \left( \| \mathbf{x}_i - \boldsymbol{\mu}_I \|^2 \right)]]></tex-math>
    <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi>G</mml:mi><mml:mi>I</mml:mi></mml:msub></mml:mrow></mml:munder><mml:mo>min</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mo stretchy="false" form="postfix">∥</mml:mo><mml:msub><mml:mi>𝐱</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>𝛍</mml:mi><mml:mi>I</mml:mi></mml:msub><mml:msup><mml:mo stretchy="false" form="postfix">∥</mml:mo><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></disp-formula></p>
    <p>where <inline-formula><alternatives>
    <tex-math><![CDATA[\mathbf{x}_i]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>𝐱</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
    are data points and <inline-formula><alternatives>
    <tex-math><![CDATA[\boldsymbol{\mu}_I]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>𝛍</mml:mi><mml:mi>I</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
    the mean at <inline-formula><alternatives>
    <tex-math><![CDATA[G_I]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>G</mml:mi><mml:mi>I</mml:mi></mml:msub></mml:math></alternatives></inline-formula>.</p>
    <p>This approach is particularly well-suited for crystals, as atoms
    typically fluctuate isotropically around their equilibrium
    positions. For materials where atoms exhibit strong anisotropic
    vibrations, IonDiff also permits the selection of alternative
    clustering schemes, such as spectral clustering, which is effective
    for cases where group adjacency is significant. Nevertheless, in a
    previous work
    (<xref alt="López et al., 2024b" rid="ref-Lopez2024" ref-type="bibr">López
    et al., 2024b</xref>), it was found that the performance of k-means
    clustering in identifying ionic hops in standard and technologically
    relevant fast-ion conductors was generally superior to that of other
    clustering approaches.</p>
    <p>The number of clusters, or equivalently, ionic vibrational
    centers, determined by IonDiff for a molecular dynamics (MD)
    simulation is the one that maximizes the average silhouette ratio.
    This metric assesses the similarity of a point within its own
    cluster and its dissimilarity in comparison to other clusters. The
    average silhouette ratio is defined as:</p>
    <p><disp-formula><alternatives>
    <tex-math><![CDATA[S = \left \langle \frac{b(i) - a(i)}{\max{(a(i), b(i))}} \right \rangle_i]]></tex-math>
    <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>S</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">⟨</mml:mo><mml:mfrac><mml:mrow><mml:mi>b</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mi>a</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mo>max</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>a</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:mfrac><mml:mo stretchy="true" form="postfix">⟩</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></alternatives></disp-formula></p>
    <p>where:</p>
    <p><disp-formula><alternatives>
    <tex-math><![CDATA[\begin{gathered}
            a(i) = \frac{1}{|G_I| - 1} \sum_{l \in G_I} \| \mathbf{x}_i - \mathbf{x}_l \|^2  \\
            b(i) = \min_{J \neq I} \left( \frac{1}{|G_J|} \sum_{l \in G_J} \| \mathbf{x}_i - \mathbf{x}_l \|^2 \right)
        \end{gathered}]]></tex-math>
    <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mtable><mml:mtr><mml:mtd columnalign="center" style="text-align: center"><mml:mi>a</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mrow><mml:mo stretchy="true" form="prefix">|</mml:mo><mml:msub><mml:mi>G</mml:mi><mml:mi>I</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">|</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfrac><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>l</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi>G</mml:mi><mml:mi>I</mml:mi></mml:msub></mml:mrow></mml:munder><mml:mo stretchy="false" form="postfix">∥</mml:mo><mml:msub><mml:mi>𝐱</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>𝐱</mml:mi><mml:mi>l</mml:mi></mml:msub><mml:msup><mml:mo stretchy="false" form="postfix">∥</mml:mo><mml:mn>2</mml:mn></mml:msup></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="center" style="text-align: center"><mml:mi>b</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:munder><mml:mo>min</mml:mo><mml:mrow><mml:mi>J</mml:mi><mml:mo>≠</mml:mo><mml:mi>I</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mo stretchy="true" form="prefix">|</mml:mo><mml:msub><mml:mi>G</mml:mi><mml:mi>J</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">|</mml:mo></mml:mrow></mml:mfrac><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>l</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi>G</mml:mi><mml:mi>J</mml:mi></mml:msub></mml:mrow></mml:munder><mml:mo stretchy="false" form="postfix">∥</mml:mo><mml:msub><mml:mi>𝐱</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>𝐱</mml:mi><mml:mi>l</mml:mi></mml:msub><mml:msup><mml:mo stretchy="false" form="postfix">∥</mml:mo><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p>
    <p>Once the number of vibrational centers, along with their
    real-space location and temporal evolution, are determined, ionic
    diffusion paths are delineated as the segments connecting two
    distinct vibrational centers over time
    <xref alt="[fig:diffusion-detection]" rid="figU003Adiffusion-detection">[fig:diffusion-detection]</xref>.
    In other words, the points located between different ionic
    vibrational centers, that is, different k-means clusters, are
    regarded as part of the ionic diffusion path connecting them. Due to
    the discrete nature of the generated trajectories and intricacies of
    the k-means clustering approach, establishing the precise start and
    end points of ionic diffusion paths is challenging. Consequently, we
    adopt an arbitrary yet physically plausible threshold distance of
    0.5 Å from the midpoint of the vibrational centers to define the
    extremities of diffusive trajectories. Tests performed in
    (<xref alt="López et al., 2024b" rid="ref-Lopez2024" ref-type="bibr">López
    et al., 2024b</xref>) have shown that reasonable variations of this
    parameter value have negligible effects on the analysis results
    obtained with IonDiff.</p>
  </sec>
  <sec id="correlations-between-mobile-ions">
    <title>Correlations between mobile ions</title>
    <p>To quantitatively evaluate the correlations and level of
    concertation between a variable number of mobile ions, we developed
    the following algorithm. Beginning with a given sequence of ionic
    configurations from a molecular dynamics simulation, we compute the
    correlation matrix for diffusive events. Initially, we assign a
    value of “1” to each diffusing particle and “0” to each vibrating
    particle at every time frame. This binary assignment is facilitated
    by the ionic hop identification algorithm introduced earlier.</p>
    <p>Due to the discrete nature of the ionic trajectories and to
    enhance numerical convergence in subsequent correlation analysis,
    the multistep time functions are approximated using Gaussians with
    widths equal to their half-maxima (commonly known as the
    “full-width-at-half-maximum” or FWHM method used in signal
    processing). Subsequently, we compute the
    <inline-formula><alternatives>
    <tex-math><![CDATA[N \times N]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>N</mml:mi><mml:mo>×</mml:mo><mml:mi>N</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
    correlation matrix, where <inline-formula><alternatives>
    <tex-math><![CDATA[N]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>N</mml:mi></mml:math></alternatives></inline-formula>
    represents the number of potentially mobile ions, using all gathered
    simulation data. However, this correlation matrix may be challenging
    to converge due to its statistical nature, especially in scenarios
    with limited mobile ions and time steps, typical of AIMD
    simulations.</p>
    <p>Moreover, uncorrelated ion hops occurring simultaneously could be
    erroneously interpreted as correlated. To address these practical
    challenges, we compute a reference correlation matrix based on a
    randomly distributed sequence of ionic hops, with the Gaussian FWHM
    matching the mean diffusion time determined during the simulation.
    It is important to note that due to the finite width of the
    Gaussians, this reference matrix is not exactly the identity
    matrix.</p>
    <p>Next, covariance coefficients in the original correlation matrix
    larger (smaller) than the corresponding random reference values were
    considered as true correlations (random noise) and rounded off to
    one (zero) for simplification. To ensure an accurate assessment of
    many-ion correlations, different hops of the same ion are treated as
    independent events. Ultimately, this process results in a
    correlation matrix comprising ones and zeros, facilitating the
    determination of the number of particles that remain concerted
    during diffusion.</p>
  </sec>
</sec>
<sec id="acknowledgements">
  <title>Acknowledgements</title>
  <p>C.C. acknowledges support from the Spanish Ministry of Science,
  Innovation, and Universities under the fellowship RYC2018-024947-I and
  PID2020-112975GB-I00 and grant TED2021-130265B-C22. C.L. acknowledges
  support from the Spanish Ministry of Science, Innovation, and
  Universities under the FPU grant, and the CSIC under the “JAE Intro
  SOMdM 2021” grant program. The authors thankfully acknowledge the
  computer resources at MareNostrum, and the technical support provided
  by Barcelona Supercomputing Center (FI-1-0006, FI-2022-2-0003,
  FI-2023-1-0002, FI-2023-2-0004, and FI-2023-3-0004). R.R. acknowledges
  financial support from the MCIN/AEI/10.13039/501100011033 under grant
  no. PID2020-119777GB-I00, the Severo Ochoa Centres of Excellence
  Program (CEX2019-000917-S), and the Generalitat de Catalunya under
  grant no. 2017SGR1506.</p>
</sec>
</body>
<back>
<ref-list>
  <title></title>
  <ref id="ref-database">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>López</surname><given-names>C.</given-names></name>
        <name><surname>Rurali</surname><given-names>R.</given-names></name>
        <name><surname>Cazorla</surname><given-names>C.</given-names></name>
      </person-group>
      <article-title>DFT-AIMD database</article-title>
      <source>NOMAD</source>
      <year iso-8601-date="2024">2024</year>
      <pub-id pub-id-type="doi">10.17172/NOMAD/2024.04.01-1</pub-id>
    </element-citation>
  </ref>
  <ref id="ref-Lopez2023">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>López</surname><given-names>C.</given-names></name>
        <name><surname>Emperador</surname><given-names>A.</given-names></name>
        <name><surname>Saucedo</surname><given-names>E. et al.</given-names></name>
      </person-group>
      <article-title>Universal ion-transport descriptors and classes of inorganic solid-state electrolytes</article-title>
      <source>Mater. Horiz.</source>
      <year iso-8601-date="2023">2023</year>
      <volume>10</volume>
      <pub-id pub-id-type="doi">10.1039/D2MH01516A</pub-id>
      <fpage>1757</fpage>
      <lpage>1768</lpage>
    </element-citation>
  </ref>
  <ref id="ref-Lopez2024">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>López</surname><given-names>C.</given-names></name>
        <name><surname>Rurali</surname><given-names>R.</given-names></name>
        <name><surname>Cazorla</surname><given-names>C.</given-names></name>
      </person-group>
      <article-title>How concerted are ionic hops in inorganic solid-state electrolytes?</article-title>
      <source>J. Am. Chem. Soc.</source>
      <year iso-8601-date="2024">2024</year>
      <volume>146</volume>
      <pub-id pub-id-type="doi">10.1021/jacs.3c13279</pub-id>
      <fpage>8269</fpage>
      <lpage>8279</lpage>
    </element-citation>
  </ref>
  <ref id="ref-Pedregosa2011">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Pedregosa</surname><given-names>F.</given-names></name>
        <name><surname>Varoquaux</surname><given-names>G.</given-names></name>
        <name><surname>Gramfort</surname><given-names>A.</given-names></name>
      </person-group>
      <article-title>Scikit-learn: Machine learning in Python</article-title>
      <source>J. Mach. Learn. Res.</source>
      <year iso-8601-date="2011">2011</year>
      <volume>12</volume>
      <pub-id pub-id-type="doi">10.48550/arXiv.1201.0490</pub-id>
      <fpage>2825</fpage>
      <lpage>2830</lpage>
    </element-citation>
  </ref>
  <ref id="ref-Harris2020">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Harris</surname><given-names>C. R.</given-names></name>
        <name><surname>Millman</surname><given-names>K. J.</given-names></name>
        <name><surname>van der Walt</surname><given-names>S. J. et al.</given-names></name>
      </person-group>
      <article-title>Array programming with NumPy</article-title>
      <source>Nature</source>
      <year iso-8601-date="2020">2020</year>
      <volume>585</volume>
      <pub-id pub-id-type="doi">10.1038/s41586-020-2649-2</pub-id>
      <fpage>357</fpage>
      <lpage>362</lpage>
    </element-citation>
  </ref>
  <ref id="ref-Hunter2007">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Hunter</surname><given-names>J. D.</given-names></name>
      </person-group>
      <article-title>Matplotlib: A 2D graphics environment</article-title>
      <source>Comput. Sci. Eng.</source>
      <year iso-8601-date="2007">2007</year>
      <volume>9</volume>
      <pub-id pub-id-type="doi">10.1109/MCSE.2007.55</pub-id>
      <fpage>90</fpage>
      <lpage>95</lpage>
    </element-citation>
  </ref>
  <ref id="ref-Kresse1996">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Kresse</surname><given-names>G.</given-names></name>
        <name><surname>Furthmüller</surname><given-names>J.</given-names></name>
      </person-group>
      <article-title>Efficient iterative schemes for ab initio total-energy calculations using a plane-wave basis set</article-title>
      <source>Phys. Rev. B</source>
      <year iso-8601-date="1996">1996</year>
      <volume>54</volume>
      <pub-id pub-id-type="doi">10.1103/PhysRevB.54.11169</pub-id>
      <fpage>11169</fpage>
      <lpage></lpage>
    </element-citation>
  </ref>
  <ref id="ref-Molinari2021">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Molinari</surname><given-names>N.</given-names></name>
        <name><surname>Xie</surname><given-names>Y.</given-names></name>
        <name><surname>Leifer</surname><given-names>I.</given-names></name>
        <name><surname>Marcolongo</surname><given-names>A.</given-names></name>
        <name><surname>Kornbluth</surname><given-names>M.</given-names></name>
        <name><surname>Kozinsky</surname><given-names>B.</given-names></name>
      </person-group>
      <article-title>Spectral denoising for accelerated analysis of correlated ionic transport</article-title>
      <source>Phys. Rev. Lett.</source>
      <year iso-8601-date="2021">2021</year>
      <volume>127</volume>
      <pub-id pub-id-type="doi">10.1103/PhysRevLett.127.025901</pub-id>
      <fpage>025901</fpage>
      <lpage></lpage>
    </element-citation>
  </ref>
  <ref id="ref-Sasaki2023">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Sasaki</surname><given-names>R.</given-names></name>
        <name><surname>Gao</surname><given-names>B.</given-names></name>
        <name><surname>Hitosugi</surname><given-names>T.</given-names></name>
        <name><surname>Tateyama</surname><given-names>Y.</given-names></name>
      </person-group>
      <article-title>Nonequilibrium molecular dynamics for accelerated computation of ion–ion correlated conductivity beyond Nernst–Einstein limitation</article-title>
      <source>npj Comput. Mater.</source>
      <year iso-8601-date="2023">2023</year>
      <volume>9</volume>
      <pub-id pub-id-type="doi">10.1038/s41524-023-00996-8</pub-id>
      <fpage>48</fpage>
      <lpage></lpage>
    </element-citation>
  </ref>
  <ref id="ref-Hull2004">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Hull</surname><given-names>S.</given-names></name>
      </person-group>
      <article-title>Superionics: crystal structures and conduction processes</article-title>
      <source>Rep. Prog. Phys.</source>
      <year iso-8601-date="2004">2004</year>
      <volume>67</volume>
      <pub-id pub-id-type="doi">10.1088/0034-4885/67/7/R05</pub-id>
      <fpage>1233</fpage>
      <lpage></lpage>
    </element-citation>
  </ref>
  <ref id="ref-Sagotra2017">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Sagotra</surname><given-names>A. K.</given-names></name>
        <name><surname>Cazorla</surname><given-names>C.</given-names></name>
      </person-group>
      <article-title>Stress-mediated enhancement of ionic conductivity in fast-ion conductors</article-title>
      <source>ACS Appl. Mater. Interfaces.</source>
      <year iso-8601-date="2017">2017</year>
      <volume>9</volume>
      <pub-id pub-id-type="doi">10.1021/acsami.7b11687</pub-id>
      <fpage>38773</fpage>
      <lpage></lpage>
    </element-citation>
  </ref>
</ref-list>
</back>
</article>
