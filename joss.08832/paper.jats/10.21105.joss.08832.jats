<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN"
                  "JATS-publishing1.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" dtd-version="1.2" article-type="other">
<front>
<journal-meta>
<journal-id></journal-id>
<journal-title-group>
<journal-title>Journal of Open Source Software</journal-title>
<abbrev-journal-title>JOSS</abbrev-journal-title>
</journal-title-group>
<issn publication-format="electronic">2475-9066</issn>
<publisher>
<publisher-name>Open Journals</publisher-name>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="publisher-id">8832</article-id>
<article-id pub-id-type="doi">10.21105/joss.08832</article-id>
<title-group>
<article-title>Type Enforced: A Python type enforcer for type
annotations</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author" corresp="yes">
<contrib-id contrib-id-type="orcid">https://orcid.org/0009-0005-1522-022X</contrib-id>
<name>
<surname>Makowski</surname>
<given-names>Connor</given-names>
</name>
<xref ref-type="aff" rid="aff-1"/>
<xref ref-type="corresp" rid="cor-1"><sup>*</sup></xref>
</contrib>
<contrib contrib-type="author">
<contrib-id contrib-id-type="orcid">https://orcid.org/0009-0002-1638-4726</contrib-id>
<name>
<surname>Guter</surname>
<given-names>Willem</given-names>
</name>
<xref ref-type="aff" rid="aff-1"/>
</contrib>
<contrib contrib-type="author">
<contrib-id contrib-id-type="orcid">https://orcid.org/0000-0001-8399-9339</contrib-id>
<name>
<surname>Russell</surname>
<given-names>Timothy</given-names>
</name>
<xref ref-type="aff" rid="aff-1"/>
</contrib>
<aff id="aff-1">
<institution-wrap>
<institution>Massachusetts Institute of Technology Cambridge, United
States</institution>
<institution-id institution-id-type="ROR">042nb2s44</institution-id>
</institution-wrap>
</aff>
</contrib-group>
<author-notes>
<corresp id="cor-1">* E-mail: <email></email></corresp>
</author-notes>
<pub-date date-type="pub" publication-format="electronic" iso-8601-date="2025-05-30">
<day>30</day>
<month>5</month>
<year>2025</year>
</pub-date>
<volume>10</volume>
<issue>113</issue>
<fpage>8832</fpage>
<permissions>
<copyright-statement>Authors of papers retain copyright and release the
work under a Creative Commons Attribution 4.0 International License (CC
BY 4.0)</copyright-statement>
<copyright-year>2025</copyright-year>
<copyright-holder>The article authors</copyright-holder>
<license license-type="open-access" xlink:href="https://creativecommons.org/licenses/by/4.0/">
<license-p>Authors of papers retain copyright and release the work under
a Creative Commons Attribution 4.0 International License (CC BY
4.0)</license-p>
</license>
</permissions>
<kwd-group kwd-group-type="author">
<kwd>Python</kwd>
<kwd>type</kwd>
<kwd>typing</kwd>
<kwd>typeguard</kwd>
<kwd>enforce</kwd>
<kwd>pydantic</kwd>
</kwd-group>
</article-meta>
</front>
<body>
<sec id="summary">
  <title>Summary</title>
  <p><monospace>type_enforced</monospace> is a pure Python package
  designed to enforce type annotations at runtime without the need for a
  special compiler. It provides an intuitive decorator-based interface
  that allows developers to enforce explicit typing constraints on
  function and method inputs, return types, dataclasses, and class
  instances. The package supports a comprehensive set of Python’s
  built-in types, typing module constructs (such as
  <monospace>List</monospace>, <monospace>Dict</monospace>,
  <monospace>Union</monospace>, <monospace>Optional</monospace>, and
  <monospace>Literal</monospace>), nested data structures, and custom
  constraints. By offering runtime validation of type annotations and
  constraints, <monospace>type_enforced</monospace> enhances code
  reliability, readability, and maintainability.</p>
</sec>
<sec id="statement-of-need">
  <title>Statement of Need</title>
  <p>Python’s dynamic typing system offers flexibility but can lead to
  runtime errors that are difficult to diagnose in web applications,
  complex scientific software, and research applications. Static type
  checking tools such as Mypy provide valuable compile-time validation;
  however, they do not prevent runtime type errors. Existing runtime
  enforcement libraries often require extensive boilerplate code or lack
  support for advanced typing features and nested structures.</p>
  <p>The <monospace>type_enforced</monospace> package addresses these
  limitations by providing robust runtime enforcement of Python type
  annotations with comparable speed when compared to
  <ext-link ext-link-type="uri" xlink:href="https://github.com/connor-makowski/type_enforced/blob/main/benchmark.md">benchmarking</ext-link>.
  It supports advanced typing features including nested iterables, union
  types, dataclasses, inheritance-based validation, uninitialized class
  type checks, and custom constraints
  (<monospace>Constraint</monospace>,
  <monospace>GenericConstraint</monospace>). This functionality is
  particularly important for research software development, where
  correctness of data types is critical for reproducibility and
  reliability.</p>
  <p>In scientific computing, <monospace>type_enforced</monospace> helps
  ensure the correctness of numerical simulations, validates complex
  machine learning data pipelines, and reduces subtle runtime errors
  that could compromise reproducibility. It has proven valuable in
  collaborative environments, such as transportation modeling and
  logistics optimization, where contributors with varying Python
  expertise develop models that must integrate seamlessly through APIs
  or shared workflows. By catching type mismatches early,
  <monospace>type_enforced</monospace> improves the robustness and
  trustworthiness of research software.</p>
</sec>
<sec id="functionality-and-features">
  <title>Functionality and Features</title>
  <p>Key features provided by the package include:</p>
  <list list-type="bullet">
    <list-item>
      <p><bold>Decorator-based enforcement</bold>: Easily apply
      enforcement to functions, methods, classes, static methods, class
      methods, and dataclasses.</p>
    </list-item>
    <list-item>
      <p><bold>Comprehensive typing support</bold>: Supports built-in
      Python types (<monospace>int</monospace>,
      <monospace>str</monospace>, <monospace>list</monospace>,
      <monospace>dict</monospace>, etc.), typing module constructs
      (<monospace>List</monospace>, <monospace>Dict</monospace>,
      <monospace>Union</monospace>, <monospace>Optional</monospace>,
      <monospace>Literal</monospace>, <monospace>Any</monospace>), union
      types (<monospace>int | float</monospace>), nested structures
      (<monospace>dict[str, dict[str, int]]</monospace>), and deeply
      nested iterables (<monospace>list[set[str]]</monospace>).</p>
    </list-item>
    <list-item>
      <p><bold>Custom constraints</bold>: Validate input values with
      built-in constraint classes (e.g., numerical bounds) or
      user-defined generic constraints (e.g., membership in a predefined
      set).</p>
    </list-item>
    <list-item>
      <p><bold>Inheritance-aware validation</bold>: Validate instances
      against class hierarchies. Inheritance-aware validation allows any
      subclass to pass type checks if the parent class is expected
      (e.g., accepting a MySubclass instance for a parameter of type
      MyParentClass).</p>
    </list-item>
    <list-item>
      <p><bold>Validate class instances and classes</bold>: Type
      enforcement supports both class instance and uninitialized class
      object validation, enabling flexible function signatures for
      factory methods and advanced patterns.</p>
    </list-item>
    <list-item>
      <p><bold>Flexible enable/disable mechanism</bold>: Enable or
      disable enforcement selectively at the function or class level to
      accommodate debugging versus production environments.</p>
    </list-item>
  </list>
</sec>
<sec id="related-work">
  <title>Related Work</title>
  <p>Python’s ecosystem for type checking and data validation is rich
  and rapidly evolving, reflecting the growing need for both static and
  runtime type safety in scientific and production code. The landscape
  can be broadly divided into static type checkers, runtime type
  checkers, and project-based frameworks. Recent empirical studies, such
  as
  (<xref alt="Rak-amnouykit et al., 2020" rid="ref-Rak-amnouykitU003A2020" ref-type="bibr">Rak-amnouykit
  et al., 2020</xref>), have analyzed the adoption and semantics of
  Python’s type systems in real-world codebases, highlighting both the
  promise and the challenges of practical type enforcement.</p>
  <sec id="static-type-checkers">
    <title>Static Type Checkers</title>
    <p>Static type checkers analyze code before execution, using type
    hints to catch potential errors and improve code reliability without
    incurring runtime overhead.</p>
    <list list-type="bullet">
      <list-item>
        <p><bold>Mypy</bold>
        (<xref alt="Lehtosalo &amp; Mypy contributors, 2012" rid="ref-LehtosaloU003A2012" ref-type="bibr">Lehtosalo
        &amp; Mypy contributors, 2012</xref>): Mypy is the most widely
        adopted static type checker for Python, implementing a
        conventional static type system based on PEP 484. It enforces
        fixed variable types and reports errors when type annotations
        are violated. As detailed by
        (<xref alt="Rak-amnouykit et al., 2020" rid="ref-Rak-amnouykitU003A2020" ref-type="bibr">Rak-amnouykit
        et al., 2020</xref>), Mypy represents the canonical approach to
        static type checking in Python, and its semantics have become a
        baseline for evaluating new type inference tools.</p>
      </list-item>
      <list-item>
        <p><bold>Pyright</bold>
        (<xref alt="Microsoft Corporation, 2025" rid="ref-pyrightU003A2025" ref-type="bibr">Microsoft
        Corporation, 2025</xref>): A fast type checker developed by
        Microsoft, offering real-time feedback in editors.</p>
      </list-item>
      <list-item>
        <p><bold>PyType</bold>
        (<xref alt="Google, 2024" rid="ref-pytypeU003A2025" ref-type="bibr">Google,
        2024</xref>): Developed by Google, PyType also provides static
        analysis and type inference for Python code, but with a distinct
        approach. Unlike Mypy, PyType maintains separate type
        environments for different branches in control flow and can
        infer more precise union types for variables that take on
        multiple types. The comparative study by
        (<xref alt="Rak-amnouykit et al., 2020" rid="ref-Rak-amnouykitU003A2020" ref-type="bibr">Rak-amnouykit
        et al., 2020</xref>) shows that PyType and Mypy differ in their
        handling of type joins, attribute typing, and error reporting,
        reflecting broader trade-offs in static analysis for dynamic
        languages.</p>
      </list-item>
    </list>
  </sec>
  <sec id="runtime-type-checkers-and-data-validation">
    <title>Runtime Type Checkers and Data Validation</title>
    <p>Runtime type checkers enforce type constraints as the program
    executes, which is particularly valuable when handling external data
    or integrating with user-facing APIs.</p>
    <list list-type="bullet">
      <list-item>
        <p><bold>Pydantic</bold>
        (<xref alt="Colvin et al., 2017" rid="ref-ColvinU003A2017" ref-type="bibr">Colvin
        et al., 2017</xref>): Pydantic is a widely used library for
        runtime data validation targed at dataclass like objects,
        leveraging type hints to enforce data schemas and automatically
        cast input values. It is central to frameworks like FastAPI and
        is particularly effective for validating input from untrusted
        sources.</p>
      </list-item>
      <list-item>
        <p><bold>Typeguard</bold>
        (<xref alt="Grönholm, 2016" rid="ref-GronholmU003A2016" ref-type="bibr">Grönholm,
        2016</xref>): Typeguard offers single type level runtime
        enforcement of function type annotations, raising errors when
        arguments or return values violate declared types. It is
        lightweight and integrates easily into existing codebases.</p>
      </list-item>
      <list-item>
        <p><bold>Enforce</bold>
        (<xref alt="Keith‑Magee, 2016" rid="ref-KeithMageeU003A2016" ref-type="bibr">Keith‑Magee,
        2016</xref>): Provides basic runtime enforcement but does not
        support advanced typing features such as deeply nested
        structures or constraint-based validations.</p>
      </list-item>
      <list-item>
        <p><bold>Marshmallow</bold>:
        (<xref alt="Loria, 2013" rid="ref-LoriaU003A2013" ref-type="bibr">Loria,
        2013</xref>):Marshmallow provides serialization,
        deserialization, and validation of complex data structures, with
        support for custom validation logic. It is commonly used in web
        frameworks for API data validation.</p>
      </list-item>
      <list-item>
        <p><bold>type_enforced</bold>: In contrast to the above,
        <monospace>type_enforced</monospace> offers decorator-based
        runtime enforcement of Python type annotations, including
        support for nested structures, custom constraints, and
        inheritance-aware validation. Its focus is on minimal
        boilerplate and compatibility with modern Python typing
        constructs, making it suitable for research and collaborative
        environments where correctness and ease of use are
        paramount.</p>
      </list-item>
    </list>
  </sec>
  <sec id="discussion">
    <title>Discussion</title>
    <p>The diversity of tools reflects the dual nature of Python’s type
    system—supporting both static and dynamic paradigms. As
    (<xref alt="Rak-amnouykit et al., 2020" rid="ref-Rak-amnouykitU003A2020" ref-type="bibr">Rak-amnouykit
    et al., 2020</xref>) demonstrate, the adoption of type annotations
    is increasing, but real-world usage patterns remain heterogeneous,
    and the semantics of type checking tools can differ in subtle but
    important ways. Packages like <monospace>type_enforced</monospace>
    complement this landscape by providing runtime guarantees that
    static checkers cannot, especially in collaborative or data-driven
    research settings. Compared to these tools,
    <monospace>type_enforced</monospace> uniquely combines comprehensive
    type annotation enforcement with powerful constraint validation
    capabilities and inheritance-aware checks.</p>
  </sec>
</sec>
<sec id="usage-example">
  <title>Usage Example</title>
  <p>A simple example demonstrating basic usage:</p>
  <code language="python">import type_enforced

@type_enforced.Enforcer()
def calculate_area(width: int | float, height: int | float) -&gt; int | float:
    return width * height

calculate_area(3.0, 4.5)   # Passes
calculate_area('3', 4.5)   # Raises TypeError at runtime</code>
  <p>An example demonstrating constraint validation:</p>
  <code language="python">import type_enforced
from type_enforced.utils import Constraint

@type_enforced.Enforcer()
def positive_integer(value: int | Constraint(ge=0)) -&gt; int:
    return value

positive_integer(10)   # Passes
positive_integer(-5)   # Raises TypeError due to constraint violation</code>
</sec>
<sec id="acknowledgments">
  <title>Acknowledgments</title>
  <p>Development of this software was supported by:</p>
  <list list-type="bullet">
    <list-item>
      <p>MIT Center for Transportation &amp; Logistics (CTL)</p>
    </list-item>
    <list-item>
      <p>MIT Computational Analytics, Visualization &amp; Education Lab
      (CAVE)</p>
    </list-item>
  </list>
</sec>
</body>
<back>
<ref-list>
  <title></title>
  <ref id="ref-ColvinU003A2017">
    <element-citation publication-type="software">
      <person-group person-group-type="author">
        <name><surname>Colvin</surname><given-names>Samuel</given-names></name>
        <name><surname>Jolibois</surname><given-names>Eric</given-names></name>
        <name><surname>Ramezani</surname><given-names>Hasan</given-names></name>
        <name><surname>Garcia Badaracco</surname><given-names>Adrian</given-names></name>
        <name><surname>Dorsey</surname><given-names>Terrence</given-names></name>
        <name><surname>Montague</surname><given-names>David</given-names></name>
        <name><surname>Matveenko</surname><given-names>Serge</given-names></name>
        <name><surname>Trylesinski</surname><given-names>Marcelo</given-names></name>
        <name><surname>Runkle</surname><given-names>Sydney</given-names></name>
        <name><surname>Hewitt</surname><given-names>David</given-names></name>
        <name><surname>Hall</surname><given-names>Alex</given-names></name>
        <name><surname>Plot</surname><given-names> Victorien</given-names></name>
      </person-group>
      <article-title>Pydantic (v2.11.7)</article-title>
      <publisher-name>Zenodo</publisher-name>
      <year iso-8601-date="2017">2017</year>
      <date-in-citation content-type="access-date"><year iso-8601-date="2025-07-01">2025</year><month>07</month><day>01</day></date-in-citation>
      <uri>https://doi.org/10.5281/zenodo.15662245</uri>
      <pub-id pub-id-type="doi">10.5281/zenodo.15662245</pub-id>
    </element-citation>
  </ref>
  <ref id="ref-GronholmU003A2016">
    <element-citation publication-type="software">
      <person-group person-group-type="author">
        <name><surname>Grönholm</surname><given-names>Alex</given-names></name>
      </person-group>
      <article-title>Typeguard</article-title>
      <year iso-8601-date="2016">2016</year>
      <date-in-citation content-type="access-date"><year iso-8601-date="2025-07-01">2025</year><month>07</month><day>01</day></date-in-citation>
      <uri>https://github.com/agronholm/typeguard</uri>
    </element-citation>
  </ref>
  <ref id="ref-LehtosaloU003A2012">
    <element-citation publication-type="software">
      <person-group person-group-type="author">
        <name><surname>Lehtosalo</surname><given-names>Jukka</given-names></name>
        <name><surname>Mypy contributors</surname></name>
      </person-group>
      <article-title>Mypy</article-title>
      <year iso-8601-date="2012">2012</year>
      <date-in-citation content-type="access-date"><year iso-8601-date="2025-07-01">2025</year><month>07</month><day>01</day></date-in-citation>
      <uri>https://github.com/python/mypy</uri>
    </element-citation>
  </ref>
  <ref id="ref-KeithMageeU003A2016">
    <element-citation publication-type="software">
      <person-group person-group-type="author">
        <name><surname>Keith‑Magee</surname><given-names>Russell</given-names></name>
      </person-group>
      <article-title>Enforce</article-title>
      <year iso-8601-date="2016">2016</year>
      <date-in-citation content-type="access-date"><year iso-8601-date="2025-07-01">2025</year><month>07</month><day>01</day></date-in-citation>
      <uri>https://github.com/RussBaz/enforce</uri>
    </element-citation>
  </ref>
  <ref id="ref-LoriaU003A2013">
    <element-citation publication-type="software">
      <person-group person-group-type="author">
        <name><surname>Loria</surname><given-names>Steven</given-names></name>
      </person-group>
      <article-title>marshmallow</article-title>
      <year iso-8601-date="2013">2013</year>
      <date-in-citation content-type="access-date"><year iso-8601-date="2025-07-01">2025</year><month>07</month><day>01</day></date-in-citation>
      <uri>https://github.com/marshmallow-code/marshmallow</uri>
    </element-citation>
  </ref>
  <ref id="ref-Rak-amnouykitU003A2020">
    <element-citation publication-type="paper-conference">
      <person-group person-group-type="author">
        <name><surname>Rak-amnouykit</surname><given-names>Ingkarat</given-names></name>
        <name><surname>McCrevan</surname><given-names>Daniel</given-names></name>
        <name><surname>Milanova</surname><given-names>Ana</given-names></name>
        <name><surname>Hirzel</surname><given-names>Martin</given-names></name>
        <name><surname>Dolby</surname><given-names>Julian</given-names></name>
      </person-group>
      <article-title>Python 3 Types in the Wild: A Tale of Two Type Systems</article-title>
      <source>Proceedings of the 16th ACM SIGPLAN international symposium on dynamic languages</source>
      <publisher-name>ACM</publisher-name>
      <publisher-loc>Virtual USA</publisher-loc>
      <year iso-8601-date="2020-11-17">2020</year><month>11</month><day>17</day>
      <date-in-citation content-type="access-date"><year iso-8601-date="2025-09-20">2025</year><month>09</month><day>20</day></date-in-citation>
      <isbn>978-1-4503-8175-8</isbn>
      <uri>https://dl.acm.org/doi/10.1145/3426422.3426981</uri>
      <pub-id pub-id-type="doi">10.1145/3426422.3426981</pub-id>
      <fpage>57</fpage>
      <lpage>70</lpage>
    </element-citation>
  </ref>
  <ref id="ref-pyrightU003A2025">
    <element-citation publication-type="software">
      <person-group person-group-type="author">
        <string-name>Microsoft Corporation</string-name>
      </person-group>
      <article-title>Pyright</article-title>
      <year iso-8601-date="2025">2025</year>
      <date-in-citation content-type="access-date"><year iso-8601-date="2025-09-21">2025</year><month>09</month><day>21</day></date-in-citation>
      <uri>https://github.com/microsoft/pyright</uri>
    </element-citation>
  </ref>
  <ref id="ref-pytypeU003A2025">
    <element-citation publication-type="software">
      <person-group person-group-type="author">
        <name><surname>Google</surname></name>
      </person-group>
      <article-title>Pytype</article-title>
      <year iso-8601-date="2024">2024</year>
      <date-in-citation content-type="access-date"><year iso-8601-date="2025-09-21">2025</year><month>09</month><day>21</day></date-in-citation>
      <uri>https://github.com/google/pytype</uri>
    </element-citation>
  </ref>
</ref-list>
</back>
</article>
